/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/musictheoryjs/dist/musictheory.js":
/*!********************************************************!*\
  !*** ./node_modules/musictheoryjs/dist/musictheory.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

(function (global, factory) {
    true ? factory(exports) :
   0;
})(this, (function (exports) { 'use strict';

   /**
    * Notes starting at C0 - zero index - 12 total
    * Maps note names to semitone values starting at C=0
    * @enum
    */
   var Semitone;
   (function (Semitone) {
       Semitone[Semitone["A"] = 9] = "A";
       Semitone[Semitone["As"] = 10] = "As";
       Semitone[Semitone["Bb"] = 10] = "Bb";
       Semitone[Semitone["B"] = 11] = "B";
       Semitone[Semitone["Bs"] = 0] = "Bs";
       Semitone[Semitone["Cb"] = 11] = "Cb";
       Semitone[Semitone["C"] = 0] = "C";
       Semitone[Semitone["Cs"] = 1] = "Cs";
       Semitone[Semitone["Db"] = 1] = "Db";
       Semitone[Semitone["D"] = 2] = "D";
       Semitone[Semitone["Ds"] = 3] = "Ds";
       Semitone[Semitone["Eb"] = 3] = "Eb";
       Semitone[Semitone["E"] = 4] = "E";
       Semitone[Semitone["Es"] = 5] = "Es";
       Semitone[Semitone["Fb"] = 4] = "Fb";
       Semitone[Semitone["F"] = 5] = "F";
       Semitone[Semitone["Fs"] = 6] = "Fs";
       Semitone[Semitone["Gb"] = 6] = "Gb";
       Semitone[Semitone["G"] = 7] = "G";
       Semitone[Semitone["Gs"] = 8] = "Gs";
       Semitone[Semitone["Ab"] = 8] = "Ab";
   })(Semitone || (Semitone = {}));
   /**
    * Returns the whole note name (e.g. C, D, E, F, G, A, B) for
    * the given string
    * @internal
    */
   const getWholeToneFromName = (name) => {
       if (!name || name.length === 0 || name.length > 1)
           throw new Error("Invalid name");
       const key = name[0].toUpperCase();
       return Semitone[key];
   };
   var Semitone$1 = Semitone;

   /**
    * Wraps a number between a min and max value.
    * @param value - the number to wrap
    * @param lower  - the lower bound
    * @param upper - the upper bound
    * @returns wrappedNumber - the wrapped number
    * @internal
    */
   const wrap = (value, lower, upper) => {
       // copies
       let val = value;
       let lbound = lower;
       let ubound = upper;
       // if the bounds are inverted, swap them here
       if (upper < lower) {
           lbound = upper;
           ubound = lower;
       }
       // the amount needed to move the range and value to zero
       const zeroOffset = 0 - lbound;
       // offset the values so that the lower bound is zero
       lbound += zeroOffset;
       ubound += zeroOffset;
       val += zeroOffset;
       // compute the number of times the value will wrap
       let wraps = Math.trunc(val / ubound);
       // case: -1 / ubound(>0) will equal 0 although it wraps once
       if (wraps === 0 && val < lbound)
           wraps = -1;
       // case: ubound and value are the same val/ubound = 1 but actually doesnt wrap
       if (wraps === 1 && val === ubound)
           wraps = 0;
       // needed to handle the case where the num of wraps is 0 or 1 or -1
       let valOffset = 0;
       let wrapOffset = 0;
       if (wraps >= -1 && wraps <= 1)
           wrapOffset = 1;
       // if the value is below the range
       if (val < lbound) {
           valOffset = (val % ubound) + wrapOffset;
           val = ubound + valOffset;
           // if the value is above the range
       }
       else if (val > ubound) {
           valOffset = (val % ubound) - wrapOffset;
           val = lbound + valOffset;
       }
       // add the offset from zero back to the value
       val -= zeroOffset;
       return {
           value: val,
           numWraps: wraps,
       };
   };

   /**
    * Simple util to clamp a number to a range
    * @param pNum - the number to clamp
    * @param pLower - the lower bound
    * @param pUpper - the upper bound
    * @returns Number - the clamped number
    *
    * @internal
    */
   const clamp = (pNum, pLower, pUpper) => Math.max(Math.min(pNum, Math.max(pLower, pUpper)), Math.min(pLower, pUpper));

   //**********************************************************
   // Constants
   //**********************************************************
   const MODIFIED_SEMITONES = [1, 3, 4, 6, 8, 10];
   const TONES_MAX = 11;
   const TONES_MIN = 0;
   const OCTAVE_MAX = 9;
   const OCTAVE_MIN = 0;
   const DEFAULT_OCTAVE = 4;
   const DEFAULT_SEMITONE = 0;

   /**
    * Maps note alterations to  their relative mathmatical value
    *@enum
    */
   var Modifier;
   (function (Modifier) {
       Modifier[Modifier["FLAT"] = -1] = "FLAT";
       Modifier[Modifier["NATURAL"] = 0] = "NATURAL";
       Modifier[Modifier["SHARP"] = 1] = "SHARP";
   })(Modifier || (Modifier = {}));
   /**
    * Parses modifier from string and returns the enum value
    * @internal
    */
   const parseModifier = (modifier) => {
       switch (modifier) {
           case "b":
           case "flat":
               return Modifier.FLAT;
           case "#":
           case "s":
           case "sharp":
               return Modifier.SHARP;
           default:
               return Modifier.NATURAL;
       }
   };
   var Modifier$1 = Modifier;

   // import { registerInitializer } from "../Initializer/Initializer";
   // import table from "./noteLookup.json";
   // import fs from "fs";
   //**********************************************************
   /**
    * Regex for matching note name, modifier, and octave
    */
   //**********************************************************
   const nameRegex$2 = /([A-G])/g;
   const modifierRegex$2 = /(#|s|b)/g;
   const octaveRegex$2 = /([0-9]+)/g;
   //**********************************************************
   /**
    * attempts to parse a note from a string
    */
   //**********************************************************
   const parseNote = (note, supressWarning = false) => {
       try {
           const result = noteLookup(note);
           if (result) {
               return result;
           }
           if (!supressWarning)
               console.warn(`Ineffecient note string formatting - ${note}. Get a performance increase by using the format [A-G][#|s|b][0-9] and using buildTables method(see documentation)`);
       }
       catch (err) {
           if (!supressWarning)
               console.warn(`Ineffecient note string formatting - ${note}. Get a performance increase by using the format [A-G][#|s|b][0-9] and using buildTables method(see documentation)`);
       }
       let noteIdenifier = "";
       let noteModifier = 0;
       let noteOctave = "";
       const nameMatch = note.match(nameRegex$2)?.join("").split("");
       const modifierMatch = note.match(modifierRegex$2)?.join("").split("");
       const octaveMatch = note.match(octaveRegex$2)?.join("").split("");
       // combine all modifiers
       if (modifierMatch) {
           if (modifierMatch.length > 1) {
               // combine all modifiers into an offeset value to be added to the semitone
               noteModifier = modifierMatch
                   .map((item) => parseModifier(item))
                   .reduce((a, b) => a + b);
           }
           else {
               noteModifier = parseModifier(modifierMatch[0]);
           }
       }
       if (octaveMatch) {
           const [octave] = octaveMatch;
           noteOctave = octave;
       }
       if (nameMatch) {
           const [noteName] = nameMatch;
           noteIdenifier = noteName;
           let modifier = 0;
           if (noteModifier)
               modifier = noteModifier;
           const wrappedTone = wrap(getWholeToneFromName(noteIdenifier) + modifier, TONES_MIN, TONES_MAX);
           const semitone = wrappedTone.value;
           let octave = 4;
           if (noteOctave)
               octave = clamp(parseInt(noteOctave, 10), OCTAVE_MIN, OCTAVE_MAX);
           return {
               semitone: semitone,
               octave: octave,
           };
       }
       throw new Error(`Invalid note: ${note}`);
   };
   //**********************************************************
   /**
    * creates a lookup table for all notes formatted as [A-G][#|b|s][0-9]
    */
   //**********************************************************
   const createTable$4 = () => {
       const noteTable = {};
       const noteLetters = ["A", "B", "C", "D", "E", "F", "G"];
       const noteModifiers = ["b", "#", "s"];
       for (const noteLabel of noteLetters) {
           noteTable[noteLabel] = parseNote(noteLabel, true); // 'C' for example
           for (let iModifierOuter = 0; iModifierOuter < noteModifiers.length; ++iModifierOuter) {
               const key = `${noteLabel}${noteModifiers[iModifierOuter]}`;
               noteTable[key] = parseNote(key, true); // 'C#' for example
           }
           for (let iOctave = OCTAVE_MIN; iOctave < OCTAVE_MAX; ++iOctave) {
               const key = `${noteLabel}${iOctave}`;
               noteTable[key] = parseNote(key, true); // 'C4' for example
               for (let iModifier = 0; iModifier < noteModifiers.length; ++iModifier) {
                   const key = `${noteLabel}${noteModifiers[iModifier]}${iOctave}`;
                   noteTable[key] = parseNote(key, true); // 'C#4' for example
               }
           }
       }
       return noteTable;
   };
   /**
    * The lookup table
    */
   let _noteLookup = {};
   const noteLookup = (key) => {
       // buildNoteTable();
       return _noteLookup[key];
   };
   // registerInitializer(() => {
   //    _noteLookup = createTable();
   // });
   // if (table && Object.keys(table).length > 0) {
   //    _noteLookup = table;
   // } else {
   //    _noteLookup = createTable();
   // }
   const buildNoteTable = () => {
       _noteLookup = createTable$4();
       Object.freeze(_noteLookup);
       console.log("built note table");
       return _noteLookup;
   };

   // import { registerInitializer } from "../Initializer/Initializer";
   // import table from "./noteStringLookup.json";
   const UNKNOWN_MODIFIER_NOTE_STRINGS = [
       "C",
       "C#/Db",
       "D",
       "D#/Eb",
       "E",
       "F",
       "F#/Gb",
       "G",
       "G#/Ab",
       "A",
       "A#/Bb",
       "B",
   ];
   const SHARP_NOTE_STRINGS = [
       "C",
       "C#",
       "D",
       "D#",
       "E",
       "F",
       "F#",
       "G",
       "G#",
       "A",
       "A#",
       "B",
   ];
   const FLAT_MODIFIER_NOTE_STRINGS = [
       "C",
       "Db",
       "D",
       "Eb",
       "E",
       "F",
       "Gb",
       "G",
       "Ab",
       "A",
       "Bb",
       "B",
   ];
   const createTable$3 = () => {
       const table = {};
       for (let iTone = TONES_MIN; iTone <= TONES_MAX; ++iTone) {
           for (let iPrev = TONES_MIN; iPrev <= TONES_MAX; ++iPrev) {
               // for (let iOctave = OCTAVE_MIN; iOctave <= OCTAVE_MAX; iOctave++) {
               let modifier = "";
               if (MODIFIED_SEMITONES.includes(iTone)) {
                   modifier = "-"; // has an unknown modifier
                   // if is flat
                   if (wrap(iTone + 1, TONES_MIN, TONES_MAX).value === iPrev)
                       modifier = "b";
                   // is sharp
                   if (wrap(iTone - 1, TONES_MIN, TONES_MAX).value === iPrev)
                       modifier = "#";
               }
               // get note name from table
               table[`${iTone}-${iPrev}`] = getNoteLabel(iTone, modifier);
           }
           // }
       }
       return table;
   };
   const getNoteLabel = (tone, modifier) => {
       switch (modifier) {
           case "#":
               return SHARP_NOTE_STRINGS[tone];
           case "b":
               return FLAT_MODIFIER_NOTE_STRINGS[tone];
           case "-":
           default:
               return UNKNOWN_MODIFIER_NOTE_STRINGS[tone];
       }
   };
   let _noteStringLookup = {};
   const noteStringLookup = (key) => {
       // buildNoteStringTable();
       if (Object.keys(_noteStringLookup).length === 0)
           buildNoteStringTable();
       return _noteStringLookup[key];
   };
   // registerInitializer(() => {
   //    _noteStringLookup = createTable();
   // });
   // if (table && Object.keys(table).length > 0) {
   //    _noteStringLookup = table;
   // } else {
   //    _noteStringLookup = createTable();
   // }
   const buildNoteStringTable = () => {
       // if (Object.keys(_noteStringLookup).length > 0) return _noteStringLookup;
       _noteStringLookup = createTable$3();
       Object.freeze(_noteStringLookup);
       console.log("Note string table built.");
       return _noteStringLookup;
   };

   var IDX=256, HEX=[], SIZE=256, BUFFER;
   while (IDX--) HEX[IDX] = (IDX + 256).toString(16).substring(1);

   function uid(len) {
   	var i=0, tmp=(len || 11);
   	if (!BUFFER || ((IDX + tmp) > SIZE*2)) {
   		for (BUFFER='',IDX=0; i < SIZE; i++) {
   			BUFFER += HEX[Math.random() * 256 | 0];
   		}
   	}

   	return BUFFER.substring(IDX, IDX++ + tmp);
   }

   // import Identifiable from "../composables/Identifiable";
   /**
    * A note consist of a semitone and an octave.<br>
    *
    * @example
    * ```javascript
    * import { Note } from "musictheoryjs";
    * import { NoteInitializer } from "musictheoryjs"; // typescript only if needed
    * ```
    */
   class Note {
       /**
        * @example
        * ```javascript
        * import { Note } from "musictheoryjs";
        *
        * // creates a new note with default values semitone 0(C) and octave 4
        * const note = new Note();
        *
        * // creates a new note using an initializer object
        * const note = new Note({semitone: 4, octave: 5});
        *
        * // String parsing should follow the format: note-name[modifier][octave]
        * // creates a new note using a string
        * const note = new Note("C5");
        * ```
        */
       constructor(values) {
           if (!values) {
               this.octave = DEFAULT_OCTAVE;
               this.semitone = DEFAULT_SEMITONE;
           }
           else if (typeof values === "string") {
               values = parseNote(values);
               this.octave = values?.octave ?? DEFAULT_OCTAVE;
               this.semitone = values?.semitone ?? DEFAULT_SEMITONE;
               this._prevSemitone = this._tone;
           }
           else {
               // important that octave is set first so that
               // setting the semitone can change the octave
               this.octave = values?.octave ?? DEFAULT_OCTAVE;
               this.semitone = values?.semitone ?? DEFAULT_SEMITONE;
               this._prevSemitone = this._tone;
           }
       }
       /**
        *  unique id for this note(auto generated)
        * @example
        * ```javascript
        * const note = new Note();
        * console.log(note.id); // s2898snloj
        * ```
        */
       id = uid();
       /**
        * semitone
        */
       _tone = DEFAULT_SEMITONE;
       _prevSemitone = DEFAULT_SEMITONE;
       /**
        * @example
        * ```javascript
        * const note = new Note();
        * console.log(note.semitone); // 0
        * ```
        */
       get semitone() {
           return this._tone;
       }
       /**
        * setting the semitone with a number outside the
        * range of 0-11 will wrap the value around and
        * change the octave accordingly
        * @example
        * ```javascript
        * const note = new Note();
        * note.semitone = 4;// E
        * console.log(note.semitone); // 4(E)
        * ```
        */
       set semitone(semitone) {
           const wrapped = wrap(semitone, TONES_MIN, TONES_MAX);
           this._prevSemitone = this._tone;
           this._tone = wrapped.value;
           this._octave = this._octave + wrapped.numWraps;
       }
       /**
        * octave
        */
       _octave = DEFAULT_OCTAVE;
       /**
        * @example
        * ```javascript
        * const note = new Note();
        * console.log(note.octave); // 4
        * ```
        */
       get octave() {
           return this._octave;
       }
       /**
        * The octave is clamped to the range [0, 9].
        * @example
        * ```javascript
        * const note = new Note();
        * note.octave = 10;
        * console.log(note.octave); // 9(because of clamping)
        * ```
        */
       set octave(octave) {
           this._octave = clamp(octave, OCTAVE_MIN, OCTAVE_MAX);
       }
       /**
        * @chainable
        * @returns a new note that is a sharpened version of this note.
        * @example
        * ```javascript
        * const note = new Note(); // default semitone is 0(C)
        * const note2 = note.sharp();
        * console.log(note2.semitone); // 1(C#)
        * ```
        */
       sharp() {
           return new Note({
               semitone: this.semitone,
               octave: this.octave,
           }).sharpen();
       }
       /**
        * Sharpens the note in place.
        * @chainable
        * @example
        * ```javascript
        * const note = new Note(); // default semitone is 0(C)
        * note.sharpen();
        * console.log(note.semitone); // 1(C#)
        */
       sharpen() {
           this.semitone = this.semitone + 1;
           return this;
       }
       /**
        *  attempts to determine if the note is sharp
        * @returns true if the note is sharp
        * @example
        * ```javascript
        * const note = new Note(); // default semitone is 0(C)
        * console.log(note.isSharp()); // false
        * note.sharpen();
        * console.log(note.isSharp()); // true
        * ```
        */
       isSharp() {
           // if note is whole, it can't be sharp
           const modified = MODIFIED_SEMITONES.includes(this.semitone);
           if (!modified)
               return false;
           // if note is flat, it can't be sharp
           if (wrap(this.semitone + 1, TONES_MIN, TONES_MAX).value ===
               this._prevSemitone)
               return false; //is flat
           // Doesn't neccecarily mean it's sharp, but it's a good guess at this point
           return true;
       }
       /**
        * Returns a new note that is a flattened version of this note.
        * @chainable
        * @returns a new note that is a flattened version of this note.
        * @example
        * ```javascript
        * const note = new Note(); // default semitone is 0(C)
        * const note2 = note.flat();
        * console.log(note2.semitone); // 3(Eb)
        * ```
        */
       flat() {
           return new Note({
               semitone: this.semitone,
               octave: this.octave,
           }).flatten();
       }
       /**
        * Flattens the note in place.
        * @chainable
        * @example
        * ```javascript
        * const note = new Note({semitone: 4}); //  semitone is 4(E)
        * note.flatten();
        * console.log(note.semitone); // 3(Eb)
        * ```
        */
       flatten() {
           this.semitone = this.semitone - 1;
           return this;
       }
       /**
        *  attempts to determine if the note is flat
        * @returns true if the note is flat
        * @example
        * ```javascript
        * const note = new Note(); // default semitone is 0(C)
        * console.log(note.isFlat()); // false
        * note.flatten();
        * console.log(note.isFlat()); // true
        * ```
        */
       isFlat() {
           // if note is whole, it can't be sharp
           const modified = MODIFIED_SEMITONES.includes(this.semitone);
           if (!modified)
               return false;
           // if note is sharp, it can't be flat
           if (wrap(this.semitone - 1, TONES_MIN, TONES_MAX).value ===
               this._prevSemitone)
               return false; //is sharp
           // Doesn't neccecarily mean it's flat, but it's a good guess at this point
           return true;
       }
       /**
        * @returns true if this note is equal to the given note
        * @example
        * ```javascript
        * const note = new Note();
        * const note2 = new Note();
        * console.log(note.equals(note2)); // true
        * ```
        */
       equals(note) {
           return this.semitone === note.semitone && this.octave === note.octave;
       }
       /**
        * @returns a copy of this note
        * @example
        * ```javascript
        * const note = new Note(); // default semitone is 0(C)
        * const note2 = note.copy();
        * console.log(note.equals(note2)); // true
        * ```
        */
       copy() {
           return new Note({
               semitone: this.semitone,
               octave: this.octave,
           });
       }
       /**
        * Returns a string version of this note
        * @example
        * ```javascript
        * const note = new Note(); // default semitone is 0(C)
        * console.log(note.toString()); // C4
        * ```
        *
        */
       toString() {
           // console.log(noteStringLookup);
           return (noteStringLookup(`${this._tone}-${this._prevSemitone}`) +
               `${this._octave}`);
       }
       /**
        * Static methods to create whole notes easily.
        * the default octave is 4
        */
       /**
        * @static
        * @param octave
        * @returns note set to A[octave]
        * @example
        * ```javascript
        * const note = Note.A();
        * console.log(note.toString()); // A4
        * ```
        */
       static A(octave = 4) {
           return new Note({
               semitone: Semitone$1.A,
               octave,
           });
       }
       /**
        *
        * @static
        * @param octave
        * @returns note set to B[octave]
        * @example
        * ```javascript
        * const note = Note.B();
        * console.log(note.toString()); // B4
        * ```
        */
       static B(octave = 4) {
           return new Note({
               semitone: Semitone$1.B,
               octave,
           });
       }
       /**
        *
        * @static
        * @param octave
        * @returns note set to C[octave]
        * @example
        * ```javascript
        * const note = Note.C();
        * console.log(note.toString()); // C4
        * ```
        */
       static C(octave = 4) {
           return new Note({
               semitone: Semitone$1.C,
               octave,
           });
       }
       /**
        *
        * @static
        * @param octave
        * @returns note set to D[octave]
        * @example
        * ```javascript
        * const note = Note.D();
        * console.log(note.toString()); // D4
        * ```
        */
       static D(octave = 4) {
           return new Note({
               semitone: Semitone$1.D,
               octave,
           });
       }
       /**
        *
        * @static
        * @param octave
        * @returns note set to E[octave]
        * @example
        * ```javascript
        * const note = Note.E();
        * console.log(note.toString()); // E4
        * ```
        */
       static E(octave = 4) {
           return new Note({
               semitone: Semitone$1.E,
               octave,
           });
       }
       /**
        *
        * @static
        * @param octave
        * @returns note set to F[octave]
        * @example
        * ```javascript
        * const note = Note.F();
        * console.log(note.toString()); // F4
        * ```
        */
       static F(octave = 4) {
           return new Note({
               semitone: Semitone$1.F,
               octave,
           });
       }
       /**
        *
        * @static
        * @param octave
        * @returns note set to G[octave]
        * @example
        * ```javascript
        * const note = Note.G();
        * console.log(note.toString()); // G4
        * ```
        */
       static G(octave = 4) {
           return new Note({
               semitone: Semitone$1.G,
               octave,
           });
       }
   }

   /**
    * Constants
    */
   const MIDIKEY_START = 12;
   const NUM_OCTAVES = 10;
   const NUM_SEMITONES = 12;
   /**
    * Calculates the midi key for a given octave and semitone.
    */
   const calcMidiKey = (octave, semitone) => MIDIKEY_START + octave * NUM_SEMITONES + semitone;
   /**
    * Calculates the frequency for a given octave and semitone given
    * a tuning for a4.
    */
   const calcFrequency = (midiKey, a4Tuning) => 2 ** ((midiKey - 69) / 12) * a4Tuning;
   /**
    * Creates and return lookup tables for midikey and frequency.
    */
   const createTables = (a4Tuning = 440) => {
       /**
        * Maps octave and semitone to note frequency(hertz).
        * requires a key in the form of `<octave>-<semitone>`
        */
       const freqTable = {};
       /**
        * Maps octave and semitone to midi key.
        * requires a key in the form of `<octave>-<semitone>`
        */
       const midiTable = {};
       let iOctave = 0;
       let iSemitone = 0;
       for (iOctave = 0; iOctave < NUM_OCTAVES; ++iOctave) {
           for (iSemitone = 0; iSemitone < NUM_SEMITONES; ++iSemitone) {
               const key = `${iOctave}-${iSemitone}`;
               const mkey = calcMidiKey(iOctave, iSemitone);
               const freq = calcFrequency(mkey, a4Tuning);
               midiTable[key] = mkey;
               freqTable[key] = freq;
           }
       }
       return {
           freqLookup: freqTable,
           midiLookup: midiTable,
       };
   };

   /**
    * Tuning component used by Instrument class<br>
    * containes the a4 tuning - default is 440Hz<br>
    * builds lookup tables for midi key and frequency<br>
    * based on the tuning
    * @internal
    */
   class Tuning {
       /**
        * Creates the object and builds the lookup tables.
        */
       constructor(a4Freq = 440) {
           this._a4 = a4Freq;
           this.buildTables();
       }
       /**
        * unique id for this instance
        */
       id = uid();
       copy() {
           return new Tuning(this._a4);
       }
       equals(other) {
           return this._a4 === other._a4;
       }
       /**
        * a4 Tuning
        */
       _a4 = 440;
       get a4() {
           return this._a4;
       }
       /**
        * setting the tuning will rebuild the lookup tables
        */
       set a4(value) {
           this._a4 = value;
           this.buildTables();
       }
       /**
        * lookup table for midi key
        */
       _midiKeyTable = {};
       midiKeyLookup(octave, semitone) {
           const key = `${octave}-${semitone}`;
           return this._midiKeyTable[key];
       }
       /**
        * lookup table for frequency
        */
       _freqTable = {};
       freqLookup(octave, semitone) {
           const key = `${octave}-${semitone}`;
           return this._freqTable[key];
       }
       /**
        * Builds the lookup tables for midi key and frequency
        */
       buildTables() {
           const tables = createTables(this._a4);
           this._midiKeyTable = tables.midiLookup;
           this._freqTable = tables.freqLookup;
       }
       /**
        * returns the tuning as a string
        */
       toString() {
           return `Tuning(${this._a4})`;
       }
   }

   /**
    * Instrument are used to encapsulate the tuning and retrieving of midi keys
    * and frequencies for notes
    *
    * @example
    * ```javascript
    * import { Instrument } from "musictheoryjs";
    */
   class Instrument {
       tuning;
       /**
        * @param tuning A4 frequency - defaults to 440
        * @example
        * ```javascript
        * const instrument = new Instrument(); // default 440 tuning
        * ```
        */
       constructor(a4Freq = 440) {
           this.tuning = new Tuning(a4Freq);
       }
       /**
        * @returns a unique id for this instance
        * @example
        * ```javascript
        * const instrument = new Instrument();
        * instrument.id; // returns a unique id
        * ```
        */
       id = uid();
       /**
        * @chainable
        * @returns a copy of this instance
        * @example
        * ```javascript
        * const instrument = new Instrument();
        * const copy = instrument.copy();
        * console.log(instrument.equals(copy)); // true
        * ```
        */
       copy() {
           return new Instrument(this.tuning.a4);
       }
       /**
        * @param other the other object to compare
        * @returns  true if the other object is equal to this one
        * @example
        * ```javascript
        * const instrument = new Instrument();
        * const copy = instrument.copy();
        * console.log(instrument.equals(copy)); // true
        * ```
        */
       equals(other) {
           return this.tuning.equals(other.tuning);
       }
       /**
        * @returns the frequency of the given note
        * @example
        * ```javascript
        * const instrument = new Instrument();
        * instrument.getFrequency(new Note("C4")); // returns 261.6255653005986
        * ```
        */
       getFrequency(note) {
           return this.tuning.freqLookup(note.octave, note.semitone);
       }
       /**
        * @returns the midi key of the given note
        * @example
        * ```javascript
        * const instrument = new Instrument();
        * instrument.getMidiKey(new Note("C4")); // returns 60
        * ```
        */
       getMidiKey(note) {
           return this.tuning.midiKeyLookup(note.octave, note.semitone);
       }
       /**
        * @returns the tuning as a string
        * @example
        * ```javascript
        * const instrument = new Instrument();
        * console.log(instrument.toString()); // returns "Instrument Tuning(440)"
        * ```
        */
       toString() {
           return `Instrument Tuning(${this.tuning.a4})`;
       }
   }

   const DEFAULT_SCALE_TEMPLATE = [0, 2, 2, 1, 2, 2, 2]; // major
   Object.freeze(DEFAULT_SCALE_TEMPLATE);

   /**
    * Maps predefined scales to their names.
    */
   const ScaleTemplates = {
       wholeTone: [0, 2, 2, 2, 2, 2, 2],
       // major
       major: [0, 2, 2, 1, 2, 2, 2],
       major7s4s5: [0, 2, 2, 2, 2, 1, 2],
       // modes
       // ionian: [], // set below - same as major
       // aeolian: [], // set below - same as minor
       dorian: [0, 2, 1, 2, 2, 2, 1],
       phrygian: [0, 1, 2, 2, 2, 1, 2],
       lydian: [0, 2, 2, 2, 1, 2, 2],
       lydianDominant: [0, 2, 2, 2, 1, 2, 1],
       // acoustic: [], // set below - same as lydianDominant
       mixolydian: [0, 2, 2, 1, 2, 2, 1],
       mixolydianFlat6: [0, 2, 2, 1, 2, 1, 2],
       locrian: [0, 1, 2, 2, 1, 2, 2],
       superLocrian: [0, 1, 2, 1, 2, 2, 2],
       // minor
       minor: [0, 2, 1, 2, 2, 1, 2],
       minor7b9: [0, 1, 2, 2, 2, 2, 1],
       minor7b5: [0, 2, 1, 2, 1, 2, 2],
       // halfDiminished: [], // set below - same as minor7b5
       // harmonic
       harmonicMajor: [0, 2, 2, 1, 2, 1, 3],
       harmonicMinor: [0, 2, 1, 2, 2, 1, 3],
       doubleHarmonic: [0, 1, 3, 1, 2, 1, 3],
       // byzantine: [], // set below - same as doubleHarmonic
       // melodic
       melodicMinorAscending: [0, 2, 1, 2, 2, 2, 2],
       melodicMinorDescending: [0, 2, 2, 1, 2, 2, 1],
       // pentatonic
       majorPentatonic: [0, 2, 2, 3, 2],
       majorPentatonicBlues: [0, 2, 1, 1, 3, 2],
       minorPentatonic: [0, 3, 2, 2, 3],
       minorPentatonicBlues: [0, 3, 2, 1, 1, 3],
       b5Pentatonic: [0, 3, 2, 1, 4, 2],
       minor6Pentatonic: [0, 3, 2, 2, 2, 3],
       // enigmatic
       enigmaticMajor: [0, 1, 3, 2, 2, 2, 1],
       enigmaticMinor: [0, 1, 2, 3, 1, 3, 1],
       // 8Tone
       dim8Tone: [0, 2, 1, 2, 1, 2, 1, 2],
       dom8Tone: [0, 1, 2, 1, 2, 1, 2, 1],
       // neapolitan
       neapolitanMajor: [0, 1, 2, 2, 2, 2, 2],
       neapolitanMinor: [0, 1, 2, 2, 2, 1, 3],
       // hungarian
       hungarianMajor: [0, 3, 1, 2, 1, 2, 1],
       hungarianMinor: [0, 2, 1, 3, 1, 1, 3],
       hungarianGypsy: [0, 1, 3, 1, 2, 1, 3],
       // spanish
       spanish: [0, 1, 2, 1, 2, 2, 2],
       spanish8Tone: [0, 1, 2, 1, 1, 1, 2, 2],
       // jewish: [], // set below - same as spanish8Tone
       spanishGypsy: [0, 1, 3, 1, 2, 1, 2],
       // aug dom
       augmented: [0, 3, 1, 3, 1, 3, 1],
       dominantSuspended: [0, 2, 3, 2, 2, 1, 2],
       // bebop
       bebopMajor: [0, 2, 2, 1, 2, 1, 1, 2],
       bebopDominant: [0, 2, 2, 1, 2, 2, 1, 1],
       mystic: [0, 2, 2, 2, 3, 2],
       overtone: [0, 2, 2, 2, 1, 1, 2],
       leadingTone: [0, 2, 2, 2, 2, 2, 1],
       // japanese
       hirojoshi: [0, 2, 1, 4, 1],
       japaneseA: [0, 1, 4, 1, 3],
       japaneseB: [0, 2, 3, 1, 3],
       // cultures
       oriental: [0, 1, 3, 1, 1, 3, 1],
       persian: [0, 1, 4, 1, 2, 3],
       arabian: [0, 2, 2, 1, 1, 2, 2],
       balinese: [0, 1, 2, 4, 1],
       kumoi: [0, 2, 1, 4, 2, 2],
       pelog: [0, 1, 2, 3, 1, 1],
       algerian: [0, 2, 1, 2, 1, 1, 1, 3],
       chinese: [0, 4, 2, 1, 4],
       mongolian: [0, 2, 2, 3, 2],
       egyptian: [0, 2, 3, 2, 3],
       romainian: [0, 2, 1, 3, 1, 2, 1],
       hindu: [0, 2, 2, 1, 2, 1, 2],
       insen: [0, 1, 4, 2, 3],
       iwato: [0, 1, 4, 1, 4],
       scottish: [0, 2, 3, 2, 2],
       yo: [0, 3, 2, 2, 3],
       istrian: [0, 1, 2, 2, 2, 1, 2],
       ukranianDorian: [0, 2, 1, 3, 1, 2, 1],
       petrushka: [0, 1, 3, 2, 1, 3],
       ahavaraba: [0, 1, 3, 1, 2, 1, 2],
   };
   // duplicates with aliases
   ScaleTemplates.halfDiminished = ScaleTemplates.minor7b5;
   ScaleTemplates.jewish = ScaleTemplates.spanish8Tone;
   ScaleTemplates.byzantine = ScaleTemplates.doubleHarmonic;
   ScaleTemplates.acoustic = ScaleTemplates.lydianDominant;
   ScaleTemplates.aeolian = ScaleTemplates.minor;
   ScaleTemplates.ionian = ScaleTemplates.major;
   Object.keys(ScaleTemplates).forEach((element) => Object.freeze(ScaleTemplates[element]));

   /**
    * Regex for matching note name, modifier, and octave
    */
   const nameRegex$1 = /([A-G])(?![^(]*\))/g;
   const modifierRegex$1 = /(#|s|b)(?![^(]*\))/g;
   const octaveRegex$1 = /([0-9]+)(?![^(]*\))/g;
   const scaleNameRegex = /(\([a-zA-Z]{2,}\))/g;
   /**
    * attempts to parse a note from a string
    * @param scale - the string to parse
    * @param supressWarning - supress the warning for ineffeciency if true
    * @internal
    */
   const parseScale = (scale, supressWarning = false) => {
       try {
           const result = scaleLookup(scale);
           if (result) {
               return result;
           }
           if (!supressWarning)
               console.warn(`Ineffecient scale string formatting - ${scale}. Get a performanc increase by using a valid format`);
       }
       catch (err) {
           if (!supressWarning)
               console.warn(`Ineffecient scale string formatting - ${scale}. Get a performanc increase by using a valid format`);
       }
       let noteIdenifier = "";
       let noteModifier = 0;
       let noteOctave = "";
       let scaleName = "";
       const nameMatch = scale.match(nameRegex$1)?.join("").split("");
       const modifierMatch = scale.match(modifierRegex$1)?.join("").split("");
       const octaveMatch = scale.match(octaveRegex$1)?.join("").split("");
       const scaleNameMatch = scale.match(scaleNameRegex)?.join("").split("");
       // combine all modifiers
       if (modifierMatch) {
           if (modifierMatch.length > 1) {
               // combine all modifiers into an offeset value to be added to the semitone
               noteModifier = modifierMatch
                   .map((item) => parseModifier(item))
                   .reduce((a, b) => a + b);
           }
           else {
               noteModifier = parseModifier(modifierMatch[0]);
           }
       }
       if (octaveMatch) {
           const [octave] = octaveMatch;
           noteOctave = octave;
       }
       if (scaleNameMatch) {
           const sName = scaleNameMatch.join("");
           // console.log(sName);
           scaleName = sName;
       }
       if (nameMatch) {
           const [noteName] = nameMatch;
           noteIdenifier = noteName;
           let modifier = 0;
           if (noteModifier)
               modifier = noteModifier;
           const wrappedTone = wrap(getWholeToneFromName(noteIdenifier) + modifier, TONES_MIN, TONES_MAX);
           const semitone = wrappedTone.value;
           let octave = 4;
           if (noteOctave)
               octave = clamp(parseInt(noteOctave, 10), OCTAVE_MIN, OCTAVE_MAX);
           let templateIndex = 1; // default major scale
           if (scaleName) {
               templateIndex = Object.keys(ScaleTemplates).findIndex((template) => template
                   .toLowerCase()
                   .includes(scaleName.toLowerCase().replace(/\(|\)/g, "")));
           }
           // console.log(Object.keys(ScaleTemplates)[templateIndex]);
           if (templateIndex === -1) {
               console.log("UNKNOWN TEMPLATE", scaleName);
               throw new Error(`Unable to find template for scale ${scaleName}`);
           }
           const template = ScaleTemplates[Object.keys(ScaleTemplates)[templateIndex]];
           return {
               key: semitone,
               octave: octave,
               template: template,
           };
       }
       throw new Error(`Invalid Scale: ${scale}`);
   };
   /**
    * creates a lookup table for all notes formatted as [A-G][#|b|s][0-9]
    * @internal
    */
   const createTable$2 = () => {
       const scaleTable = {};
       const noteLetters = ["A", "B", "C", "D", "E", "F", "G"];
       const noteModifiers = ["b", "#", "s"];
       const templates = Object.keys(ScaleTemplates);
       for (const template of templates) {
           for (const noteLabel of noteLetters) {
               //ex A(minor)
               scaleTable[`${noteLabel}(${template})`] = parseScale(noteLabel, true); // 'C' for example
               for (const mod of noteModifiers) {
                   const key = `${noteLabel}${mod}(${template})`;
                   // ex A#(minor)
                   scaleTable[key] = parseScale(key, true); // 'C#' for example
               }
               for (let iOctave = OCTAVE_MIN; iOctave < OCTAVE_MAX; ++iOctave) {
                   const key = `${noteLabel}${iOctave}(${template})`;
                   // ex A4(minor)
                   scaleTable[key] = parseScale(key, true); // 'C4' for example
                   for (const mod of noteModifiers) {
                       const key = `${noteLabel}${mod}${iOctave}(${template})`;
                       // ex A#4(minor)
                       scaleTable[key] = parseScale(key, true); // 'C#4' for example
                   }
               }
           }
       }
       return scaleTable;
   };
   /**
    * creates the lookup table as soon as the module is loaded
    * @internal
    */
   let _scaleLookup = {};
   const scaleLookup = (key) => {
       // buildScaleTable();
       return _scaleLookup[key];
   };
   // if (table && Object.keys(table).length > 0) {
   //    _scaleLookup = table as { [key: string]: ScaleInitializer };
   // } else {
   //    _scaleLookup = createTable();
   // }
   const buildScaleTable = () => {
       // if (Object.entries(_scaleLookup).length > 0) return _scaleLookup;
       _scaleLookup = createTable$2();
       // Object.freeze(_scaleLookup);
       console.log("Scale Table Built");
       return _scaleLookup;
   };

   /**
    * shifts an array by a given distance
    * @param arr the array to shift
    * @param distance the distance to shift
    * @returns the shifted array
    * @internal
    */
   const shift = (arr, dist = 1) => {
       arr = [...arr]; // copy
       if (dist > arr.length || dist < 0 - arr.length)
           throw new Error("shift: distance is greater than array length");
       if (dist > 0) {
           const temp = arr.splice(arr.length - dist, Infinity);
           arr.unshift(...temp);
       }
       if (dist < 0) {
           const temp = arr.splice(0, dist);
           arr.push(...temp);
       }
       return arr;
   };

   /**
    *  Simple util to lazy clone an object
    * @internal
    */
   const clone = (obj) => {
       return JSON.parse(JSON.stringify(obj));
   };

   /**
    * simple util to lazy check equality of objects and arrays
    * @internal
    */
   const isEqual = (a, b) => {
       const stringA = JSON.stringify(a);
       const stringB = JSON.stringify(b);
       return stringA === stringB;
   };

   // import table from "./noteStringLookup.json";
   /**
    * Will lookup a scale name based on the template.
    * @param template - the template to lookup
    * @param supressWarning - supress the warning for ineffeciency if true
    * @returns the scale name
    * @internal
    */
   const scaleNameLookup = (template, supressWarning = false) => {
       try {
           const result = nameTable(JSON.stringify(template));
           if (result)
               return result;
       }
       catch (e) {
           if (!supressWarning)
               console.warn(e);
       }
       const keys = Object.keys(ScaleTemplates);
       const values = Object.values(ScaleTemplates);
       const scaleNames = [];
       for (let i = 0; i < keys.length; ++i) {
           if (isEqual(values[i], template)) {
               scaleNames.push(keys[i].charAt(0).toUpperCase() + keys[i].slice(1));
           }
       }
       const scaleNamesString = scaleNames.join(" AKA ");
       return scaleNamesString;
   };
   const createTable$1 = () => {
       const table = {};
       for (const template of Object.values(ScaleTemplates)) {
           table[JSON.stringify(template)] = scaleNameLookup(template, true);
       }
       return table;
   };
   let _nameTable = {};
   const nameTable = (key) => {
       // buildScaleNameTable();
       return _nameTable[key];
   };
   // if (table && Object.keys(table).length > 0) {
   //    _nameTable = table;
   // } else {
   //    _nameTable = createTable();
   // }
   const buildScaleNameTable = () => {
       // if (Object.entries(_nameTable).length > 0) return _nameTable;
       _nameTable = createTable$1();
       Object.freeze(_nameTable);
       console.log("Scale name table built");
       return _nameTable;
   };

   /**
    * Scales consist of a key(tonic or root) and a template(array of integers) that
    * <br> represents the interval of steps between each note.
    * <br><br>Scale intervals are represented by an integer
    * <br>that is the number of semitones between each note.
    * <br>0 = key - will always represent the tonic
    * <br>1 = half step
    * <br>2 = whole step
    * <br>3 = one and one half steps
    * <br>4 = double step
    * <br>[0, 2, 2, 1, 2, 2, 2] represents the major scale
    * <br><br> Scale templates may have arbitray lengths
    *
    * The following Pre-defined templates are available:
    * <table>
    * <tr>
    * <td>major</td>
    * <td>minor</td>
    * <td>ionian</td>
    * <td>dorian</td>
    * </tr><tr>
    * <td>phrygian</td>
    * <td>lydian</td>
    * <td>mixolydian</td>
    * <td>aeolian</td>
    * </tr><tr>
    * <td>locrian</td>
    * <td>enigmaticMajor</td>
    * <td>enigmaticMinor</td>
    * <td>minor7b5</td>
    * </tr><tr>
    * <td>major7s4s5</td>
    * <td>harmonicMajor</td>
    * <td>harmonicMinor</td>
    * <td>doubleHarmonic</td>
    * </tr><tr>
    * <td>melodicMinorAscending</td>
    * <td>melodicMinorDescending</td>
    * <td>majorPentatonic</td>
    * <td>majorPentatonicBlues</td>
    * </tr><tr>
    * <td>minorPentatonic</td>
    * <td>minorPentatonicBlues</td>
    * <td>b5Pentatonic</td>
    * <td>minor6Pentatonic</td>
    * </tr><tr>
    * <td>dim8Tone</td>
    * <td>dom8Tone</td>
    * <td>neopolitanMajor</td>
    * <td>neopolitanMinor</td>
    * </tr><tr>
    * <td>hungarianMajor</td>
    * <td>hungarianMinor</td>
    * <td>hungarianGypsy</td>
    * <td>spanish</td>
    * </tr><tr>
    * <td>spanish8Tone</td>
    * <td>spanishGypsy</td>
    * <td>augmented</td>
    * <td>dominantSuspended</td>
    * </tr><tr>
    * <td>bebopMajor</td>
    * <td>bebopDominant</td>
    * <td>mystic</td>
    * <td>overtone</td>
    * </tr><tr>
    * <td>leadingTone</td>
    * <td>hirojoshi</td>
    * <td>japaneseA</td>
    * <td>japaneseB</td>
    * </tr><tr>
    * <td>oriental</td>
    * <td>arabian</td>
    * <td>persian</td>
    * <td>balinese</td>
    * </tr><tr>
    * <td>kumoi</td>
    * <td>pelog</td>
    * <td>algerian</td>
    * <td>chinese</td>
    * </tr><tr>
    * <td>mongolian</td>
    * <td>egyptian</td>
    * <td>hindu</td>
    * <td>romanian</td>
    * </tr><tr>
    * <td>hindu</td>
    * <td>insen</td>
    * <td>iwato</td>
    * <td>scottish</td>
    * </tr><tr>
    * <td>yo</td>
    * <td>istrian</td>
    * <td>ukranianDorian</td>
    * <td>petrushka</td>
    * </tr><tr>
    * <td>ahavaraba</td>
    * <td>halfDiminished</td>
    * <td>jewish</td>
    * <td>byzantine</td>
    * </tr><tr>
    * <td>acoustic</td>
    * </table>
    *
    * @example
    * ```javascript
    * import {Scale} from 'musictheoryjs';
    * import {ScaleTemplates} from 'musictheoryjs';
    * import {ScaleInitializer} from 'musictheoryjs'; // TypeScript only if needed
    * ```
    */
   class Scale {
       /**
        * @example
        * ```javascript
        * import {Scale, ScaleTemplates} from 'musictheoryjs';
        *
        * // creates a scale with the default template, key 0f 0(C) and an octave of 4
        * const scale = new Scale();
        *
        * // creates a scale with the template [0, 2, 2, 1, 2, 2, 2] and key 4(E) and octave 5
        * const scale2 = new Scale({key: 4, octave: 5, template: ScaleTemplates.major});
        *
        *
        * // String parsing should follow the format: note-name[alteration][octave][(scale-name)]
        * // creates a scale with the minor template, key Gb and an octave of 7
        * const scale3 = new Scale('Gb7(minor)');
        * ```
        */
       constructor(values) {
           if (!values) {
               this.template = DEFAULT_SCALE_TEMPLATE;
               this.key = DEFAULT_SEMITONE;
               this.octave = DEFAULT_OCTAVE;
           }
           else if (typeof values === "string") {
               values = parseScale(values);
               this.template = [...(values?.template ?? DEFAULT_SCALE_TEMPLATE)];
               this.key = values.key || DEFAULT_SEMITONE;
               this.octave = values.octave || DEFAULT_OCTAVE;
           }
           else {
               // important that octave is set first so that
               // setting the semitone can change the octave
               this.template = [...(values?.template ?? DEFAULT_SCALE_TEMPLATE)];
               this.key = values.key || DEFAULT_SEMITONE;
               this.octave = values.octave || DEFAULT_OCTAVE;
           }
           this._notesDirty = true;
       }
       /**
        *  unique id for this scale(auto generated)
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.id); // dhlkj5j322
        * ```
        */
       id = uid();
       /**
        * Returns true if this scale is equal to the given scale
        * @param scale - the scale to compare to
        * @returns true if the scales are equal
        * @example
        * ```javascript
        * const scale = new Scale();
        * const scale2 = new Scale();
        * console.log(scale.equals(scale2)); // true
        * ```
        */
       equals(scale) {
           return (this._key === scale._key &&
               this._octave === scale._octave &&
               isEqual(this._template, scale._template));
       }
       /**
        * Returns a copy of this Scale
        * @chainable
        * @returns a copy of this Scale
        * @example
        * ```javascript
        * const scale = new Scale();
        * const scale2 = scale.copy();
        * console.log(scale.equals(scale2)); // true
        * ```
        */
       copy() {
           const scale = new Scale({
               key: this.key,
               octave: this.octave,
               template: clone(this.template),
           });
           if (this._shiftedInterval !== 0)
               scale.shift(this._shiftedInterval);
           return scale;
       }
       /**
        * key
        */
       _key = 0;
       /**
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.key); // 0(semitone)
        * ```
        */
       get key() {
           return this._key;
       }
       /**
        * Setting the semitone to a value outside of the range [0, 11](semitone) will<br/>
        * wrap the semitone to the range [0, 11] and change the octave depending<br/>
        * on how many times the semitone has been wrapped.
        * @example
        * ```javascript
        * const scale = new Scale();
        * scale.key = 4;
        * console.log(scale.key); // 4
        * ```
        */
       set key(value) {
           const wrapped = wrap(value, TONES_MIN, TONES_MAX);
           this.octave = this.octave + wrapped.numWraps;
           this._key = wrapped.value;
           this._notesDirty = true;
       }
       /**
        * octave
        */
       _octave = DEFAULT_OCTAVE;
       /**
        * The octave is clamped to the range [0, 9].
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.octave); // 4
        * ```
        */
       get octave() {
           return this._octave;
       }
       /**
        * @example
        * ```javascript
        * const scale = new Scale();
        * scale.octave = 5;
        * console.log(scale.octave); // 5
        * ```
        */
       set octave(value) {
           this._octave = clamp(value, OCTAVE_MIN, OCTAVE_MAX);
           this._notesDirty = true;
       }
       /**
        * template
        */
       _template = [];
       /**
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.template); // [0, 2, 2, 1, 2, 2, 2]
        * ```
        */
       get template() {
           return clone(this._template);
       }
       /**
        * The following Pre-defined templates are available:
        * <table>
        * <tr>
        * <td>major</td>
        * <td>minor</td>
        * <td>ionian</td>
        * <td>dorian</td>
        * </tr><tr>
        * <td>phrygian</td>
        * <td>lydian</td>
        * <td>mixolydian</td>
        * <td>aeolian</td>
        * </tr><tr>
        * <td>locrian</td>
        * <td>enigmaticMajor</td>
        * <td>enigmaticMinor</td>
        * <td>minor7b5</td>
        * </tr><tr>
        * <td>major7s4s5</td>
        * <td>harmonicMajor</td>
        * <td>harmonicMinor</td>
        * <td>doubleHarmonic</td>
        * </tr><tr>
        * <td>melodicMinorAscending</td>
        * <td>melodicMinorDescending</td>
        * <td>majorPentatonic</td>
        * <td>majorPentatonicBlues</td>
        * </tr><tr>
        * <td>minorPentatonic</td>
        * <td>minorPentatonicBlues</td>
        * <td>b5Pentatonic</td>
        * <td>minor6Pentatonic</td>
        * </tr><tr>
        * <td>dim8Tone</td>
        * <td>dom8Tone</td>
        * <td>neopolitanMajor</td>
        * <td>neopolitanMinor</td>
        * </tr><tr>
        * <td>hungarianMajor</td>
        * <td>hungarianMinor</td>
        * <td>hungarianGypsy</td>
        * <td>spanish</td>
        * </tr><tr>
        * <td>spanish8Tone</td>
        * <td>spanishGypsy</td>
        * <td>augmented</td>
        * <td>dominantSuspended</td>
        * </tr><tr>
        * <td>bebopMajor</td>
        * <td>bebopDominant</td>
        * <td>mystic</td>
        * <td>overtone</td>
        * </tr><tr>
        * <td>leadingTone</td>
        * <td>hirojoshi</td>
        * <td>japaneseA</td>
        * <td>japaneseB</td>
        * </tr><tr>
        * <td>oriental</td>
        * <td>arabian</td>
        * <td>persian</td>
        * <td>balinese</td>
        * </tr><tr>
        * <td>kumoi</td>
        * <td>pelog</td>
        * <td>algerian</td>
        * <td>chinese</td>
        * </tr><tr>
        * <td>mongolian</td>
        * <td>egyptian</td>
        * <td>hindu</td>
        * <td>romanian</td>
        * </tr><tr>
        * <td>hindu</td>
        * <td>insen</td>
        * <td>iwato</td>
        * <td>scottish</td>
        * </tr><tr>
        * <td>yo</td>
        * <td>istrian</td>
        * <td>ukranianDorian</td>
        * <td>petrushka</td>
        * </tr><tr>
        * <td>ahavaraba</td>
        * <td>halfDiminished</td>
        * <td>jewish</td>
        * <td>byzantine</td>
        * </tr><tr>
        * <td>acoustic</td>
        * </table>
        * @example
        * ```javascript
        * const scale = new Scale();
        * scale.template = [0, 2, 2, 1, 2, 2, 2];
        * console.log(scale.template); // [0, 2, 2, 1, 2, 2, 2]
        * ```
        */
       set template(value) {
           this._template = clone(value);
           this._shiftedInterval = 0;
           this._notesDirty = true;
       }
       /**
        * notes
        * notes are generated and cached as needed
        */
       _notes = [];
       _notesDirty = true;
       /**
        * will generate the notes if needed or return the cached notes
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.notes); // List of notes
        * ```
        */
       get notes() {
           if (this._notesDirty) {
               this.generateNotes();
               this._notesDirty = false;
           }
           return this._notes;
       }
       /**
        * generate notes(internal)
        * generates the notes for this scale
        */
       generateNotes() {
           // use the template unshifted for simplicity
           const unshiftedTemplate = shift(this._template, -this._shiftedInterval);
           // if allowing this to change the octave is undesirable
           // then may need to pre wrap the tone and use
           // the final value
           const notes = [];
           let accumulator = this.key;
           for (const interval of unshiftedTemplate) {
               const tone = interval === 0
                   ? (accumulator = this.key)
                   : (accumulator += interval);
               const note = new Note({
                   semitone: tone,
                   octave: this.octave,
               });
               notes.push(note);
           }
           // shift notes back to original position
           if (this._shiftedInterval > 0) {
               const temp = notes.splice(notes.length - (this._shiftedInterval + 1), Infinity);
               notes.unshift(...temp);
           }
           if (this._shiftedInterval < 0) {
               const temp = notes.splice(0, this._shiftedInterval);
               notes.push(...temp);
           }
           this._notes = notes;
       }
       /**
        * returns the names of the notes in the scale
        * @param preferSharpKeys - if true then sharps will be preferred over flats when semitones could be either - ex: Bb/A#
        * @returns the names of the notes in the scale
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.names); // ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4']
        * ```
        */
       getNoteNames(preferSharpKey = true) {
           const names = scaleNoteNameLookup(this, preferSharpKey);
           return names;
       }
       /**
        * degree
        * returns a note that represents the given degree
        * @param degree - the degree to return
        * @returns a note that represents the given degree
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.degree(0)); // C4(Note)
        * console.log(scale.degree(1)); // D4(Note) etc
        * ```
        */
       degree(degree) {
           const wrapped = wrap(degree - 1 /*zero index */, 0, this.notes.length - 1);
           const note = this.notes[wrapped.value].copy();
           note.octave = this.octave + wrapped.numWraps;
           return note;
       }
       /**
        * relative major
        * returns a new scale that is the relative major of this scale - takes the 3rd degree as it's key
        * @chainable
        * @returns a new scale that is the relative major of this scale
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.relativeMajor()); // Scale
        * ```
        */
       relativeMajor() {
           const major = new Scale({
               template: ScaleTemplates.major,
               key: this.degree(3).semitone,
               octave: this.octave,
           });
           return major;
       }
       /**
        * relative minor
        * returns a new scale that is the relative minor of this scale - takes the 6th degree as it's key
        * @chainable
        * @returns a new scale that is the relative minor of this scale
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.relativeMinor()); // Scale
        * ```
        */
       relativeMinor() {
           const minor = new Scale({
               template: ScaleTemplates.minor,
               key: this.degree(6).semitone,
               octave: this.octave,
           });
           return minor;
       }
       /**
        * shift
        */
       _shiftedInterval = 0;
       _originalTemplate = [];
       /**
        * shift
        * shifts the scale by the given number of degrees
        * @chainable
        * @param shift - the number of degrees to shift the scale
        * @returns a new scale that is the shifted scale
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.shift(1)); // Scale
        * ```
        */
       shift(degrees = 1) {
           if (this._shiftedInterval === 0) {
               this._originalTemplate = clone(this._template);
           }
           this._template = shift(this._template, degrees);
           this._shiftedInterval += degrees;
           this._notesDirty = true;
           return this;
       }
       /**
        * shifted
        * returns a copy of this scale shifted by the given number of degrees
        * @chainable
        * @param degrees - the number of degrees to shift the scale
        * @returns a copy of this scale shifted by the given number of degrees
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.shifted(1)); // Scale(copy)
        * ```
        */
       shifted(degrees = 1) {
           const scale = this.copy();
           scale.shift(degrees);
           return scale;
       }
       /**
        * unshift
        * shifts the original root back to the root position
        * @chainable
        * @returns this scale after unshifting it back to the original root position
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.shift(1));
        * console.log(scale.unshift());
        * ```
        */
       unshift() {
           if (this._shiftedInterval !== 0) {
               if (this._originalTemplate.length > 0) {
                   this._template = this._originalTemplate;
               }
               // this.shift(this._shiftedInterval * -1);
               this._shiftedInterval = 0;
               this._originalTemplate = [];
               this._notesDirty = true;
           }
           return this;
       }
       /**
        * unshifted
        * returns a copy of this scale with the tonic shifted back
        * to the root position
        * @chainable
        * @returns a copy of this scale with the tonic shifted back
        * to the root position
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.shift(1));
        * console.log(scale.unshifted()); // Scale(copy)
        * ```
        */
       unshifted() {
           const scale = this.copy();
           if (this._originalTemplate.length)
               scale.template = this._originalTemplate;
           scale.unshift();
           return scale;
       }
       /**
        * returns the amount that the scale has shifted
        * (0 if not shifted)
        * @returns the amount that the scale has shifted
        * (0 if not shifted)
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.shift(1));
        * console.log(scale.shifted()); // 1
        * ```
        */
       shiftedInterval() {
           return this._shiftedInterval;
       }
       /**
        * Scale modes
        */
       /**
        * @chainable
        * @returns a copy of this scale in the Ionian(major) mode
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.ionian()); // Scale(copy)
        * ```
        */
       ionian() {
           const scale = this.copy();
           scale.template = ScaleTemplates.ionian;
           return scale;
       }
       /**
        * @chainable
        * @returns a copy of this scale in the Dorian mode
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.dorian()); // Scale(copy)
        * ```
        */
       dorian() {
           const scale = this.copy();
           scale.template = ScaleTemplates.dorian;
           return scale;
       }
       /**
        * @chainable
        * @returns a copy of this scale in the Phrygian mode
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.phrygian()); // Scale(copy)
        * ```
        */
       phrygian() {
           const scale = this.copy();
           scale.template = ScaleTemplates.phrygian;
           return scale;
       }
       /**
        * @chainable
        * @returns a copy of this scale in the Lydian mode
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.lydian()); // Scale(copy)
        * ```
        */
       lydian() {
           const scale = this.copy();
           scale.template = ScaleTemplates.lydian;
           return scale;
       }
       /**
        * @chainable
        * @returns a copy of this scale in the Mixolydian mode
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.mixolydian()); // Scale(copy)
        * ```
        */
       mixolydian() {
           const scale = this.copy();
           scale.template = ScaleTemplates.mixolydian;
           return scale;
       }
       /**
        * @chainable
        * @returns a copy of this scale in the Aeolian(minor) mode
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.aeolian()); // Scale(copy)
        * ```
        */
       aeolian() {
           const scale = this.copy();
           scale.template = ScaleTemplates.aeolian;
           return scale;
       }
       /**
        * @chainable
        * @returns a copy of this scale in the Locrian mode
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.locrian()); // Scale(copy)
        * ```
        */
       locrian() {
           const scale = this.copy();
           scale.template = ScaleTemplates.locrian;
           return scale;
       }
       /**
        * returns string version of the scale
        * @returns string version of the scale
        * @example
        * ```javascript
        * const scale = new Scale();
        * console.log(scale.toString()); // 'C'
        * ```
        */
       toString() {
           let scaleNames = scaleNameLookup(this._template);
           if (!scaleNames)
               scaleNames = this.getNoteNames().join(", ");
           return `${Semitone$1[this._key]}${this._octave}(${scaleNames})`;
       }
   }
   /**
    * attempts to lookup the note name for a scale efficiently
    * @param scale - the scale to lookup
    * @param preferSharpKey - if true, will prefer sharp keys over flat keys
    * @returns the note names for the scale
    * @internal
    */
   const scaleNoteNameLookup = (scale, preferSharpKey = true) => {
       try {
           const key = `${scale.key}-${scale.octave}-${JSON.stringify(scale.template)}`;
           const notes = notesLookup(key);
           if (notes) {
               return notes;
           }
       }
       catch (e) {
           // do nothing
       }
       let notes = [...scale.notes];
       notes = shift(notes, -scale.shiftedInterval()); //unshift back to key = 0 index
       const notesParts = notes.map((note) => note.toString().split("/"));
       const octaves = notes.map((note) => note.octave);
       const removables = ["B#", "Bs", "Cb", "E#", "Es", "Fb"];
       const noteNames = [];
       for (const [i, noteParts] of notesParts.entries()) {
           //remove Cb B# etc
           for (const part of noteParts) {
               // remove any numbers from the note name(octave)
               // part.replace(/\d/g, "");
               if (removables.includes(part)) {
                   const index = noteNames.indexOf(part);
                   noteNames.splice(index, 1);
               }
           }
           if (noteNames.length === 0) {
               noteNames.push(preferSharpKey ? noteParts[0] : noteParts[noteParts.length - 1]);
               continue;
           }
           if (noteParts.length === 1) {
               noteNames.push(noteParts[0]);
               continue;
           }
           const wholeNotes = [
               "A",
               "B",
               "C",
               "D",
               "E",
               "F",
               "G",
               "A",
               "B",
               "C",
               "D",
               "E",
               "F",
               "G",
           ];
           const lastWholeNote = noteNames[noteNames.length - 1][0];
           const lastIndex = wholeNotes.indexOf(lastWholeNote);
           const nextNote = wholeNotes[lastIndex + 1];
           if (noteParts[0].includes(nextNote)) {
               const hasOctave = noteParts[0].match(/\d/g);
               noteNames.push(noteParts[0] + (hasOctave ? "" : octaves[i]));
               continue;
           }
           const hasOctave = noteParts[noteParts.length - 1].match(/\d/g);
           noteNames.push(noteParts[noteParts.length - 1] + (hasOctave ? "" : octaves[i]));
       }
       const shiftedNoteNames = shift(noteNames, scale.shiftedInterval());
       return shiftedNoteNames;
   };
   /**
    * creates a lookup table for all notes formatted as [A-G][#|b|s][0-9]
    */
   const createNotesLookupTable = () => {
       const scaleTable = {};
       for (let itone = TONES_MIN; itone < TONES_MIN + OCTAVE_MAX; itone++) {
           for (let ioctave = OCTAVE_MIN; ioctave <= OCTAVE_MAX; ioctave++) {
               for (const template of Object.values(ScaleTemplates)) {
                   const scale = new Scale({
                       key: itone,
                       template: template,
                       octave: ioctave,
                   });
                   scaleTable[`${itone}-${ioctave}-${JSON.stringify(template)}`] =
                       scaleNoteNameLookup(scale);
               }
           }
       }
       return scaleTable;
   };
   /**
    * creates the lookup table as soon as the module is loaded
    */
   let _notesLookup = {};
   const notesLookup = (key) => {
       // buildScaleNoteTable();
       return _notesLookup[key];
   };
   const buildScaleNoteTable = () => {
       // if (Object.entries(_notesLookup).length > 0) return _notesLookup;
       _notesLookup = createNotesLookupTable();
       Object.freeze(_notesLookup);
       console.log("built scale note table");
       return _notesLookup;
   };

   /**
    * Shortcut for modifiers
    * @internal
    */
   const flat = -1;
   const flat_flat = -2;
   const sharp = 1;
   /**
    * Chord templates
    * @internal
    */
   const ChordTemplates = {
       maj: [1, 3, 5],
       maj4: [1, 3, 4, 5],
       maj6: [1, 3, 5, 6],
       maj69: [1, 3, 5, 6, 9],
       maj7: [1, 3, 5, 7],
       maj9: [1, 3, 5, 7, 9],
       maj11: [1, 3, 5, 7, 9, 11],
       maj13: [1, 3, 5, 7, 9, 11, 13],
       maj7s11: [1, 3, 5, 7, [11, sharp]],
       majb5: [1, 3, [5, flat]],
       min: [1, [3, flat], 5],
       min4: [1, [3, flat], 4, 5],
       min6: [1, [3, flat], 5, 6],
       min7: [1, [3, flat], 5, [7, flat]],
       minAdd9: [1, [3, flat], 5, 9],
       min69: [1, [3, flat], 5, 6, 9],
       min9: [1, [3, flat], 5, [7, flat], 9],
       min11: [1, [3, flat], 5, [7, flat], 9, 11],
       min13: [1, [3, flat], 5, [7, flat], 9, 11, 13],
       min7b5: [1, [3, flat], [5, flat], [7, flat]],
       dom7: [1, 3, 5, [7, flat]],
       dom9: [1, 3, 5, [7, flat], 9],
       dom11: [1, 3, 5, [7, flat], 9, 11],
       dom13: [1, 3, 5, [7, flat], 9, 11, 13],
       dom7s5: [1, 3, [5, sharp], [7, flat]],
       dom7b5: [1, 3, [5, flat], [7, flat]],
       dom7b9: [1, 3, 5, [7, flat], [9, flat]],
       dom7s9: [1, 3, 5, [7, flat], [9, sharp]],
       dom9s5: [1, 3, [5, sharp], [7, flat], 9],
       dom9b5: [1, 3, [5, flat], [7, flat], 9],
       dom7s5s9: [1, 3, [5, sharp], [7, flat], [9, sharp]],
       dom7s5b9: [1, 3, [5, sharp], [7, flat], [9, flat]],
       dom7s11: [1, 3, 5, [7, flat], [11, sharp]],
       dim: [1, [3, flat], [5, flat]],
       dim7: [1, [3, flat], [5, flat], [7, flat_flat]],
       aug: [1, 3, [5, sharp]],
       sus2: [1, 2, 5],
       sus4: [1, [4, flat], 5],
       fifth: [1, 5],
       b5: [1, [5, flat]],
       s11: [1, 5, [11, sharp]],
   };
   Object.keys(ChordTemplates).forEach((element) => Object.freeze(ChordTemplates[element]));

   const DEFAULT_CHORD_TEMPLATE = [1, 3, 5];
   const DEFAULT_SCALE = new Scale();

   // import table from "./noteLookup.json";
   /**
    * Regex for matching note name, modifier, and octave
    */
   const nameRegex = /([A-G])(?=[^(]*\))/g;
   const modifierRegex = /(#|s|b)(?=[^(]*\))/g;
   const octaveRegex = /([0-9]+)(?=[^(]*\))/g;
   const chordNameRegex = /(min|maj|dim|aug)(?![^(]*\))/g;
   const additionsRegex = /([#|s|b]?[0-9]+)(?![^(]*\))/g;
   /**
    * @param chord the string to parse
    * @returns a valid ChordInitializer
    * @internal
    */
   const parseChord = (chord) => {
       try {
           const result = chordLookup(chord);
           if (result) {
               return result;
           }
       }
       catch {
           // do nothing
       }
       let noteIdenifier = "";
       let noteModifier = 0;
       let noteOctave = "";
       let chordName = "maj";
       let additions = [];
       const nameMatch = chord.match(nameRegex)?.join("").split("");
       const modifierMatch = chord.match(modifierRegex)?.join("").split("");
       const octaveMatch = chord.match(octaveRegex)?.join("").split("");
       const chordNameMatch = chord.match(chordNameRegex)?.join("");
       const additionsMatch = chord.match(additionsRegex)?.join("").split("");
       // combine all modifiers
       if (modifierMatch) {
           if (modifierMatch.length > 1) {
               // combine all modifiers into an offeset value to be added to the semitone
               noteModifier = modifierMatch
                   .map((item) => parseModifier(item))
                   .reduce((a, b) => a + b);
           }
           else {
               noteModifier = parseModifier(modifierMatch[0]);
           }
       }
       if (octaveMatch) {
           const [octave] = octaveMatch;
           noteOctave = octave;
       }
       if (chordNameMatch) {
           // const [name] = chordNameMatch;
           chordName = chordNameMatch;
       }
       if (additionsMatch) {
           additions = additionsMatch;
       }
       const intervals = [];
       if (nameMatch) {
           const [noteName] = nameMatch;
           noteIdenifier = noteName;
           let modifier = 0;
           if (noteModifier)
               modifier = noteModifier;
           const wrappedTone = wrap(getWholeToneFromName(noteIdenifier) + modifier, TONES_MIN, TONES_MAX);
           const semitone = wrappedTone.value;
           let octave = 4;
           if (noteOctave)
               octave = clamp(parseInt(noteOctave, 10), OCTAVE_MIN, OCTAVE_MAX);
           intervals.push(...ChordTemplates[chordName]);
           for (const addition of additions) {
               let mod = 0;
               if (addition[0] === "#" || addition[0] === "s") {
                   mod = 1;
                   additions.shift();
               }
               else if (addition[0] === "b") {
                   mod = -1;
                   additions.shift();
               }
               const additionNum = parseInt(addition, 10);
               if (intervals.includes(additionNum)) {
                   const index = intervals.indexOf(additionNum);
                   intervals[index] = [additionNum, mod];
               }
               else {
                   intervals.push([additionNum, mod]);
               }
           }
           return {
               root: semitone,
               octave: octave,
               template: intervals,
           };
       }
       throw new Error("Invalid chord name");
   };
   /**
    * @returns a lookup table of chord names and their initializers
    * @internal
    */
   const createTable = () => {
       const table = {};
       const noteLetters = ["A", "B", "C", "D", "E", "F", "G"];
       const noteModifiers = ["b", "#", "s"];
       const qualities = ["maj", "min", "dim", "aug", "sus"];
       const additions = [
           "",
           "2",
           "3",
           "4",
           "5",
           "6",
           "7",
           "9",
           "11",
           "13",
           "b2",
           "b3",
           "b4",
           "b5",
           "b6",
           "b7",
           "b9",
           "b11",
           "b13",
           "s2",
           "s3",
           "s4",
           "s5",
           "s6",
           "s7",
           "s9",
           "s11",
           "s13",
           "#2",
           "#3",
           "#4",
           "#5",
           "#6",
           "#7",
           "#9",
           "#11",
           "#13",
           "7s11",
           "7#11",
           "7b9",
           "7#9",
           "7b5",
           "7#5",
           "7b9b5",
           "7#9#5",
           "7b13",
           "7#13",
           "9#5",
           "9b5",
           "9#11",
           "9b11",
           "9#13",
           "9b13",
           "11#5",
           "11b5",
           "11#9",
           "11b9",
           "11#13",
           "11b13",
       ];
       for (const quality of qualities) {
           for (const addition of additions) {
               for (const noteLetter of noteLetters) {
                   const key = `(${noteLetter})${quality}${addition}`;
                   table[key] = parseChord(key);
                   for (const noteModifier of noteModifiers) {
                       const key = `(${noteLetter}${noteModifier})${quality}${addition}`;
                       table[key] = parseChord(key);
                       for (let i = OCTAVE_MIN; i <= OCTAVE_MAX; i++) {
                           const key = `(${noteLetter}${noteModifier}${i})${quality}${addition}`;
                           table[key] = parseChord(key);
                       }
                   }
               }
           }
       }
       return table;
   };
   let _chordLookup = {};
   /**
    * @param key the string to lookup
    * @returns a valid chord initializer
    * @throws an error if the key is not a valid chord
    * @internal
    */
   const chordLookup = (key) => {
       // buildChordTable();
       return _chordLookup[key];
   };
   // registerInitializer(() => {
   //    _chordLookup = createTable();
   // });
   // if (table && Object.keys(table).length > 0) {
   //    _chordLookup = table as { [key: string]: ChordInitializer };
   // } else {
   //    _chordLookup = createTable();
   // }
   const buildChordTable = () => {
       // if (Object.entries(_chordLookup).length > 0) return _chordLookup;
       _chordLookup = createTable();
       Object.freeze(_chordLookup);
       console.log("built chord table");
       // console.log(Object.entries(_chordLookup).length);
       return _chordLookup;
   };

   /**
    * Chords consist of a root note, octave, chord template, and a base scale.<br><br>
    * The chord template is an array of integers, each integer representing<br>
    *  a scale degree from the base scale(defaults to major).<br>
    * The default template is the I,III,V denoted as [1,3,5]<br>
    * ChordIntervals used in templates can also contain a modifier,<br>
    * for a particular scale degree, such as [1,3,[5, -1]]<br>
    * where -1 is flat, 0 is natural, and 1 is sharp.<br>
    * It could also be written as [1,3,[5, modifier.flat]]<br>
    * if you import modifier.
    *
    * The following predefined templates are available:<br>
    * <table>
    * <tr>
    * <td>maj</td>
    * <td>maj4</td>
    * <td>maj6</td>
    * <td>maj69</td>
    * </tr><tr>
    * <td>maj7</td>
    * <td>maj9</td>
    * <td>maj11</td>
    * <td>maj13</td>
    * </tr><tr>
    * <td>maj7s11</td>
    * <td>majb5</td>
    * <td>min</td>
    * <td>min4</td>
    * </tr><tr>
    * <td>min6</td>
    * <td>min7</td>
    * <td>minAdd9</td>
    * <td>min69</td>
    * </tr><tr>
    * <td>min9</td>
    * <td>min11</td>
    * <td>min13</td>
    * <td>min7b5</td>
    * </tr><tr>
    * <td>dom7</td>
    * <td>dom9</td>
    * <td>dom11</td>
    * <td>dom13</td>
    * </tr><tr>
    * <td>dom7s5</td>
    * <td>dom7b5</td>
    * <td>dom7s9</td>
    * <td>dom7b9</td>
    * </tr><tr>
    * <td>dom9b5</td>
    * <td>dom9s5</td>
    * <td>dom7s11</td>
    * <td>dom7s5s9</td>
    * </tr><tr>
    * <td>dom7s5b9</td>
    * <td>dim</td>
    * <td>dim7</td>
    * <td>aug</td>
    * </tr><tr>
    * <td>sus2</td>
    * <td>sus4</td>
    * <td>fifth</td>
    * <td>b5</td>
    * </tr><tr>
    * <td>s11</td>
    * </tr>
    * </table>
    *
    * @example
    * ```javascript
    * import { Chord } from "musictheoryjs";
    * import {ChordTemplate} from "musictheoryjs";
    * import {ChordInterval} from "musictheoryjs";
    * import {Modifier} from "musictheoryjs";
    * import {ChordInitializer} from "musictheoryjs";// Typescript only if needed
    * ```
    */
   class Chord {
       /**
        * @example
        * ```javascript
        * import { Chord, ChordTemplates, Modifier } from "musictheoryjs";
        *
        * //creates a chord with the default(1,3,5) template, root of C, in the 4th octave
        * const chord = new Chord();
        *
        * // creates a chord with the pre-defined diminished template, root of Eb, in the 5th octave
        * const chord = new Chord({root: 3, octave: 5, template: ChordTemplates.dim});
        *
        * // String parsing should follow the format: (root-note-name[s,#,b][octave])[chord-template-name|[chord-quality][modifiers]]
        * // creates a chord from a string
        * const chord = new Chord('(D4)min4');
        * ```
        */
       constructor(values) {
           if (!values) {
               this._template = [...DEFAULT_CHORD_TEMPLATE];
               this.octave = DEFAULT_OCTAVE;
               this.root = DEFAULT_SEMITONE;
           }
           else if (typeof values === "string") {
               const parsed = parseChord(values);
               this._template = [...(parsed?.template ?? DEFAULT_CHORD_TEMPLATE)];
               this.octave = parsed?.octave ?? DEFAULT_OCTAVE;
               this.root = parsed?.root ?? DEFAULT_SEMITONE;
           }
           else {
               this._template = [...(values.template ?? DEFAULT_CHORD_TEMPLATE)];
               this.octave = values.octave ?? DEFAULT_OCTAVE;
               this.root = values.root ?? DEFAULT_SEMITONE;
           }
           this._baseScale = new Scale({ key: this._root, octave: this._octave });
           this._notesDirty = true;
       }
       /**
        * unique id for this instance
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.id); // hal8934hll
        * ```
        */
       id = uid();
       /**
        * root
        */
       _root = DEFAULT_SEMITONE;
       /**
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.root); // 0(semitone)
        * ```
        */
       get root() {
           return this._root;
       }
       /**
        * Setting the root to a value outside of the range [0, 11](semitone) will<br/>
        * wrap the semitone to the range [0, 11] and change the octave depending<br/>
        * on how many times the semitone has been wrapped.
        * @example
        * ```javascript
        * const chord = new Chord();
        * chord.root = 4; // sets the root to 4th semitone(E)
        * console.log(chord.root); // 4(semitone)
        * ```
        */
       set root(value) {
           // this._root = value;
           const wrapped = wrap(value, TONES_MIN, TONES_MAX);
           this._root = wrapped.value;
           this._octave = this._octave + wrapped.numWraps;
           this._notesDirty = true;
       }
       /**
        * base scale
        */
       _baseScale = DEFAULT_SCALE;
       /**
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.baseScale); // prints the default scale(major)
        * ```
        */
       get baseScale() {
           return this._baseScale;
       }
       /**
        * Not a lot of good reasons to change this except for experimentation
        * @example
        * ```javascript
        * const chord = new Chord();
        * chord.baseScale = new Scale({ key: 3, octave: 5, template: [1, [3, Modifier.flat], 5] });
        * console.log(chord.baseScale); // prints the minor scale
        * ```
        */
       set baseScale(value) {
           this._baseScale = value;
           this._baseScale.octave = this._octave;
           this._notesDirty = true;
       }
       /**
        * octave
        */
       _octave = DEFAULT_OCTAVE;
       /**
        * The octave is clamped to the range [0, 9].
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.octave); // 4(octave)
        * ```
        */
       get octave() {
           return this._octave;
       }
       /**
        * @example
        * ```javascript
        * const chord = new Chord();
        * chord.octave = 5; // sets the octave to 5th
        * console.log(chord.octave); // 5(octave)
        * ```
        */
       set octave(value) {
           this._octave = clamp(value, OCTAVE_MIN, OCTAVE_MAX);
           this._baseScale.octave = this._octave;
           this._notesDirty = true;
       }
       /**
        * template
        */
       _template = [];
       /**
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.template); // prints the default template
        * ```
        */
       get template() {
           return [...this._template];
       }
       /**
        * The following predefined templates are available:<br>
        * <table>
        * <tr>
        * <td>maj</td>
        * <td>maj4</td>
        * <td>maj6</td>
        * <td>maj69</td>
        * </tr><tr>
        * <td>maj7</td>
        * <td>maj9</td>
        * <td>maj11</td>
        * <td>maj13</td>
        * </tr><tr>
        * <td>maj7s11</td>
        * <td>majb5</td>
        * <td>min</td>
        * <td>min4</td>
        * </tr><tr>
        * <td>min6</td>
        * <td>min7</td>
        * <td>minAdd9</td>
        * <td>min69</td>
        * </tr><tr>
        * <td>min9</td>
        * <td>min11</td>
        * <td>min13</td>
        * <td>min7b5</td>
        * </tr><tr>
        * <td>dom7</td>
        * <td>dom9</td>
        * <td>dom11</td>
        * <td>dom13</td>
        * </tr><tr>
        * <td>dom7s5</td>
        * <td>dom7b5</td>
        * <td>dom7s9</td>
        * <td>dom7b9</td>
        * </tr><tr>
        * <td>dom9b5</td>
        * <td>dom9s5</td>
        * <td>dom7s11</td>
        * <td>dom7s5s9</td>
        * </tr><tr>
        * <td>dom7s5b9</td>
        * <td>dim</td>
        * <td>dim7</td>
        * <td>aug</td>
        * </tr><tr>
        * <td>sus2</td>
        * <td>sus4</td>
        * <td>fifth</td>
        * <td>b5</td>
        * </tr><tr>
        * <td>s11</td>
        * </tr>
        * </table>
        * @example
        * ```javascript
        * const chord = new Chord();
        * chord.template = [1, [3, Modifier.flat], 5]; // sets the template to a minor chord
        * console.log(chord.template); // prints the new template
        * ```
        */
       set template(value) {
           this._template = [...value];
           this._notesDirty = true;
       }
       /**
        * notes
        * notes are generated and cached as needed
        */
       _notes = [];
       _notesDirty = true;
       /**
        * will generate notes if needed or return the cached notes
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.notes); // prints the default notes
        * ```
        */
       get notes() {
           if (this._notesDirty) {
               this.generateNotes();
               this._notesDirty = false;
           }
           return this._notes;
       }
       /**
        * generate notes(internal)
        * generates the notes for this scale
        */
       generateNotes() {
           this._notes = [];
           for (const interval of this._template) {
               let tone = 0;
               let mod = 0;
               if (Array.isArray(interval)) {
                   tone = interval[0];
                   mod = interval[1];
               }
               else {
                   tone = interval;
               }
               const offset = tone;
               const note = this._baseScale.degree(offset);
               const noteTone = note.semitone;
               note.semitone = noteTone + mod;
               this._notes.push(note);
           }
           return this._notes;
       }
       /**
        * @returns the note names -> ['C4', 'E4', 'G4']
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.getNoteNames()); // ['C4', 'E4', 'G4']
        * ```
        */
       getNoteNames() {
           const noteNames = [];
           for (const note of this.notes) {
               noteNames.push(note.toString());
           }
           return noteNames;
       }
       /**
        * @chainable
        * @returns a copy of the chord
        * @example
        * ```javascript
        * const chord = new Chord();
        * const copy = chord.copy();
        * console.log(chord.equals(copy)); // true
        * ```
        */
       copy() {
           return new Chord({
               root: this.root,
               octave: this.octave,
               template: [...this._template],
           });
       }
       /**
        * @param other the other chord to compare to
        * @returns true if the two chords are equal
        * @example
        * ```javascript
        * const chord = new Chord();
        * const copy = chord.copy();
        * console.log(chord.equals(copy)); // true
        * ```
        */
       equals(other) {
           return (this.root === other.root &&
               this.octave === other.octave &&
               isEqual(this._template, other.template));
       }
       /**
        * mutates the chord in place
        * @chainable
        * @returns the chord with a natrual 3rd
        * @example
        * ```javascript
        * const chord = new Chord();
        * chord.minor();
        * chord.major();
        * console.log(chord.template); // [1,3,5]
        * ```
        */
       major() {
           let index = -1;
           for (let i = 0; i < this._template.length; ++i) {
               if (this._template[i] === 3) {
                   index = i;
                   break;
               }
               const interval = this._template[i];
               if (Array.isArray(interval)) {
                   if ((interval[0] ?? 0) === 3) {
                       index = i;
                       break;
                   }
               }
           }
           if (index === -1) {
               this._template.push(3);
           }
           else {
               this._template[index] = 3;
           }
           this._notesDirty = true;
           return this;
       }
       /**
        * @chainable
        * @returns a copy of the chord with a natural 3rd
        * @example
        * ```javascript
        * const chord = new Chord();
        * chord.minor();
        * const copy = chord.majored();
        * console.log(copy.template); // [1,3,5]
        * ```
        */
       majored() {
           return this.copy().major();
       }
       /**
        * @returns true if the chord has a natural 3rd
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.isMajor()); // true
        * ```
        */
       isMajor() {
           for (const interval of this._template) {
               if (Array.isArray(interval)) {
                   if ((interval[0] ?? 0) === 3 && (interval[1] ?? 0) === 0) {
                       return true;
                   }
               }
               else {
                   if (interval === 3) {
                       return true;
                   }
               }
           }
           return false;
       }
       /**
        *  mutates the chord in place
        * @chainable
        * @returns the chord with a flat 3rd
        * @example
        * ```javascript
        * const chord = new Chord();
        * chord.minor();
        * console.log(chord.template); // [1,[3,-1],5]
        * ```
        */
       minor() {
           let index = -1;
           for (let i = 0; i < this._template.length; ++i) {
               if (this._template[i] === 3) {
                   index = i;
                   break;
               }
               const interval = this._template[i];
               if (Array.isArray(interval)) {
                   if ((interval[0] ?? 0) === 3) {
                       index = i;
                       break;
                   }
               }
           }
           if (index === -1) {
               this._template.push([3, -1]);
           }
           else {
               this._template[index] = [3, -1];
           }
           this._notesDirty = true;
           return this;
       }
       /**
        * @chainable
        * @returns a copy of the chord with a flat 3rd
        * @example
        * ```javascript
        * const chord = new Chord();
        * const copy = chord.minored();
        * console.log(copy.template); // [1,[3,-1],5]
        * ```
        */
       minored() {
           return this.copy().minor();
       }
       /**
        * @returns true if the chord has a flat 3rd
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.isMinor()); // false
        * chord.minor();
        * console.log(chord.isMinor()); // true
        * ```
        */
       isMinor() {
           for (const interval of this._template) {
               if (Array.isArray(interval)) {
                   if ((interval[0] ?? 0) === 3 && (interval[1] ?? 0) === -1) {
                       return true;
                   }
               }
           }
           return false;
       }
       /**
        * Mutates the chord in place
        * @chainable
        * @returns the chord with a sharp 5th
        * @example
        * ```javascript
        * const chord = new Chord();
        * chord.augment();
        * console.log(chord.template); // [1, 3, [5, Modifier.sharp]]
        * ```
        */
       augment() {
           let index = -1;
           for (let i = 0; i < this._template.length; ++i) {
               if (this._template[i] === 5) {
                   index = i;
                   break;
               }
               const interval = this._template[i];
               if (Array.isArray(interval)) {
                   if ((interval[0] ?? 0) === 5) {
                       index = i;
                       break;
                   }
               }
           }
           if (index === -1) {
               this._template.push([5, 1]);
           }
           else {
               this._template[index] = [5, 1];
           }
           this._notesDirty = true;
           return this;
       }
       /**
        * @chainable
        * @returns a copy of the chord with a sharp 5th
        * @example
        * ```javascript
        * const chord = new Chord();
        * const copy = chord.augmented();
        * console.log(copy.template); // [1, 3, [5, Modifier.sharp]]
        * ```
        */
       augmented() {
           return this.copy().augment();
       }
       /**
        * @returns true if the chord has a sharp 5th
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.isAugmented()); // false
        * chord.augment();
        * console.log(chord.isAugmented()); // true
        * ```
        */
       isAugmented() {
           for (const interval of this._template) {
               if (Array.isArray(interval)) {
                   if ((interval[0] ?? 0) === 5 && (interval[1] ?? 0) === 1) {
                       return true;
                   }
               }
           }
           return false;
       }
       /**
        * Mutates the chord in place
        * @chainable
        * @returns the chord with a flat 5th
        * @example
        * ```javascript
        * const chord = new Chord();
        * chord.diminish();
        * console.log(chord.template); // [1, 3, [5, Modifier.flat]]
        * ```
        */
       diminish() {
           let index = -1;
           for (let i = 0; i < this._template.length; ++i) {
               if (this._template[i] === 5) {
                   index = i;
                   break;
               }
               const interval = this._template[i];
               if (Array.isArray(interval)) {
                   if ((interval[0] ?? 0) === 5) {
                       index = i;
                       break;
                   }
               }
           }
           if (index === -1) {
               this._template.push([5, -1]);
           }
           else {
               this._template[index] = [5, -1];
           }
           this._notesDirty = true;
           return this;
       }
       /**
        * @chainable
        * @returns a copy of the chord with a flat 5th
        * @example
        * ```javascript
        * const chord = new Chord();
        * const copy = chord.diminished();
        * console.log(copy.template); // [1, 3, [5, Modifier.flat]]
        * ```
        */
       diminished() {
           return this.copy().diminish();
       }
       /**
        * @returns true if the chord has a flat 5th
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.isDiminished()); // false
        * chord.diminish();
        * console.log(chord.isDiminished()); // true
        * ```
        */
       isDiminished() {
           for (const interval of this._template) {
               if (Array.isArray(interval)) {
                   if ((interval[0] ?? 0) === 5 && (interval[1] ?? 0) === -1) {
                       return true;
                   }
               }
           }
           return false;
       }
       /**
        * Mutates the chord in place
        * @chainable
        * @returns the chord with a flat 3,5, and 7th
        * @example
        * ```javascript
        * const chord = new Chord();
        * chord.halfDiminish();
        * console.log(chord.template); // [1, [3, Modifier.flat], [5, Modifier.flat], [7, Modifier.flat]]
        *
        */
       halfDiminish() {
           this.minor(); // get flat 3rd
           this.diminish(); // get flat 5th
           let index = -1;
           for (let i = 0; i < this._template.length; ++i) {
               if (this._template[i] === 7) {
                   index = i;
                   break;
               }
               const interval = this._template[i];
               if (Array.isArray(interval)) {
                   if ((interval[0] ?? 0) === 7) {
                       index = i;
                       break;
                   }
               }
           }
           if (index === -1) {
               this._template.push([7, -1]);
           }
           else {
               this._template[index] = [7, -1];
           }
           this._notesDirty = true;
           return this;
       }
       /**
        * @chainable
        * @returns a copy of the chord with a flat 3,5, and 7th
        * @example
        * ```javascript
        * const chord = new Chord();
        * const copy = chord.halfDiminished();
        * console.log(copy.template); // [1, 3, [5, Modifier.flat], [7, Modifier.flat]]
        */
       halfDiminished() {
           return this.copy().halfDiminish();
       }
       /**
        * @returns true if the chord has a flat 3,5, and 7th
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.isHalfDiminished()); // false
        * chord.halfDiminish();
        * console.log(chord.isHalfDiminished()); // true
        */
       isHalfDiminished() {
           let third = false;
           let fifth = false;
           let seventh = false;
           for (const interval of this._template) {
               if (Array.isArray(interval)) {
                   if ((interval[0] ?? 0) === 7 && (interval[1] ?? 0) === -1) {
                       seventh = true;
                   }
                   else if ((interval[0] ?? 0) === 5 && (interval[1] ?? 0) === -1) {
                       fifth = true;
                   }
                   else if ((interval[0] ?? 0) === 3 && (interval[1] ?? 0) === -1) {
                       third = true;
                   }
               }
           }
           return third && fifth && seventh;
       }
       /**
        * Mutates the chord in place
        * @chainable
        * @returns the chord with with the first note moved to the end up one octave
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.template); // [1,3,5]
        * console.log(chord.getNoteNames()); // ['C4', 'E4', 'G4']
        * chord.invert();
        * console.log(chord.template); // [3,5,1]
        * console.log(chord.getNoteNames()); // ['E4', 'G4', 'C5']
        * ```
        */
       invert() {
           console.log(this._template[0]);
           if (Array.isArray(this._template[0])) {
               this._template[0][0] += this._baseScale.template.length;
           }
           else {
               this._template[0] += this._baseScale.template.length;
           }
           const newTemplate = shift(this._template, this._template.length - 1);
           this._template = newTemplate;
           this._notesDirty = true;
           return this;
       }
       /**
        * @chainable
        * @returns a copy of the chord with with the first note moved to the end up one octave
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.template); // [1,3,5]
        * console.log(chord.getNoteNames()); // ['C4', 'E4', 'G4']
        * const copy = chord.inverted();
        * console.log(copy.template); // [3,5,1]
        * console.log(copy.getNoteNames()); // ['E4', 'G4', 'C5']
        * ```
        */
       inverted() {
           return this.copy().invert();
       }
       /**
        * @returns the string form of the chord
        * @example
        * ```javascript
        * const chord = new Chord();
        * console.log(chord.toString()); // '(C4)maj'
        * ```
        */
       toString() {
           const keys = Object.keys(ChordTemplates);
           const values = Object.values(ChordTemplates).map((template) => JSON.stringify(template));
           const index = values.indexOf(JSON.stringify(this._template));
           const prefix = `(${Semitone$1[this._root]}${this._octave})`;
           const str = index > -1 ? prefix + keys[index] : this.getNoteNames().join(",");
           return str;
       }
   }

   /**
    * Builds lookup tables for more performant string parsing.<br/>
    * Should only(optionally) be called once soon after the library is loaded and<br/>
    * only if you are using string initializers.
    */
   const buildTables = () => {
       buildNoteTable();
       buildNoteStringTable();
       buildScaleTable();
       buildScaleNoteTable();
       buildScaleNameTable();
       buildChordTable();
   };

   exports.Chord = Chord;
   exports.ChordTemplates = ChordTemplates;
   exports.Instrument = Instrument;
   exports.Modifier = Modifier$1;
   exports.Note = Note;
   exports.Scale = Scale;
   exports.ScaleTemplates = ScaleTemplates;
   exports.Semitone = Semitone$1;
   exports.buildTables = buildTables;

   Object.defineProperty(exports, '__esModule', { value: true });

}));


/***/ }),

/***/ "./src/availablescales.ts":
/*!********************************!*\
  !*** ./src/availablescales.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAvailableScales": () => (/* binding */ getAvailableScales)
/* harmony export */ });
/* harmony import */ var musictheoryjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! musictheoryjs */ "./node_modules/musictheoryjs/dist/musictheory.js");
/* harmony import */ var musictheoryjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(musictheoryjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/utils.ts");


const scalesForNotes = (notes, params) => {
    const scales = new Set();
    // First add all scales
    for (const scaleSlug in params.scaleSettings) {
        const template = params.scaleSettings[scaleSlug];
        if (template.enabled) {
            for (let semitone = 0; semitone < 12; semitone++) {
                const scale = new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Scale({ key: semitone, template: musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.ScaleTemplates[scaleSlug] });
                scales.add({
                    key: semitone,
                    templateSlug: scaleSlug,
                    semitones: scale.notes.map(note => note.semitone),
                });
            }
        }
    }
    for (let note of notes) {
        const semitone = note.semitone;
        for (const scale of scales) {
            if (!scale.semitones.includes(semitone)) {
                scales.delete(scale);
            }
        }
    }
    const ret = [];
    for (const scale of scales) {
        ret.push(new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Scale({ key: scale.key, template: musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.ScaleTemplates[scale.templateSlug] }));
    }
    return ret;
};
const getAvailableScales = (values) => {
    const { latestDivision, divisionedRichNotes, params, randomNotes, logger } = values;
    // Given a new chord, find available scales base on the previous notes
    const currentAvailableScales = scalesForNotes(randomNotes, params);
    const ret = [];
    for (const scale of currentAvailableScales) {
        ret.push({
            scale,
            tension: 0,
        });
    }
    logger.log("currentAvailableScales", currentAvailableScales);
    // Go back a few chords and find the scales that are available.
    for (let i = 1; i < 4; i++) {
        const division = latestDivision - (i * _utils__WEBPACK_IMPORTED_MODULE_1__.BEAT_LENGTH);
        if (!divisionedRichNotes[division]) {
            continue;
        }
        const notes = divisionedRichNotes[division].map(richNote => richNote.note);
        const availableScales = scalesForNotes(notes, params);
        for (const potentialScale of ret) {
            const index = availableScales.findIndex(item => item.equals(potentialScale.scale));
            if (index == -1) {
                // Scale wasn't available, increase tension
                if (i == 1) {
                    potentialScale.tension += 20; // Base of how long ago it was
                }
                else if (i == 2) {
                    potentialScale.tension += 10;
                }
                else if (i == 3) {
                    potentialScale.tension += 5;
                }
                else if (i == 4) {
                    potentialScale.tension += 1;
                }
                logger.log("Scale ", potentialScale.scale.toString(), " wasn't available at division ", division, ", increase tension");
            }
        }
    }
    logger.print("Available scales", ret);
    return ret.filter(item => item.tension < 20);
};


/***/ }),

/***/ "./src/chords.ts":
/*!***********************!*\
  !*** ./src/chords.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildTables": () => (/* reexport safe */ musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.buildTables),
/* harmony export */   "makeMelody": () => (/* binding */ makeMelody),
/* harmony export */   "makeMusic": () => (/* binding */ makeMusic)
/* harmony export */ });
/* harmony import */ var musictheoryjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! musictheoryjs */ "./node_modules/musictheoryjs/dist/musictheory.js");
/* harmony import */ var musictheoryjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(musictheoryjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _mylogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mylogger */ "./src/mylogger.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/utils.ts");
/* harmony import */ var _randomchords__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./randomchords */ "./src/randomchords.ts");
/* harmony import */ var _inversions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./inversions */ "./src/inversions.ts");
/* harmony import */ var _tension__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tension */ "./src/tension.ts");
/* harmony import */ var _topmelody__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./topmelody */ "./src/topmelody.ts");
/* harmony import */ var _halfnotes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./halfnotes */ "./src/halfnotes.ts");
/* harmony import */ var _availablescales__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./availablescales */ "./src/availablescales.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};









const sleepMS = (ms) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise(resolve => setTimeout(resolve, ms));
});
const makeChords = (mainParams, progressCallback = null) => __awaiter(void 0, void 0, void 0, function* () {
    // generate a progression
    const beatsPerBar = mainParams.beatsPerBar || 4;
    const maxBeats = mainParams.getMaxBeats();
    //let currentScale = new Scale({ key: Math.floor(Math.random() * 12) , octave: 5, template: ScaleTemplates[params.scaleTemplate]});
    let currentScale = new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Scale({ key: 0, octave: 5 });
    let result = {};
    let tensions = [];
    let prevChord = null;
    let prevInversionName = null;
    const prevNotes = [];
    const prevMelody = [];
    // for (let i=0; i<maxTensions; i++) {
    //     // tensionBeats.push(Math.floor(Math.random() * (maxBeats - 10)) + 6);
    // }
    for (let division = 0; division < maxBeats * _utils__WEBPACK_IMPORTED_MODULE_2__.BEAT_LENGTH; division += _utils__WEBPACK_IMPORTED_MODULE_2__.BEAT_LENGTH) {
        const params = mainParams.currentCadenceParams(division);
        const beatsUntilLastChordInCadence = params.beatsUntilCadenceEnd;
        console.groupCollapsed("division", division, prevChord ? prevChord.toString() : "null", " scale ", currentScale.toString());
        const currentBeat = Math.floor(division / _utils__WEBPACK_IMPORTED_MODULE_2__.BEAT_LENGTH);
        console.log("beatsUntilLastChordInCadence", beatsUntilLastChordInCadence);
        const beatSetting = params.beatSettings[currentBeat];
        let tensionOverride = null;
        if (beatSetting) {
            tensionOverride = parseFloat(beatSetting.tension);
        }
        else {
            tensionOverride = params.baseTension;
        }
        let chordIsGood = false;
        const randomGenerator = new _randomchords__WEBPACK_IMPORTED_MODULE_3__.RandomChordGenerator(params, currentScale);
        let newChord = null;
        let tension = 0;
        let newScale = null;
        let oldNewScale = null;
        const randomNotes = [];
        let iterations = 0;
        let bestResult = {
            notes: [],
            tension: 999,
            scale: currentScale,
            chord: null,
        };
        let closestTension = -100;
        let wantedTension = 0;
        let goBack = false;
        while (!chordIsGood) {
            iterations++;
            if (iterations % 100) {
                yield sleepMS(100);
            }
            if (iterations > 1000) {
                console.log("Too many iterations, breaking, closestTension: ", closestTension);
                goBack = true;
                break;
            }
            let criteriaLevel = Math.floor(iterations / (50));
            if (iterations % 100 == 0) {
                // Try previous chords again with different criteriaLevel...
                randomGenerator.cleanUp();
            }
            newChord = randomGenerator.getChord();
            const chordLogger = new _mylogger__WEBPACK_IMPORTED_MODULE_1__.Logger();
            let allInversions;
            let availableScales;
            if (beatsUntilLastChordInCadence == 1) {
                // Force same chord twice
                chordIsGood = true;
                randomNotes.splice(0, randomNotes.length);
                randomNotes.push(...prevNotes);
                newChord = prevChord;
                tension = 0;
            }
            else if (!newChord) {
                chordLogger.log("Failed to get a new chord (all used) Using the best result");
                if (bestResult.tension < 10 || division == 0) {
                    console.groupEnd();
                    console.groupCollapsed("Best result is good enough, using it");
                    chordIsGood = true;
                    randomNotes.splice(0, randomNotes.length);
                    randomNotes.push(...bestResult.notes);
                    newChord = bestResult.chord;
                    if (!prevChord) {
                        prevChord = newChord;
                    }
                    tension = bestResult.tension;
                }
                else {
                    console.groupEnd();
                    console.log("Best result is not good enough, going back");
                    // Go back to previous chord, and make it again
                    chordIsGood = false;
                    goBack = true;
                    break;
                }
            }
            else {
                const availableScaleLogger = new _mylogger__WEBPACK_IMPORTED_MODULE_1__.Logger(chordLogger);
                availableScales = (0,_availablescales__WEBPACK_IMPORTED_MODULE_8__.getAvailableScales)({
                    latestDivision: division,
                    divisionedRichNotes: result,
                    params: params,
                    randomNotes: newChord.notes,
                    logger: availableScaleLogger,
                });
                if (prevMelody.length > 0) {
                    if (maxBeats - currentBeat < 3 || beatsUntilLastChordInCadence < 3 || currentBeat < 5) {
                        // Don't allow other scales than the current one
                        availableScales = availableScales.filter(s => s.scale.equals(currentScale));
                    }
                }
                if (availableScales.length == 0) {
                    continue;
                }
                allInversions = (0,_inversions__WEBPACK_IMPORTED_MODULE_4__.getInversions)(newChord, prevNotes, currentBeat, params, new _mylogger__WEBPACK_IMPORTED_MODULE_1__.Logger(chordLogger), maxBeats - currentBeat);
            }
            if (!chordIsGood) {
                for (const inversionResult of allInversions) {
                    if (chordIsGood) {
                        break;
                    }
                    const inversionLogger = new _mylogger__WEBPACK_IMPORTED_MODULE_1__.Logger(chordLogger);
                    inversionLogger.title = ["Inversion ", `${inversionResult.inversionName}`];
                    randomNotes.splice(0, randomNotes.length); // Empty this and replace contents
                    randomNotes.push(...inversionResult.notes);
                    let bestTension = 999;
                    for (const availableScale of availableScales) {
                        const scaleLogger = new _mylogger__WEBPACK_IMPORTED_MODULE_1__.Logger(inversionLogger);
                        const chordTensionLogger = new _mylogger__WEBPACK_IMPORTED_MODULE_1__.Logger(scaleLogger);
                        scaleLogger.title = ["Scale ", `${availableScale.scale.toString()}`];
                        if (chordIsGood) {
                            break;
                        }
                        const tensionResult = (0,_tension__WEBPACK_IMPORTED_MODULE_5__.getTension)(result, randomNotes, availableScale.scale, beatsUntilLastChordInCadence, params, chordTensionLogger, maxBeats - currentBeat, inversionResult.inversionName, prevInversionName);
                        chordTensionLogger.title = [
                            prevChord ? prevChord.toString() : "", " -> ", newChord.toString(), ": ", tensionResult.tension
                        ];
                        for (const chord in params.chordSettings) {
                            const chordSetting = params.chordSettings[chord];
                            const chordWeight = parseFloat(`${chordSetting.weight}` || '0');
                            if (newChord.chordType == chord) {
                                tensionResult.tension -= (Math.pow((chordWeight * 10), 3)) / 10;
                                chordTensionLogger.log("Chord ", chord, " weight: ", chordWeight, " tension: ", tensionResult.tension);
                            }
                        }
                        tensionResult.tension += availableScale.tension / Math.max(0.01, params.modulationWeight);
                        chordTensionLogger.log("Scale tension: ", tensionResult.tension);
                        if (prevMelody.length > 0) {
                            if (!availableScale.scale.equals(currentScale)) {
                                tensionResult.tension += 1 / Math.max(0.01, params.modulationWeight);
                                chordTensionLogger.log("Scale change tension: ", tensionResult.tension);
                                if (maxBeats - currentBeat < 3) {
                                    // Last 2 bars, don't change scale
                                    tensionResult.tension += 100;
                                }
                                if (beatsUntilLastChordInCadence < 3) {
                                    // Don't change scale in last 2 beats of cadence
                                    tensionResult.tension += 100;
                                }
                                if (currentBeat < 5) {
                                    // Don't change scale in first 5 beats
                                    tensionResult.tension += 100;
                                }
                            }
                        }
                        tension = tensionResult.tension;
                        wantedTension = 0.4;
                        // if (tensionBeats.includes(currentBeat)) {
                        //     wantedTension = highTension;
                        // }
                        if (maxBeats - currentBeat < 4) {
                            // Final bar
                            wantedTension = -0.5;
                        }
                        if (beatsUntilLastChordInCadence < 3) {
                            wantedTension = -0.7;
                        }
                        else {
                            wantedTension += (0.1 * criteriaLevel);
                        }
                        if (tensionOverride != null) {
                            wantedTension = parseFloat(tensionOverride);
                            wantedTension += (0.1 * criteriaLevel);
                        }
                        if (tension < bestTension) {
                            bestTension = tension;
                        }
                        if (tension < wantedTension) {
                            chordIsGood = true;
                            newScale = availableScale.scale.copy();
                            chordTensionLogger.log("Chord is good: ", tension, " wanted: ", wantedTension);
                            prevInversionName = inversionResult.inversionName;
                            break; // Skip checking other voice leading inversions
                        }
                        else {
                            if (tension < bestResult.tension) {
                                bestResult.tension = tension;
                                bestResult.notes.splice(0, bestResult.notes.length);
                                bestResult.notes.push(...randomNotes);
                                bestResult.chord = newChord;
                            }
                            chordTensionLogger.log("Chord is bad: ", tension, " wanted: ", wantedTension);
                            if (Math.abs(tension - wantedTension) < Math.abs(closestTension - wantedTension)) {
                                closestTension = tension;
                            }
                            if (progressCallback) {
                                const giveUP = progressCallback(null, null);
                                if (giveUP) {
                                    // Reduce cadence count to fix errors later
                                    // FIXME
                                    // params.cadenceCount = Math.floor((currentBeat / (barsPerCadenceEnd * beatsPerBar)));
                                    return result;
                                }
                            }
                        }
                        scaleLogger.title.push("tension: ");
                        scaleLogger.title.push(`${tension}`);
                    } // For available scales end
                    inversionLogger.title.push("tension: ");
                    inversionLogger.title.push(`${bestTension}`);
                    inversionLogger.print();
                } // For voiceleading results end
            }
            chordLogger.print(prevChord ? prevChord.toString() : "", " -> ", newChord.toString(), ": ", tension.toFixed(1), " (" + wantedTension + ")");
        } // While end
        if (goBack) {
            // Go back to previous chord, and make it again
            if (division >= 0) {
                division -= _utils__WEBPACK_IMPORTED_MODULE_2__.BEAT_LENGTH * 2;
            }
            continue;
        }
        if (newChord == null) {
            return {};
        }
        tensions.push(tension);
        const newChordString = newChord.toString();
        if (newScale) {
            currentScale = newScale;
            //console.log("new scale: ", currentScale.toString());
        }
        if (newScale) {
            oldNewScale = newScale;
        }
        prevMelody.push(randomNotes[0]);
        //console.log(`${beatsUntilLastChordInCadence}: ${tension.toFixed(1)} - ${newChordString} (${currentScale.toString()})`);
        result[currentBeat * _utils__WEBPACK_IMPORTED_MODULE_2__.BEAT_LENGTH] = randomNotes.map((note, index) => ({
            note: note,
            partIndex: index,
            duration: _utils__WEBPACK_IMPORTED_MODULE_2__.BEAT_LENGTH,
            chord: newChord,
            scale: currentScale,
            tension: tension,
            inversionName: `${prevInversionName}`,
        }));
        if (progressCallback) {
            progressCallback(currentBeat, result[currentBeat * _utils__WEBPACK_IMPORTED_MODULE_2__.BEAT_LENGTH]);
        }
        prevChord = newChord;
        prevNotes.splice(0, prevNotes.length);
        prevNotes.push(...randomNotes);
        randomGenerator.cleanUp();
        console.groupEnd();
    }
    return result;
});
function makeMusic(params, progressCallback = null) {
    return __awaiter(this, void 0, void 0, function* () {
        let divisionedNotes = {};
        let iterations = 0;
        while (true) {
            iterations++;
            if (iterations > 5) {
                console.log("Too many iterations, breaking");
                return {
                    divisionedNotes: {},
                };
            }
            divisionedNotes = yield makeChords(params, progressCallback);
            if (Object.keys(divisionedNotes).length != 0) {
                break;
            }
            yield new Promise((resolve) => setTimeout(resolve, 1000));
        }
        // const divisionedNotes: DivisionedRichnotes = newVoiceLeadingNotes(chords, params);
        (0,_topmelody__WEBPACK_IMPORTED_MODULE_6__.buildTopMelody)(divisionedNotes, params);
        // addEighthNotes(divisionedNotes, params)
        (0,_halfnotes__WEBPACK_IMPORTED_MODULE_7__.addHalfNotes)(divisionedNotes, params);
        return {
            divisionedNotes: divisionedNotes,
        };
    });
}
function makeMelody(divisionedNotes, mainParams) {
    // Remove old melody and make a new one
    const maxBeats = mainParams.getMaxBeats();
    for (let division = 0; division < maxBeats * _utils__WEBPACK_IMPORTED_MODULE_2__.BEAT_LENGTH; division++) {
        const onBeat = division % _utils__WEBPACK_IMPORTED_MODULE_2__.BEAT_LENGTH == 0;
        if (!onBeat) {
            divisionedNotes[division] = [];
        }
        else if (divisionedNotes[division] && divisionedNotes[division].length > 0) {
            divisionedNotes[division].forEach(richNote => {
                richNote.duration = _utils__WEBPACK_IMPORTED_MODULE_2__.BEAT_LENGTH;
                richNote.tie = undefined;
            });
        }
    }
    // const divisionedNotes: DivisionedRichnotes = newVoiceLeadingNotes(chords, params);
    (0,_topmelody__WEBPACK_IMPORTED_MODULE_6__.buildTopMelody)(divisionedNotes, mainParams);
    // addEighthNotes(divisionedNotes, params)
    (0,_halfnotes__WEBPACK_IMPORTED_MODULE_7__.addHalfNotes)(divisionedNotes, mainParams);
}
// export async function testFunc(params: MusicParams) {
//     console.log(params)
//     let chords: Array<Array<RichNote>> = [];
//     chords = moonlightsonata
//         .map((noteNames) => (
//             noteNames.map(
//                 (noteName) => ({
//                     note: new Note(noteName),
//                     duration: BEAT_LENGTH,
//                 }) as RichNote
//             )
//         ));
//     const divisionedNotes: DivisionedRichnotes = {};
//     // Lower all semitones by 4
//     chords.forEach(richNoteList => richNoteList.forEach(richNote => {
//         const gTone = globalSemitone(richNote.note) - 4;
//         richNote.note.semitone = gTone % 12;
//         richNote.note.octave = Math.floor(gTone / 12);
//     }))
//     let prevChord = chords[0];
//     for (let i=0; i<chords.length; i++) {
//         const chord = chords[i];
//         const scale = new Scale({key: 0, template: ScaleTemplates.major});
//         console.log(getTension(prevChord.map(richNote => richNote.note), chord.map(richNote => richNote.note), scale, 10, params));
//         prevChord = chord;
//         divisionedNotes[i * BEAT_LENGTH] = chord.map((note, index) => ({
//             note: note.note,
//             partIndex: index,
//             duration: BEAT_LENGTH,
//             scale: scale,
//         }) as RichNote);
//     }
//     return {
//         chords: chords,
//         divisionedNotes: divisionedNotes,
//     }
// }



/***/ }),

/***/ "./src/halfnotes.ts":
/*!**************************!*\
  !*** ./src/halfnotes.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addHalfNotes": () => (/* binding */ addHalfNotes)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/utils.ts");

const addHalfNotes = (divisionedNotes, mainParams) => {
    const beatsPerBar = mainParams.beatsPerBar || 4;
    const lastDivision = mainParams.getMaxBeats() * _utils__WEBPACK_IMPORTED_MODULE_0__.BEAT_LENGTH;
    for (let division = 0; division < lastDivision - _utils__WEBPACK_IMPORTED_MODULE_0__.BEAT_LENGTH; division += _utils__WEBPACK_IMPORTED_MODULE_0__.BEAT_LENGTH) {
        const params = mainParams.currentCadenceParams(division);
        const lastBeat = Math.floor(division / _utils__WEBPACK_IMPORTED_MODULE_0__.BEAT_LENGTH) * _utils__WEBPACK_IMPORTED_MODULE_0__.BEAT_LENGTH;
        let beatsUntilLastChordInCadence = params.beatsUntilCadenceEnd;
        let cadenceEnding = beatsUntilLastChordInCadence < 2;
        if (params.halfNotes && !cadenceEnding) {
            // Add a tie start to the previous note to double length, and tie stop to this
            // if it's continuing with the same
            const previousNotes = divisionedNotes[division - 12] || [];
            const currentNotes = divisionedNotes[division] || [];
            for (let i = 0; i < 4; i++) {
                const previousNote = previousNotes.filter((n) => n.partIndex == i)[0];
                const currentNote = currentNotes.filter((n) => n.partIndex == i)[0];
                if (previousNote && currentNote && previousNote.note.equals(currentNote.note)) {
                    if (previousNote.duration != _utils__WEBPACK_IMPORTED_MODULE_0__.BEAT_LENGTH) {
                        continue;
                    }
                    if (currentNote.duration != _utils__WEBPACK_IMPORTED_MODULE_0__.BEAT_LENGTH) {
                        continue;
                    }
                    if (previousNote.tie != null) {
                        continue;
                    }
                    previousNote.tie = "start";
                    currentNote.tie = "stop";
                }
            }
            console.log("previousNotes: ", previousNotes);
        }
    }
};


/***/ }),

/***/ "./src/inversions.ts":
/*!***************************!*\
  !*** ./src/inversions.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getInversions": () => (/* binding */ getInversions)
/* harmony export */ });
/* harmony import */ var musictheoryjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! musictheoryjs */ "./node_modules/musictheoryjs/dist/musictheory.js");
/* harmony import */ var musictheoryjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(musictheoryjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/utils.ts");


const getInversions = (chord, prevNotes, beat, params, logger, beatsUntilLastChordInSong) => {
    // Return Notes in the Chord that are closest to the previous notes
    // For each part
    const p1Note = params.parts[0].note || "F4";
    const p2Note = params.parts[1].note || "C4";
    const p3Note = params.parts[2].note || "A3";
    const p4Note = params.parts[3].note || "C3";
    const startingGlobalSemitones = [
        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note(p1Note)),
        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note(p2Note)),
        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note(p3Note)),
        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note(p4Note)),
    ];
    const semitoneLimits = [
        [startingGlobalSemitones[0] + -12, startingGlobalSemitones[0] + 12 - 5],
        [startingGlobalSemitones[1] + -12, startingGlobalSemitones[1] + 12 - 5],
        [startingGlobalSemitones[2] + -12, startingGlobalSemitones[2] + 12 - 5],
        [startingGlobalSemitones[3] + -12, startingGlobalSemitones[3] + 12 - 5],
    ];
    logger.log(semitoneLimits);
    // Add a result for each possible inversion
    const ret = [];
    let lastBeatGlobalSemitones = [...startingGlobalSemitones];
    if (prevNotes) {
        lastBeatGlobalSemitones = prevNotes.map(note => (0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(note));
    }
    if (!chord) {
        return [];
    }
    if (chord) {
        // For each beat, we try to find a good matching semitone for each part.
        // Rules:
        // With	root position triads: double the root. 
        // With first inversion triads: double the root or 5th, in general. If one needs to double 
        // the 3rd, that is acceptable, but avoid doubling the leading tone.
        // With second inversion triads: double the fifth. 
        // With  seventh  chords:  there  is  one voice  for  each  note,  so  distribute as  fits. If  one 
        // must omit a note from the chord, then omit the 5th.
        const firstInterval = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.semitoneDistance)(chord.notes[0].semitone, chord.notes[1].semitone);
        const thirdIsGood = firstInterval == 3 || firstInterval == 4;
        logger.log("notes: ", chord.notes.map(n => n.toString()));
        // Depending on the inversion and chord type, we're doing different things
        let inversionNames = ["root", "first-root", "first-third", "first-fifth", "second"];
        let combinationCount = 3 * 2 * 1;
        if (chord.notes.length > 3) {
            inversionNames = ["root", "first", "second", "third"];
        }
        for (let skipFifthIndex = 0; skipFifthIndex < 2; skipFifthIndex++) {
            for (let inversionIndex = 0; inversionIndex < inversionNames.length; inversionIndex++) {
                for (let combinationIndex = 0; combinationIndex < combinationCount; combinationIndex++) {
                    const skipFifth = skipFifthIndex == 1;
                    // We try each inversion. Which is best?
                    const inversion = inversionNames[inversionIndex];
                    if (beatsUntilLastChordInSong < 2) {
                        if (!inversion.startsWith('root')) {
                            continue; // Don't do anything but root position on the last chord
                        }
                    }
                    const inversionResult = {
                        gToneDiffs: [],
                        notes: {},
                        rating: 0,
                        inversionName: inversionNames[inversionIndex],
                    };
                    if (skipFifth) {
                        inversionResult.inversionName += "-skipFifth";
                    }
                    const addPartNote = (partIndex, note) => {
                        inversionResult.notes[partIndex] = new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note({
                            semitone: note.semitone,
                            octave: 1 // dummy
                        });
                    };
                    logger.log("inversion: ", inversion, "skipFifth: ", skipFifth);
                    let partToIndex = {};
                    // First select bottom note
                    if (inversion.startsWith('root')) {
                        partToIndex[3] = 0;
                    }
                    else if (inversion.startsWith('first')) {
                        partToIndex[3] = 1;
                    }
                    else if (inversion.startsWith('second')) {
                        partToIndex[3] = 2;
                    }
                    else if (inversion.startsWith('third')) {
                        partToIndex[3] = 3;
                    }
                    // List notes we have left over
                    let leftOverIndexes = [];
                    if (chord.notes.length == 3) {
                        if (inversion == "root") {
                            leftOverIndexes = [0, 1, 2]; // Double the root
                        }
                        else if (inversion == "first-root") {
                            // First -> We already have 1
                            leftOverIndexes = [0, 0, 2]; // Double the root
                        }
                        else if (inversion == "first-third") {
                            leftOverIndexes = [0, 1, 2]; // Double the third
                        }
                        else if (inversion == "first-fifth") {
                            leftOverIndexes = [0, 2, 2]; // Double the fifth
                        }
                        else if (inversion == "second") {
                            // Second -> We already have 2
                            leftOverIndexes = [0, 0, 1]; // Double the root
                        }
                    }
                    else if (chord.notes.length == 4) {
                        leftOverIndexes = [0, 1, 2, 3].filter(i => i != partToIndex[3]);
                    }
                    if (skipFifth) {
                        if (partToIndex[3] == 2) {
                            // Can't skip fifth in second inversion
                            continue;
                        }
                        if (leftOverIndexes.filter(i => i == 2).length != 0) {
                            // Can't skip fifth if we have two
                            continue;
                        }
                        leftOverIndexes = leftOverIndexes.filter(i => i != 2);
                        // Add either a 0 or 1 to replace the fifth
                        if (leftOverIndexes.filter(i => i == 0).length == 1) {
                            leftOverIndexes.push(0);
                        }
                        else {
                            leftOverIndexes.push(1);
                        }
                    }
                    // Depending on combinationIndex, we select the notes for partIndexes 0, 1, 2
                    if (combinationIndex === 0) {
                        // First permutation
                        partToIndex[0] = leftOverIndexes[0];
                        partToIndex[1] = leftOverIndexes[1];
                        partToIndex[2] = leftOverIndexes[2];
                    }
                    else if (combinationIndex === 1) {
                        // Second permutation
                        partToIndex[0] = leftOverIndexes[0];
                        partToIndex[1] = leftOverIndexes[2];
                        partToIndex[2] = leftOverIndexes[1];
                    }
                    else if (combinationIndex === 2) {
                        // Third permutation
                        partToIndex[0] = leftOverIndexes[1];
                        partToIndex[1] = leftOverIndexes[0];
                        partToIndex[2] = leftOverIndexes[2];
                    }
                    else if (combinationIndex === 3) {
                        // Fourth permutation
                        partToIndex[0] = leftOverIndexes[1];
                        partToIndex[1] = leftOverIndexes[2];
                        partToIndex[2] = leftOverIndexes[0];
                    }
                    else if (combinationIndex === 4) {
                        // Fifth permutation
                        partToIndex[0] = leftOverIndexes[2];
                        partToIndex[1] = leftOverIndexes[0];
                        partToIndex[2] = leftOverIndexes[1];
                    }
                    else if (combinationIndex === 5) {
                        // Sixth permutation
                        partToIndex[0] = leftOverIndexes[2];
                        partToIndex[1] = leftOverIndexes[1];
                        partToIndex[2] = leftOverIndexes[0];
                    }
                    for (let partIndex = 0; partIndex < 4; partIndex++) {
                        if (inversionResult.notes[partIndex]) {
                            // This part is already set
                            continue;
                        }
                        addPartNote(partIndex, chord.notes[partToIndex[partIndex]]);
                    }
                    // Lastly, we select the lowest possible octave for each part
                    let minSemitone = 0;
                    for (let partIndex = 3; partIndex >= 0; partIndex--) {
                        const note = inversionResult.notes[partIndex];
                        let gTone = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(note);
                        let i = 0;
                        while (gTone < semitoneLimits[partIndex][0] || gTone < minSemitone) {
                            i++;
                            if (i > 1000) {
                                debugger;
                                throw "Too many iterations";
                            }
                            gTone += 12;
                        }
                        inversionResult.notes[partIndex] = new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note({
                            semitone: gTone % 12,
                            octave: Math.floor(gTone / 12),
                        });
                    }
                    // Make a copy inversionresult for each possible octave combination
                    const initialPart0Note = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(inversionResult.notes[0]);
                    const initialPart1Note = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(inversionResult.notes[1]);
                    const initialPart2Note = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(inversionResult.notes[2]);
                    const initialPart3Note = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(inversionResult.notes[3]);
                    for (let part0Octave = 0; part0Octave < 3; part0Octave++) {
                        const part0Note = initialPart0Note + part0Octave * 12;
                        if (part0Note > semitoneLimits[0][1]) {
                            continue;
                        }
                        for (let part1Octave = 0; part1Octave < 3; part1Octave++) {
                            const part1Note = initialPart1Note + part1Octave * 12;
                            if (part1Note > part0Note) {
                                continue;
                            }
                            if (part1Note > semitoneLimits[1][1]) {
                                continue;
                            }
                            for (let part2Octave = 0; part2Octave < 3; part2Octave++) {
                                const part2Note = initialPart2Note + part2Octave * 12;
                                if (part2Note > part1Note) {
                                    continue;
                                }
                                if (part2Note > semitoneLimits[2][1]) {
                                    continue;
                                }
                                for (let part3Octave = 0; part3Octave < 3; part3Octave++) {
                                    const part3Note = initialPart3Note + part3Octave * 12;
                                    if (part3Note > part2Note) {
                                        continue;
                                    }
                                    if (part3Note > semitoneLimits[3][1]) {
                                        continue;
                                    }
                                    ret.push({
                                        notes: [
                                            new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note({
                                                semitone: part0Note % 12,
                                                octave: Math.floor(part0Note / 12),
                                            }),
                                            new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note({
                                                semitone: part1Note % 12,
                                                octave: Math.floor(part1Note / 12),
                                            }),
                                            new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note({
                                                semitone: part2Note % 12,
                                                octave: Math.floor(part2Note / 12),
                                            }),
                                            new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note({
                                                semitone: part3Note % 12,
                                                octave: Math.floor(part3Note / 12),
                                            }),
                                        ],
                                        inversionName: inversionResult.inversionName,
                                        rating: 0,
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    logger.print("newVoiceLeadingNotes: ", chord.toString(), " beat: ", beat);
    // Randomize order of ret
    for (let i = 0; i < ret.length; i++) {
        const j = Math.floor(Math.random() * ret.length);
        const tmp = ret[i];
        ret[i] = ret[j];
        ret[j] = tmp;
    }
    return ret;
};


/***/ }),

/***/ "./src/musicxmlgen.ts":
/*!****************************!*\
  !*** ./src/musicxmlgen.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toXml": () => (/* binding */ toXml)
/* harmony export */ });
/* harmony import */ var musictheoryjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! musictheoryjs */ "./node_modules/musictheoryjs/dist/musictheory.js");
/* harmony import */ var musictheoryjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(musictheoryjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var xmlbuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xmlbuilder */ "./node_modules/xmlbuilder/lib/index.js");
/* harmony import */ var xmlbuilder__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(xmlbuilder__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/utils.ts");



const BEAT_LENGTH = 12;
function semitoneToPitch(semitone, scale, direction = "sharp") {
    for (const note of scale.notes) {
        if (note.semitone === semitone) {
            return {
                noteName: note.toString().substring(0, 1),
                alter: 0,
            };
        }
    }
    for (const note of scale.notes) {
        if (direction == "flat" && note.semitone === semitone + 1) {
            return {
                noteName: note.toString().substring(0, 1),
                alter: -1,
            };
        }
        if (direction == "sharp" && note.semitone === semitone - 1) {
            return {
                noteName: note.toString().substring(0, 1),
                alter: 1,
            };
        }
    }
    throw new Error("Could not find note for semitone " + semitone);
}
function richNoteDuration(richNote) {
    const duration = richNote.duration;
    let type = 'quarter';
    if (duration === BEAT_LENGTH * 4) {
        type = 'whole';
    }
    else if (duration === BEAT_LENGTH * 2) {
        type = 'half';
    }
    else if (duration === BEAT_LENGTH) {
        type = 'quarter';
    }
    else if (duration == BEAT_LENGTH / 2) {
        type = 'eighth';
    }
    else if (duration == BEAT_LENGTH / 4) {
        type = '16th';
    }
    return {
        'duration': duration,
        'type': type,
    };
}
const flatScaleSemitones = new Set([
    (new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note('F')).semitone,
    (new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note('Bb')).semitone,
    (new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note('Eb')).semitone,
    (new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note('Ab')).semitone,
    (new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note('Db')).semitone,
    (new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note('Gb')).semitone,
]);
function noteToPitch(richNote) {
    const note = richNote.note;
    const noteScale = richNote.scale;
    const scoreScale = new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Scale({ key: 0, octave: note.octave, template: musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.ScaleTemplates.major });
    let direction = 'sharp';
    if (noteScale) {
        const base = noteScale.notes[0].semitone;
        if (flatScaleSemitones.has(base)) {
            direction = 'flat';
        }
    }
    const pitch = semitoneToPitch(note.semitone, scoreScale, direction);
    return {
        'step': { '#text': pitch.noteName },
        'alter': pitch.alter,
        'octave': { '#text': note.octave }
    };
}
function addRichNoteToMeasure(richNote, measure, staff, voice, firstNoteInChord, writeChord, keychange = undefined, params) {
    if (richNote.duration == 0) {
        return;
    }
    const duration = richNoteDuration(richNote);
    let beamNumber = 1;
    let notations = undefined;
    if (richNote.tie) {
        notations = {
            tied: {
                '@type': richNote.tie,
            }
        };
    }
    let lyric = richNote.tension && staff == 0 ? { 'text': { '#text': richNote.tension.toFixed(2) } } : undefined;
    if (richNote.scale && richNote.chord && staff == 1) {
        const roman = richNote.scale.notes.map(n => n.semitone).indexOf(richNote.chord.notes[0].semitone);
        const numberToRoman = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII'];
        let romanNumeral = numberToRoman[roman];
        if (richNote.chord.chordType == 'min') {
            romanNumeral = romanNumeral.toLowerCase();
        }
        if (richNote.chord.chordType == 'dim') {
            romanNumeral = romanNumeral.toLowerCase() + '';
        }
        if (richNote.chord.chordType == 'dom7') {
            romanNumeral = romanNumeral + '7';
        }
        if (richNote.inversionName) {
            if (richNote.inversionName.startsWith('first')) {
                romanNumeral = romanNumeral + '6';
            }
            if (richNote.inversionName.startsWith('second')) {
                romanNumeral = romanNumeral + '64';
            }
        }
        lyric = { 'text': { '#text': romanNumeral } };
    }
    const attrs = {
        'chord': !firstNoteInChord ? {} : undefined,
        'pitch': noteToPitch(richNote),
        'duration': duration.duration,
        'voice': voice,
        'stem': { '#text': voice == 0 ? 'up' : 'down', '@default-y': voice == 0 ? 5 : -45 },
        'type': duration.type,
        'staff': staff,
        'beam': richNote.beam ? { '@number': beamNumber, '#text': richNote.beam } : undefined,
        'tie': richNote.tie ? { '@type': richNote.tie } : undefined,
        'lyric': lyric,
        'notations': notations,
    };
    if (writeChord && richNote.chord && staff == 1) {
        let chordType = 'major';
        const chordTemplateKey = richNote.chord.chordType;
        let kindText = chordTemplateKey;
        console.log("Chord template key: " + chordTemplateKey);
        if (chordTemplateKey == "maj") {
            chordType = 'major';
            kindText = '';
        }
        else if (chordTemplateKey == "min") {
            chordType = 'minor';
            kindText = 'm';
        }
        else if (chordTemplateKey == "dim") {
            chordType = 'diminished';
        }
        else if (chordTemplateKey == "aug") {
            chordType = 'augmented';
        }
        else if (chordTemplateKey == "dom7") {
            chordType = 'dominant';
            kindText = "7";
        }
        else if (chordTemplateKey == "maj7") {
            chordType = 'major-seventh';
        }
        else if (chordTemplateKey == "min7") {
            chordType = 'minor-seventh';
            kindText = "m7";
        }
        else if (chordTemplateKey == "sus2") {
            chordType = 'suspended-second';
            kindText = "sus2";
        }
        else if (chordTemplateKey == "sus4") {
            chordType = 'suspended-fourth';
            kindText = "sus4";
        }
        const scoreScale = new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Scale({ key: 0, octave: 4, template: musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.ScaleTemplates.major });
        let direction = 'sharp';
        if (richNote.scale) {
            const base = richNote.scale.notes[0].semitone;
            if (flatScaleSemitones.has(base)) {
                direction = 'flat';
            }
        }
        const pitch = semitoneToPitch(richNote.chord.notes[0].semitone, scoreScale, direction);
        measure.ele({ 'harmony': {
                'root': {
                    'root-step': { '#text': pitch.noteName },
                    'root-alter': pitch.alter,
                },
                'kind': {
                    '@halign': 'center',
                    '@text': kindText,
                    '#text': chordType,
                }
            }
        });
    }
    if (keychange) {
        const attributes = measure.ele('attributes');
        attributes.ele({ 'key': {
                'cancel': { '#text': keychange.cancel },
                'fifths': { '#text': keychange.fifths },
                'mode': { '#text': keychange.mode },
            } });
    }
    measure.ele({ 'note': attrs });
}
function firstMeasureInit(voicePartIndex, measure, params) {
    let clef;
    const semitones = [
        (0,_utils__WEBPACK_IMPORTED_MODULE_2__.globalSemitone)(new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note(params.parts[0].note || "F4")),
        (0,_utils__WEBPACK_IMPORTED_MODULE_2__.globalSemitone)(new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note(params.parts[1].note || "C4")),
        (0,_utils__WEBPACK_IMPORTED_MODULE_2__.globalSemitone)(new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note(params.parts[2].note || "A3")),
        (0,_utils__WEBPACK_IMPORTED_MODULE_2__.globalSemitone)(new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note(params.parts[3].note || "C3")),
    ];
    let clefSemitoneIndex;
    if (voicePartIndex <= 1) {
        clefSemitoneIndex = 1;
    }
    else {
        clefSemitoneIndex = 3;
    }
    const mySemitone = semitones[clefSemitoneIndex];
    if (mySemitone < 45) {
        clef = {
            '@number': 1,
            'sign': 'F',
            'line': 4,
        };
    }
    else if (mySemitone < 50) {
        clef = {
            '@number': 1,
            'sign': 'G',
            'line': 2,
            'clef-octave-change': {
                '#text': '-1'
            }
        };
    }
    else {
        clef = {
            '@number': 1,
            'sign': 'G',
            'line': 2,
        };
    }
    measure.ele({ 'attributes': {
            'divisions': { '#text': `${BEAT_LENGTH}` },
            'key': {
                'fifths': { '#text': '0' }
            },
            'time': {
                'beats': { '#text': params.beatsPerBar },
                'beat-type': { '#text': '4' }
            },
            'staves': 1,
            clef: [
                clef
            ]
        },
        'direction': {
            '@placement': 'above',
            'direction-type': {
                'metronome': {
                    'beat-unit': 'quarter',
                    'per-minute': `${params.tempo || 40}`
                }
            },
            'sound': {
                '@tempo': `${params.tempo || 40}`
            }
        }
    });
}
const getScaleSharpCount = (scale) => {
    let sharpCount = 0;
    const semitone = scale.key;
    const baseTones = [0, 2, 4, 5, 7, 9, 11];
    if (semitone == 0 || semitone == 2 || semitone == 4 || semitone == 7 || semitone == 9 || semitone == 11) {
        // Add sharps to the scale
        for (const note of scale.notes) {
            if (!baseTones.includes(note.semitone)) {
                sharpCount++;
            }
        }
        return sharpCount;
    }
    else {
        // Add flats to the scale
        for (const note of scale.notes) {
            if (!baseTones.includes(note.semitone)) {
                sharpCount--;
            }
        }
        return sharpCount;
    }
};
function toXml(divisionedNotes, mainParams) {
    const root = xmlbuilder__WEBPACK_IMPORTED_MODULE_1___default().create({ 'score-partwise': { '@version': 3.1 } }, { version: '1.0', encoding: 'UTF-8', standalone: false }, {
        pubID: '-//Recordare//DTD MusicXML 3.1 Partwise//EN',
        sysID: 'http://www.musicxml.org/dtds/partwise.dtd'
    });
    root.ele({ 'work': { 'work-title': "My song" } });
    const firstParams = mainParams.currentCadenceParams(0);
    const partList = root.ele({ 'part-list': {} });
    partList.ele({
        'score-part': {
            '@id': 'P1',
            'group': {
                '#text': 'score'
            },
            'part-name': {
                '#text': 'P1'
            },
            'score-instrument': {
                '@id': 'P1-I1',
                'instrument-name': {
                    '#text': `${firstParams.parts[0].voice}`
                },
            },
            'midi-instrument': {
                '@id': 'P1-I1',
                'midi-channel': 1,
                'midi-program': firstParams.parts[0].voice,
                'volume': 100,
                'pan': 0
            }
        }
    });
    partList.ele({
        'score-part': {
            '@id': 'P2',
            'group': {
                '#text': 'score'
            },
            'part-name': {
                '#text': 'P2'
            },
            'score-instrument': {
                '@id': 'P2-I1',
                'instrument-name': {
                    '#text': `${firstParams.parts[3].voice}`
                },
            },
            'midi-instrument': {
                '@id': 'P2-I1',
                'midi-channel': 1,
                'midi-program': firstParams.parts[3].voice,
                'volume': 100,
                'pan': 0
            }
        }
    });
    const parts = [
        root.ele({ 'part': { '@id': 'P1' } }),
        root.ele({ 'part': { '@id': 'P2' } }),
    ];
    const measures = [
        [],
        [],
    ];
    // (0 + 1) + ((0 + 1) * 2) = 1 + 2 = 3
    // 0 + 0 = 0
    // 0 + 1 = 1
    // 1 + 0 = 2
    // 1 + 1 = 3
    const maxDivision = Math.max(...Object.keys(divisionedNotes).map((k) => parseInt(k)));
    let division = 0;
    let currentScale = new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Scale({ key: 0 });
    while (division <= maxDivision) {
        const params = mainParams.currentCadenceParams(division);
        let measureIndex = Math.floor(division / (params.beatsPerBar * BEAT_LENGTH));
        for (let partIndex = 0; partIndex < 4; partIndex++) {
            let staff = partIndex <= 1 ? 0 : 1;
            const part = parts[staff];
            const voicePartIndex = partIndex;
            if (division == 0 && partIndex % 2 == 0) {
                measures[staff].push(part.ele({ 'measure': { '@number': 1 } }));
                firstMeasureInit(voicePartIndex, measures[staff][measures[staff].length - 1], firstParams);
            }
            else if (partIndex % 2 == 0) {
                measures[staff].push(part.ele({ 'measure': { '@number': `${(measureIndex) + 1}` } }));
            }
            let currentMeasure = measures[staff][measureIndex];
            // Move second voice backwards by a full measure
            if (partIndex % 2 != 0) {
                measures[staff][measures[staff].length - 1].ele({
                    'backup': {
                        'duration': {
                            "#text": `${params.beatsPerBar * BEAT_LENGTH}`,
                        }
                    }
                });
            }
            // Get all richNotes for this part for this measure
            for (let tmpDivision = 0; tmpDivision < params.beatsPerBar * BEAT_LENGTH; tmpDivision++) {
                const measureDivision = division + tmpDivision;
                const richNotes = (divisionedNotes[measureDivision] || []).filter((rn) => rn.partIndex == partIndex);
                if (!richNotes || richNotes.length == 0) {
                    continue;
                }
                const richNote = richNotes[0];
                // let keyChange: KeyChange | undefined = undefined
                // if (division % (params.beatsPerBar * BEAT_LENGTH) == 0 && richNote.scale.key != currentScale.key) {
                //   const prevSharpCount = getScaleSharpCount(currentScale);
                //   const newSharpCount = getScaleSharpCount(richNote.scale);
                //   let fifths = 0;
                //   let cancel = 0;
                //   if (prevSharpCount >= 0 && newSharpCount > prevSharpCount) {
                //     // There were sharps, and now there are more sharps
                //     fifths = newSharpCount - prevSharpCount;
                //   } else if (prevSharpCount <= 0 && newSharpCount < prevSharpCount) {
                //     // There were flats, and now there are more flats
                //     fifths = newSharpCount - prevSharpCount;
                //   } else if (prevSharpCount >= 0 && newSharpCount < prevSharpCount) {
                //     // There were sharps, and now there are fewer sharps (maybe even flats)
                //     for (let i=prevSharpCount; i>newSharpCount; i--) {
                //       if (i > 0) {
                //         // Turn these fifths into cancels
                //         cancel++;
                //         fifths--;
                //       }
                //       if (i < 0) {
                //         fifths--;
                //       }
                //     }
                //     //TODO
                //   } else if (prevSharpCount <= 0 && newSharpCount > prevSharpCount) {
                //     // There were flats, and now there are fewer flats (maybe even sharps)
                //     //TODO
                //     for (let i=prevSharpCount; i>newSharpCount; i++) {
                //       if (i < 0) {
                //         // Turn these flats into cancels
                //         cancel++;
                //         fifths--;
                //       }
                //       if (i < 0) {
                //         fifths++;
                //       }
                //     }
                //   }
                //   console.log(`prevSharpCount: ${prevSharpCount}, newSharpCount: ${newSharpCount}, fifths: ${fifths}, cancel: ${cancel}`);
                //   keyChange = {
                //     fifths: fifths,
                //     cancel: cancel,
                //   } as KeyChange
                // }
                addRichNoteToMeasure(richNote, currentMeasure, staff, partIndex % 2, true, measureDivision % BEAT_LENGTH == 0, undefined, //keyChange,
                params);
            }
        }
        division += params.beatsPerBar * BEAT_LENGTH;
    }
    const ret = root.end({ pretty: true });
    console.log(ret);
    return ret;
}


/***/ }),

/***/ "./src/mylogger.ts":
/*!*************************!*\
  !*** ./src/mylogger.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Logger": () => (/* binding */ Logger)
/* harmony export */ });
const printChildMessages = (childLogger) => {
    for (const child of childLogger.children) {
        console.groupCollapsed(...child.title);
        printChildMessages(child);
        for (const message of child.messages) {
            console.log(...message);
        }
        console.groupEnd();
    }
};
class Logger {
    constructor(parent = undefined) {
        this.title = [];
        this.messages = [];
        this.parent = undefined;
        this.children = [];
        this.cleared = false;
        this.parent = parent;
        if (parent) {
            parent.children.push(this);
        }
    }
    log(...args) {
        this.messages.push(args);
    }
    print(...args) {
        if (this.cleared) {
            return;
        }
        if (this.parent) {
            // Let parent handle me
            if (args.length > 0) {
                this.title = args;
            }
            return;
        }
        console.groupCollapsed(...args);
        // This is the top logger. Print everything.
        printChildMessages(this);
        for (let i = 0; i < this.messages.length; i++) {
            console.log(...this.messages[i]);
        }
        console.groupEnd();
    }
    clear() {
        this.messages = [];
        this.children = [];
        if (this.parent) {
            this.parent.children = this.parent.children.filter(child => child !== this);
        }
        this.cleared = true;
    }
}


/***/ }),

/***/ "./src/randomchords.ts":
/*!*****************************!*\
  !*** ./src/randomchords.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RandomChordGenerator": () => (/* binding */ RandomChordGenerator)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/utils.ts");

class RandomChordGenerator {
    constructor(params, scale) {
        const chordTypes = [];
        for (const chordType in params.chordSettings) {
            if (params.chordSettings[chordType].enabled) {
                chordTypes.push(chordType);
            }
        }
        this.chordTypes = chordTypes;
        this.usedChords = new Set();
        this.currentScale = scale;
        this.buildAvailableChords();
    }
    ;
    buildAvailableChords() {
        if (!this.usedChords) {
            this.usedChords = new Set();
        }
        this.availableChords = (this.availableChords || []).filter(chord => !this.usedChords.has(chord));
        // First try to add the simplest chords
        for (const simpleChordType of this.chordTypes.filter(chordType => ["maj", "min"].includes(chordType))) {
            for (let randomRoot = 0; randomRoot < 12; randomRoot++) {
                if (!this.usedChords.has(randomRoot + simpleChordType)) {
                    this.availableChords.push(randomRoot + simpleChordType);
                }
            }
        }
        if (this.availableChords.length > 0) {
            return;
        }
        for (let i = 0; i < 100; i++) {
            const randomType = this.chordTypes[Math.floor(Math.random() * this.chordTypes.length)];
            const randomRoot = Math.floor(Math.random() * 12);
            if (!this.usedChords.has(randomRoot + randomType)) {
                this.availableChords.push(randomRoot + randomType);
            }
        }
    }
    ;
    cleanUp() {
        if (this.usedChords) {
            this.usedChords.clear();
        }
        this.availableChords = [];
        delete this.usedChords;
        delete this.availableChords;
    }
    getChord() {
        if (!this.availableChords || this.availableChords.length === 0) {
            this.buildAvailableChords();
        }
        let iterations = 0;
        while (true) {
            if (iterations++ > 100) {
                return null;
            }
            while (this.availableChords.length - 3 > 0) {
                const chordType = this.availableChords[Math.floor(Math.random() * this.availableChords.length)];
                if (!this.usedChords.has(chordType)) {
                    this.usedChords.add(chordType);
                    this.availableChords = this.availableChords.filter(chord => chord !== chordType);
                    return new _utils__WEBPACK_IMPORTED_MODULE_0__.Chord(chordType);
                }
            }
            this.buildAvailableChords();
        }
    }
}


/***/ }),

/***/ "./src/tension.ts":
/*!************************!*\
  !*** ./src/tension.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getTension": () => (/* binding */ getTension)
/* harmony export */ });
/* harmony import */ var musictheoryjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! musictheoryjs */ "./node_modules/musictheoryjs/dist/musictheory.js");
/* harmony import */ var musictheoryjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(musictheoryjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/utils.ts");


const getTension = (divisionedNotes, toNotes, currentScale, beatsUntilLastChordInCadence, params, logger, beatsUntilLastChordInSong, inversionName, prevInversionName) => {
    /*
    *   Get the tension between two chords
    *   @param fromChord: Chord
    *   @param toChord: Chord
    *   @return: tension value between -1 and 1
    */
    let wantedFunction = null;
    if (beatsUntilLastChordInCadence == 4) {
        wantedFunction = "sub-dominant";
    }
    if (beatsUntilLastChordInCadence == 3) {
        wantedFunction = "dominant";
    }
    if (beatsUntilLastChordInCadence < 3) {
        wantedFunction = "tonic";
        if (!inversionName.startsWith('root')) {
            return { tension: 100, wantedFunction };
        }
    }
    const latestDivision = Math.max(...Object.keys(divisionedNotes).map((x) => parseInt(x, 10)));
    let tmp = [null, null, null, null];
    for (const richNote of (divisionedNotes[latestDivision] || [])) {
        tmp[richNote.partIndex] = richNote.note;
    }
    const passedFromNotes = [...tmp].filter(Boolean);
    tmp = [null, null, null, null];
    for (const richNote of (divisionedNotes[latestDivision - _utils__WEBPACK_IMPORTED_MODULE_1__.BEAT_LENGTH] || [])) {
        tmp[richNote.partIndex] = richNote.note;
    }
    const prevPassedFromNotes = [...tmp].filter(Boolean);
    let fromNotes;
    if (passedFromNotes.length < 4) {
        fromNotes = toNotes;
    }
    else {
        fromNotes = passedFromNotes;
    }
    const toChordString = toNotes.map(n => n.toString()).join(', ');
    const fromChordString = fromNotes.map(n => n.toString()).join(', ');
    const noteCount = Math.max(fromNotes.length, toNotes.length);
    // Compare the notes. Each differing note increases the tension a bit
    let tension = 0;
    const fromSemitones = fromNotes.map(note => note.semitone);
    const toSemitones = toNotes.map(note => note.semitone);
    const fromGlobalSemitones = fromNotes.map(note => (0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(note));
    const toGlobalSemitones = toNotes.map(note => (0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(note));
    const differingNotes = toSemitones.filter(semitone => !fromSemitones.includes(semitone));
    const sameNotes = toSemitones.filter(semitone => fromSemitones.includes(semitone));
    logger.log("fromGlobalSemitones: ", fromGlobalSemitones.map(s => (0,_utils__WEBPACK_IMPORTED_MODULE_1__.gToneString)(s)));
    logger.log("toGlobalSemitones: ", toGlobalSemitones.map(s => (0,_utils__WEBPACK_IMPORTED_MODULE_1__.gToneString)(s)));
    // tension += sameNotes.length * (1 / noteCount) * -0.5;
    logger.log("tension: ", tension);
    // If the notes are not in the current scale, increase the tension
    let notesNotInScale = [];
    let newScale = null;
    if (currentScale) {
        const scaleSemitones = currentScale.notes.map(note => note.semitone);
        notesNotInScale = toSemitones.filter(semitone => !scaleSemitones.includes(semitone));
        if (notesNotInScale.length > 0) {
            // Quick return, this chord sucks
            return { tension, newScale };
        }
    }
    logger.log("tension: ", tension);
    for (let i = 0; i < toGlobalSemitones.length; i++) {
        for (let j = i; j < toGlobalSemitones.length; j++) {
            const interval = Math.abs(toGlobalSemitones[i] - toGlobalSemitones[j]);
            if (interval === 1) {
                tension += 2;
                logger.log("interval 1 causing tension");
            }
            if (interval === 2) {
                tension += 0.5;
                logger.log("interval 2 causing tension");
            }
            if (interval === 6) {
                tension += 1.5;
                logger.log("interval 6 causing tension");
            }
        }
    }
    logger.log("tension: ", tension);
    if (passedFromNotes.length == 0) {
        return { tension, newScale };
    }
    if (inversionName.startsWith('second') || prevInversionName.startsWith('second')) {
        for (let i = 0; i < fromGlobalSemitones.length; i++) {
            const fromSemitone = fromGlobalSemitones[i];
            const toSemitone = toGlobalSemitones[i];
            if (Math.abs(fromSemitone - toSemitone) > 2) {
                logger.log("Can't have a jump in second inversion");
                tension += 100;
                logger.log("tension: ", tension);
            }
        }
    }
    const semitoneScaleIndex = {
        [currentScale.notes[0].semitone]: 0,
        [currentScale.notes[1].semitone]: 1,
        [currentScale.notes[2].semitone]: 2,
        [currentScale.notes[3].semitone]: 3,
        [currentScale.notes[4].semitone]: 4,
        [currentScale.notes[5].semitone]: 5,
        [currentScale.notes[6].semitone]: 6,
    };
    // Major / Minor
    // C 0: Tonic
    // D 1: SubDominant
    // E 2: Tonic
    // F 3: SubDominant
    // G 4: Dominant
    // A 5: Tonic
    // B 6: Dominant
    // I notes:
    // 0, 2, 4
    // ii notes:
    // 1, 3, 5
    // iii notes:
    // 2, 4, 6
    // IV notes:
    // 3, 5, 0
    // V notes:
    // 4, 6, 1
    // vi notes:
    // 5, 0, 2
    // viio notes:
    // 6, 1, 3
    // -> Tonic notes =       0,    2,    4
    // -> SubDominant notes = 0, 1,    3,    5
    // -> Dominant notes =       1,    3, 4,   6
    // Use relative diffs here for easy comparison
    let chordLeads = {
        0: {
            [-1]: 0,
            0: 1,
            1: 0,
        },
        1: {
            [-1]: 1,
            0: -0.5,
            1: 0.5,
        },
        2: {
            [-1]: 0,
            0: 1,
            1: 0,
        },
        3: {
            [-1]: 1,
            0: -0.5,
            1: 0.5,
        },
        4: {
            [-1]: 0,
            0: 1,
            1: 0,
        },
        5: {
            [-1]: 1,
            0: -0.5,
            1: 0,
        },
        6: {
            [-1]: 0,
            0: -1,
            1: 2,
        },
    };
    let tensionBeforelead = tension;
    const resolvedLeads = {};
    let availableLeads = {};
    for (const fromGlobalSemitone of fromGlobalSemitones) {
        // Each note may be "leading" somewhere.
        const fromSemitone = (fromGlobalSemitone + 12) % 12;
        const scaleIndex = semitoneScaleIndex[fromSemitone];
        if (scaleIndex == undefined) {
            // Out of scale. This note leads to 1 semitone up or down
            resolvedLeads[fromGlobalSemitone + 1] = 1;
            resolvedLeads[fromGlobalSemitone - 1] = 1;
            continue;
        }
        const leadsTo = chordLeads[scaleIndex];
        availableLeads[scaleIndex] = chordLeads[scaleIndex];
        for (const relativeDiff in leadsTo) {
            const relativeDiffNum = parseInt(relativeDiff);
            const nextScaleIndex = (scaleIndex + relativeDiffNum + 7) % 7;
            let semitoneDiff = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.semitoneDistance)(currentScale.notes[nextScaleIndex].semitone, fromSemitone);
            if (relativeDiffNum < 0) {
                semitoneDiff = -semitoneDiff;
            }
            const nextGTone = fromGlobalSemitone + semitoneDiff;
            resolvedLeads[nextGTone] = resolvedLeads[nextGTone] || 0;
            resolvedLeads[nextGTone] += leadsTo[relativeDiff];
            // // Add leads to all octaves
            // for (let i=-12*5; i<12*5; i+=12) {
            //     resolvedLeads[nextGTone+i] = resolvedLeads[nextGTone+i] || 0
            //     resolvedLeads[nextGTone+i] += leadsTo[relativeDiff];
            // }
        }
    }
    logger.log("availableLeads: ", availableLeads, "chords: ", fromSemitones.map(s => semitoneScaleIndex[s]), " - ", toSemitones.map(s => semitoneScaleIndex[s]), " - resolvedLeads: ", resolvedLeads);
    const handledSemitones = [];
    for (const toGlobalSemitone of toGlobalSemitones) {
        const toSemitone = (toGlobalSemitone + 12) % 12;
        if (handledSemitones.includes(toSemitone)) {
            continue;
        }
        handledSemitones.push(toSemitone);
        const scaleIndex = semitoneScaleIndex[toSemitone];
        if (wantedFunction) {
            let wantedScaleIndexes;
            if (wantedFunction == "sub-dominant") {
                // Modify weights so that all lead to subdominants (0, 1, 3, 5)
                wantedScaleIndexes = [0, 1, 3, 5];
            }
            if (wantedFunction == "dominant") {
                // Modify weights so that all lead to dominants (1, 3, 4, 6)
                wantedScaleIndexes = [1, 3, 4, 6];
            }
            if (wantedFunction == "tonic") {
                // Modify weights so that all lead to tonic (0, 2, 4)
                wantedScaleIndexes = [0, 2, 4];
            }
            if (wantedScaleIndexes.indexOf(parseInt(scaleIndex)) === -1) {
                tension += 2;
                logger.log("Tension from wanted function: ", scaleIndex, " : ", wantedFunction);
                if (beatsUntilLastChordInSong < 3) {
                    tension += 5;
                }
                continue;
            }
            else {
                tension -= 1;
                logger.log("Reduced tension from wanted function: ", scaleIndex, " : ", wantedFunction);
            }
        }
        const leadsTo = availableLeads[scaleIndex];
        if (leadsTo && leadsTo[0]) {
            // This note is leading to itself, with some tension.
            tension -= leadsTo[0];
            logger.log("Tension from lead to itself: ", scaleIndex, -leadsTo[0], " : ", wantedFunction);
            continue;
        }
        if (resolvedLeads[toGlobalSemitone] !== undefined) {
            tension -= resolvedLeads[toGlobalSemitone] * params.leadingWeight;
            logger.log("Tension from lead: ", toGlobalSemitone, -resolvedLeads[toGlobalSemitone], " : ", wantedFunction);
            continue;
        }
    }
    logger.log("tension: ", tension);
    const leadingToneSemitone = currentScale.notes[0].semitone + 11;
    for (let i = 0; i < fromGlobalSemitones.length; i++) {
        const fromGlobalSemitone = fromGlobalSemitones[i];
        if (fromGlobalSemitone % 12 == leadingToneSemitone) {
            if (toGlobalSemitones[i] != fromGlobalSemitone + 1) {
                tension += 10;
                if (i == 1 || i == 2) {
                    // not as bad
                    tension -= 7;
                }
                logger.log("Leading tone not handled, increasing tension: part ", i);
            }
        }
    }
    logger.log("tension: ", tension);
    let leadingToneCount = 0;
    for (const toGlobalSemitone of toGlobalSemitones) {
        const scaleIndex = semitoneScaleIndex[(toGlobalSemitone + 12) % 12];
        if (scaleIndex == 6) {
            leadingToneCount++;
        }
    }
    if (leadingToneCount > 1) {
        logger.log("Multiple leading tones, increasing tension: ", leadingToneCount);
        tension += 10;
    }
    if (tension > 10) {
        return { tension, currentScale };
    }
    const directionTensionWeight = wantedFunction == null ? 1 : 0.1;
    // Check directions
    const directionCounts = {
        "up": 0,
        "down": 0,
        "same": 0,
    };
    let rootBassDirection = null;
    for (let i = 0; i < fromGlobalSemitones.length; i++) {
        const fromSemitone = fromGlobalSemitones[i];
        const toSemitone = toGlobalSemitones[i];
        const diff = toSemitone - fromSemitone;
        if (diff > 0) {
            directionCounts.up += 1;
        }
        if (diff < 0) {
            directionCounts.down += 1;
        }
        if (diff == 0) {
            directionCounts.same += 1;
        }
        if (diff != 0 && inversionName.startsWith('root')) {
            rootBassDirection = diff > 0 ? 'up' : 'down';
        }
    }
    // Root bass makes up for one up/down
    if (rootBassDirection == "up" && directionCounts.down > 0) {
        directionCounts.down -= 1;
    }
    if (rootBassDirection == "down" && directionCounts.up > 0) {
        directionCounts.up -= 1;
    }
    logger.log("rootBassDirection: ", rootBassDirection, " - directionCounts: ", directionCounts);
    if (directionCounts.up > 2 && directionCounts.down < 1) {
        tension += 10 * directionTensionWeight;
        logger.log("Tension from direction up: ", directionCounts);
        logger.log("tension: ", tension);
    }
    if (directionCounts.down > 2 && directionCounts.up < 1) {
        tension += 10 * directionTensionWeight;
        logger.log("Tension from direction down: ", directionCounts);
        logger.log("tension: ", tension);
    }
    if (tension > 10) {
        return { tension, currentScale };
    }
    // Parallel motion and hidden fifths
    for (let i = 0; i < toGlobalSemitones.length; i++) {
        for (let j = i + 1; j < toGlobalSemitones.length; j++) {
            if (fromGlobalSemitones[i] == toGlobalSemitones[i] && fromGlobalSemitones[j] == toGlobalSemitones[j]) {
                continue;
            }
            const interval = Math.abs(toGlobalSemitones[i] - toGlobalSemitones[j]);
            const intervalFrom = Math.abs(fromGlobalSemitones[i] - fromGlobalSemitones[j]);
            if (interval < 20 && interval % 12 == 7 || interval % 12 == 0) {
                // Possibly a parallel, contrary or hidden fifth/octave
                if (interval == intervalFrom) {
                    tension += 10;
                    logger.log("Tension from parallel motion: ", interval, " part ", i, " and ", j);
                    logger.log("tension: ", tension);
                    continue;
                }
                // Check if the interval is hidden
                const partIDirection = fromGlobalSemitones[i] - toGlobalSemitones[i];
                const partJDirection = fromGlobalSemitones[j] - toGlobalSemitones[j];
                if (Math.abs(partJDirection) > 2) {
                    // Upper part is making a jump
                    if (partIDirection < 0 && partJDirection < 0 || partIDirection > 0 && partJDirection > 0) {
                        tension += 10;
                        logger.log("Tension from hidden fifth: ", interval, " part ", i, " and ", j);
                        logger.log("tension: ", tension);
                        continue;
                    }
                }
            }
        }
    }
    if (tension > 10) {
        return { tension, currentScale };
    }
    // Spacing errors
    const part0ToPart1 = Math.abs(toGlobalSemitones[0] - toGlobalSemitones[1]);
    const part1ToPart2 = Math.abs(toGlobalSemitones[1] - toGlobalSemitones[2]);
    const part2ToPart3 = Math.abs(toGlobalSemitones[2] - toGlobalSemitones[3]);
    if (part1ToPart2 > 12 || part0ToPart1 > 12 || part2ToPart3 > (12 + 7)) {
        tension += 10;
        logger.log("Tension from spacing error: ", part0ToPart1, part1ToPart2, part2ToPart3);
        logger.log("tension: ", tension);
    }
    if (tension > 10) {
        return { tension, currentScale };
    }
    // Overlapping error
    for (let i = 0; i < fromGlobalSemitones.length; i++) {
        const fromGlobalSemitone = fromGlobalSemitones[i];
        const upperPartToGlobalSemitone = toGlobalSemitones[i - 1];
        const lowerPartToGlobalSemitone = toGlobalSemitones[i + 1];
        if (upperPartToGlobalSemitone != undefined && fromGlobalSemitone > upperPartToGlobalSemitone) {
            // Upper part is moving lower than where lower part used to be
            tension += 10;
            logger.log("Tension from overlapping error: ", (0,_utils__WEBPACK_IMPORTED_MODULE_1__.gToneString)(fromGlobalSemitone), (0,_utils__WEBPACK_IMPORTED_MODULE_1__.gToneString)(upperPartToGlobalSemitone));
            logger.log("tension: ", tension);
        }
        if (lowerPartToGlobalSemitone != undefined && fromGlobalSemitone < lowerPartToGlobalSemitone) {
            // Lower part is moving higher than where upper part used to be
            tension += 10;
            logger.log("Tension from overlapping error: ", (0,_utils__WEBPACK_IMPORTED_MODULE_1__.gToneString)(fromGlobalSemitone), (0,_utils__WEBPACK_IMPORTED_MODULE_1__.gToneString)(lowerPartToGlobalSemitone));
            logger.log("tension: ", tension);
        }
    }
    // Melody tension
    // Avoid jumps that are aug or 7th or higher
    for (let i = 0; i < fromGlobalSemitones.length; i++) {
        const interval = Math.abs(fromGlobalSemitones[i] - toGlobalSemitones[i]);
        if (interval >= 3) {
            tension += 0.2;
            logger.log("Tension from melody jump: ", interval);
            logger.log("tension: ", tension);
        }
        if (interval >= 10) { // 7th == 10
            tension += 10;
            logger.log("Tension from melody interval: ", interval);
            logger.log("tension: ", tension);
            continue;
        }
        if (interval == 6 || interval == 8) // tritone (aug 4th) or aug 5th
         {
            tension += 5;
            logger.log("Tension from melody interval: ", interval);
            logger.log("tension: ", tension);
            continue;
        }
        if (interval == 7) {
            tension += 1;
            logger.log("Tension from melody interval: ", interval);
            logger.log("tension: ", tension);
            continue;
        }
        if (interval == 9) {
            tension += 2;
            logger.log("Tension from melody interval: ", interval);
            logger.log("tension: ", tension);
            continue;
        }
    }
    if (tension > 10) {
        return { tension, currentScale };
    }
    // 0 priimi
    // 1 pieni sekunti
    // 2 suuri sekunti
    // 3 pieni terssi
    // 4 suuri terssi
    // 5 kvartti
    // 6 tritonus
    // 7 kvintti
    // 8 pieni seksti
    // 9 suuri seksti
    // 10 pieni septimi
    // 11 suuri septimi
    // 12 oktaavi
    // Was there a jump before?
    if (prevPassedFromNotes && prevPassedFromNotes.length == 4) {
        const prevFromGlobalSemitones = prevPassedFromNotes.map((n) => (0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(n));
        logger.log("prevFromGlobalSemitones:", prevFromGlobalSemitones.map((s) => (0,_utils__WEBPACK_IMPORTED_MODULE_1__.gToneString)(s)));
        for (let i = 0; i < fromGlobalSemitones.length; i++) {
            const interval = Math.abs(prevFromGlobalSemitones[i] - fromGlobalSemitones[i]);
            if (interval >= 3) {
                // There was a jump. WE MUST GO BACK!
                // Basically the toGlobalSemitone must be between the prevFromGlobalSemitone and the fromGlobalSemitone
                // UNLESS we're outlining a triad.
                // This would mean that after a 4th up, we need to go up another 3rd
                const prevFromSemitone = prevFromGlobalSemitones[i];
                const fromSemitone = fromGlobalSemitones[i];
                const toSemitone = toGlobalSemitones[i];
                const directionMultiplier = fromSemitone > prevFromSemitone ? 1 : -1;
                const nextInterval = directionMultiplier * (toSemitone - fromSemitone);
                if (interval == 3) {
                    if (nextInterval == 4) {
                        // minor 3rd up, then maj third up. That's a root inversion minor chord!
                        continue;
                    }
                    if (nextInterval == 5) {
                        // minor 3rd up, then perfect 4th up. That's a first inversion major chord!
                        continue;
                    }
                }
                if (interval == 4) {
                    if (nextInterval == 3) {
                        // major 3rd up, then minor 3rd up. That's a root inversion major chord!
                        continue;
                    }
                    if (nextInterval == 5) {
                        // major 3rd up, then perfect 4th up. That's a first inversion minor chord!
                        continue;
                    }
                }
                if (interval == 5) {
                    if (nextInterval == 3) {
                        // perfect 4th up, then minor 3rd up. That's a second inversion minor chord!
                        continue;
                    }
                    if (nextInterval == 4) {
                        // perfect 4th up, then major 3rd up. That's a second inversion major chord!
                        continue;
                    }
                }
                // Higher than that, no triad is possible.
                if ((fromSemitone >= prevFromSemitone && toSemitone >= fromSemitone) || (fromSemitone <= prevFromSemitone && toSemitone <= fromSemitone)) {
                    // Not goinf back down/up...
                    if (interval <= 3) {
                        tension += 0.2;
                    }
                    else if (interval <= 4) {
                        tension += 1; // Not as bad
                    }
                    else {
                        tension += 10; // Terrible
                    }
                    logger.log("Tension from jump and no back: ", interval, " part ", i);
                    logger.log("tension: ", tension);
                }
                else {
                    // Going back down/up...
                    const backInterval = Math.abs(toSemitone - fromSemitone);
                    if (backInterval > 2) {
                        // Going back too far...
                        if (interval <= 3) {
                            tension += 0.2;
                        }
                        else if (interval <= 4) {
                            tension += 1; // Not as bad
                        }
                        else {
                            tension += 10; // Terrible
                        }
                        logger.log("Tension from jump and too far back: ", interval, " part ", i);
                        logger.log("tension: ", tension);
                    }
                }
            }
        }
    }
    if (tension > 10) {
        return { tension, currentScale };
    }
    for (let i = 0; i < toGlobalSemitones.length; i++) {
        const fromGlobalSemitone = fromGlobalSemitones[i];
        const toGlobalSemitone = toGlobalSemitones[i];
        let direction = toGlobalSemitone - fromGlobalSemitone;
        const baseNote = params.parts[i].note || "F4";
        const startingGlobalSemitone = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note(baseNote));
        const semitoneLimit = [startingGlobalSemitone + -12, startingGlobalSemitone + 12];
        let targetNote = semitoneLimit[1] - 4;
        targetNote -= i * 2;
        let targetNoteReached = false;
        for (const division in divisionedNotes) {
            const notes = divisionedNotes[division];
            for (const prevNote of notes.filter(richNote => richNote.partIndex == i)) {
                if ((0,_utils__WEBPACK_IMPORTED_MODULE_1__.globalSemitone)(prevNote.note) == targetNote) {
                    targetNoteReached = true;
                }
            }
        }
        if (targetNoteReached) {
            if (Math.abs(toGlobalSemitone - targetNote) < 2) {
                // We're close to the target note, let's NOT go there any more
                if (direction > 0) {
                    tension += 10;
                    logger.log("Tension from already reaching target note: ", direction, " part ", i);
                    logger.log("tension: ", tension);
                }
            }
        }
        break;
    }
    logger.log("tension: ", tension);
    if (tension > 100) {
        // Don't even log this crappy inversion
        logger.clear();
    }
    return { tension, newScale };
};


/***/ }),

/***/ "./src/topmelody.ts":
/*!**************************!*\
  !*** ./src/topmelody.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buildTopMelody": () => (/* binding */ buildTopMelody)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/utils.ts");

const addNoteBetween = (division, nextDivision, partIndex, divisionedNotes) => {
    const divisionDiff = nextDivision - division;
    const beatRichNote = (divisionedNotes[division] || []).filter(note => note.partIndex == partIndex)[0];
    if (!beatRichNote || !beatRichNote.note) {
        return;
    }
    const prevScaleTones = beatRichNote.scale.notes.map(n => n.semitone);
    const nextBeatRichNote = (divisionedNotes[nextDivision] || []).filter(note => note.partIndex == partIndex)[0];
    if (!nextBeatRichNote || !nextBeatRichNote.note) {
        return;
    }
    const scaleTones = nextBeatRichNote.scale.notes.map(n => n.semitone).filter(n => prevScaleTones.includes(n));
    const currentGTone = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.globalSemitone)(beatRichNote.note);
    const nextGTone = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.globalSemitone)(nextBeatRichNote.note);
    const randomNote = beatRichNote.note.copy();
    const diff = Math.abs(currentGTone - nextGTone);
    if (diff < 2) {
        return false;
    }
    if (currentGTone != nextGTone) {
        const availableGTones = [];
        for (let gTone = currentGTone; gTone != nextGTone; gTone += (currentGTone < nextGTone ? 1 : -1)) {
            if (gTone == currentGTone) {
                continue;
            }
            const semitone = gTone % 12;
            if (!scaleTones.includes(semitone)) {
                continue;
            }
            availableGTones.push(gTone);
        }
        if (availableGTones.length == 0) {
            availableGTones.push(currentGTone);
        }
        console.log(currentGTone, " -> ", nextGTone, ", availableGTones: ", availableGTones, ", scaleTones: ", scaleTones);
        const randomGTone = availableGTones[Math.floor(Math.random() * availableGTones.length)];
        randomNote.semitone = randomGTone % 12;
        randomNote.octave = Math.floor(randomGTone / 12);
    }
    beatRichNote.duration = divisionDiff / 2;
    divisionedNotes[division + divisionDiff / 2] = divisionedNotes[division + divisionDiff / 2] || [];
    const newRandomRichNote = {
        note: randomNote,
        duration: divisionDiff / 2,
        chord: beatRichNote.chord,
        scale: beatRichNote.scale,
        partIndex: partIndex,
    };
    divisionedNotes[division + divisionDiff / 2].push(newRandomRichNote);
    return true;
};
const buildTopMelody = (divisionedNotes, mainParams) => {
    // Convert 4th notes in part 1 to 8th notes. Add random 8th and 16th notes between them. (and pauses?)
    const lastDivision = _utils__WEBPACK_IMPORTED_MODULE_0__.BEAT_LENGTH * mainParams.getMaxBeats();
    for (let i = 0; i < lastDivision - _utils__WEBPACK_IMPORTED_MODULE_0__.BEAT_LENGTH; i += _utils__WEBPACK_IMPORTED_MODULE_0__.BEAT_LENGTH) {
        const params = mainParams.currentCadenceParams(i);
        const eightsThisBeat = Math.random() < params.eighthNotes;
        const sixteenthsThisBeat = Math.random() < params.sixteenthNotes;
        if (!eightsThisBeat) {
            continue;
        }
        const lastBeatInCadence = params.beatsUntilCadenceEnd < 2;
        if (lastBeatInCadence) {
            continue;
        }
        for (let partIndex = 0; partIndex < 4; partIndex++) {
            // Is this a good part to add eighths?
            const result = addNoteBetween(i, i + _utils__WEBPACK_IMPORTED_MODULE_0__.BEAT_LENGTH, partIndex, divisionedNotes);
            if (!result) {
                continue;
            }
            if (Math.random() < params.sixteenthNotes) {
                addNoteBetween(i, i + _utils__WEBPACK_IMPORTED_MODULE_0__.BEAT_LENGTH / 2, partIndex, divisionedNotes);
            }
            if (Math.random() < params.sixteenthNotes) {
                addNoteBetween(i + _utils__WEBPACK_IMPORTED_MODULE_0__.BEAT_LENGTH / 2, i + _utils__WEBPACK_IMPORTED_MODULE_0__.BEAT_LENGTH, partIndex, divisionedNotes);
            }
            break;
        }
    }
};


/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BEAT_LENGTH": () => (/* binding */ BEAT_LENGTH),
/* harmony export */   "Chord": () => (/* binding */ Chord),
/* harmony export */   "MainMusicParams": () => (/* binding */ MainMusicParams),
/* harmony export */   "MusicParams": () => (/* binding */ MusicParams),
/* harmony export */   "arrayOrderBy": () => (/* binding */ arrayOrderBy),
/* harmony export */   "chordTemplates": () => (/* binding */ chordTemplates),
/* harmony export */   "gToneString": () => (/* binding */ gToneString),
/* harmony export */   "getClosestOctave": () => (/* binding */ getClosestOctave),
/* harmony export */   "globalSemitone": () => (/* binding */ globalSemitone),
/* harmony export */   "majScaleCircle": () => (/* binding */ majScaleCircle),
/* harmony export */   "majScaleDifference": () => (/* binding */ majScaleDifference),
/* harmony export */   "semitoneDistance": () => (/* binding */ semitoneDistance)
/* harmony export */ });
/* harmony import */ var musictheoryjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! musictheoryjs */ "./node_modules/musictheoryjs/dist/musictheory.js");
/* harmony import */ var musictheoryjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(musictheoryjs__WEBPACK_IMPORTED_MODULE_0__);

const BEAT_LENGTH = 12;
const gToneString = (gTone) => {
    return new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note({
        semitone: gTone % 12,
        octave: Math.floor(gTone / 12),
    }).toString();
};
const arrayOrderBy = function (array, selector, desc = false) {
    return [...array].sort((a, b) => {
        a = selector(a);
        b = selector(b);
        if (a == b)
            return 0;
        return (desc ? a > b : a < b) ? -1 : 1;
    });
};
const chordTemplates = {
    maj: [0, 4, 7],
    min: [0, 3, 7],
    dim: [0, 3, 6],
    aug: [0, 4, 8],
    maj7: [0, 4, 7, 11],
    min7: [0, 3, 7, 10],
    dom7: [0, 4, 7, 10],
    sus2: [0, 2, 7],
    sus4: [0, 5, 7],
};
class Chord {
    constructor(semitoneOrName, chordType = undefined) {
        let semitone;
        if (typeof semitoneOrName === "string") {
            semitone = semitoneOrName.match(/^\d+/);
            const parsedType = semitoneOrName.match(/^\d+(.*)/);
            if (semitone == null) {
                throw "Invalid chord name " + semitoneOrName;
            }
            if (parsedType == null) {
                throw "Invalid chord name " + semitoneOrName;
            }
            semitone = parseInt(semitone[0]);
            chordType = chordType || parsedType[1];
        }
        else {
            semitone = semitoneOrName;
        }
        this.chordType = chordType;
        const template = chordTemplates[chordType];
        if (template == undefined) {
            throw "Unknown chord type: " + chordType;
        }
        this.notes = [];
        for (let note of template) {
            this.notes.push(new musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Note({ semitone: (semitone + note) % 12, octave: 1 }));
        }
    }
    toString() {
        // Find correct Semitone key
        const semitoneKeys = Object.keys(musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone).filter(key => musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone[key] === this.notes[0].semitone);
        if (semitoneKeys.length == 0) {
            return this.notes.map(note => note.toString()).join(", ");
        }
        let semitoneKey = semitoneKeys.filter(key => key.indexOf('b') == -1 && key.indexOf('s') == -1)[0] || semitoneKeys[0];
        semitoneKey = semitoneKey.replace('s', '#');
        return semitoneKey + this.chordType;
    }
}
class MainMusicParams {
    constructor(params = undefined) {
        this.beatsPerBar = 4;
        this.cadenceCount = 2;
        this.cadences = [];
        this.testMode = false;
        if (params) {
            for (let key in params) {
                this[key] = params[key];
            }
        }
    }
    currentCadenceParams(division) {
        const beat = Math.floor(division / BEAT_LENGTH);
        const bar = Math.floor(beat / this.beatsPerBar);
        let counter = 0;
        for (const cadenceParams of this.cadences) {
            counter += cadenceParams.barsPerCadence;
            if (bar < counter) {
                cadenceParams.beatsUntilCadenceEnd = counter * this.beatsPerBar - beat;
                cadenceParams.beatsUntilSongEnd = this.cadences.reduce((a, b) => a + b.barsPerCadence, 0) * this.beatsPerBar - beat;
                cadenceParams.beatsPerBar = this.beatsPerBar;
                return cadenceParams;
            }
        }
    }
    getMaxBeats() {
        return this.cadences.reduce((a, b) => a + b.barsPerCadence, 0) * this.beatsPerBar;
    }
}
class MusicParams {
    constructor(params = undefined) {
        this.beatsUntilCadenceEnd = 0;
        this.beatsUntilSongEnd = 0;
        this.beatsPerBar = 4;
        this.baseTension = 0.3;
        this.barsPerCadence = 4;
        this.tempo = 40;
        this.halfNotes = true;
        this.sixteenthNotes = 0.2;
        this.eighthNotes = 0.4;
        this.modulationWeight = 0.5;
        this.leadingWeight = 2;
        this.parts = [
            {
                voice: "1",
                note: "C5",
            },
            {
                voice: "1",
                note: "A4",
            },
            {
                voice: "1",
                note: "C4",
            },
            {
                voice: "1",
                note: "E3",
            }
        ];
        this.beatSettings = [];
        this.chordSettings = {
            maj: {
                enabled: true,
                weight: 0,
            },
            min: {
                enabled: true,
                weight: 0,
            },
            dim: {
                enabled: false,
                weight: -1,
            },
            aug: {
                enabled: false,
                weight: -1,
            },
            maj7: {
                enabled: false,
                weight: -1,
            },
            dom7: {
                enabled: false,
                weight: -1,
            },
            sus2: {
                enabled: false,
                weight: -1,
            },
            sus4: {
                enabled: false,
                weight: -1,
            },
        };
        this.scaleSettings = {
            major: {
                enabled: true,
                weight: 0,
            },
            minor: {
                enabled: true,
                weight: 0,
            },
            harmonicMinor: {
                enabled: false,
                weight: -0.5,
            },
            melodicMinorAscending: {
                enabled: false,
                weight: -0.5,
            },
            melodicMinorDescending: {
                enabled: false,
                weight: -0.5,
            },
        };
        this.melodySettings = {
            "up": 0,
            "down": 0,
            "same": 0,
        };
        if (params) {
            for (let key in params) {
                this[key] = params[key];
            }
        }
        this.updateBeatSettings();
    }
    updateBeatSettings() {
        const beatCount = this.beatsPerBar * this.barsPerCadence;
        if (this.beatSettings.length < beatCount) {
            for (let i = this.beatSettings.length; i < beatCount; i++) {
                this.beatSettings.push({
                    tension: this.baseTension
                });
            }
        }
        else if (this.beatSettings.length > beatCount) {
            this.beatSettings = this.beatSettings.slice(0, beatCount);
        }
    }
}
const globalSemitone = (note) => {
    return note.semitone + ((note.octave) * 12);
};
const getClosestOctave = (note, targetNote = null, targetSemitone = null) => {
    // 
    let semitone = globalSemitone(note);
    targetSemitone = targetSemitone || globalSemitone(targetNote);
    console.log("Closest octave: ", semitone, targetSemitone);
    // Using modulo here -> -7 % 12 = -7
    // -13 % 12 = -1
    if (semitone == targetSemitone) {
        return note.octave;
    }
    const delta = targetSemitone > semitone ? 12 : -12;
    let ret = 0;
    let i = 0;
    const cleanOctave = (octave) => {
        return Math.min(Math.max(octave, 2), 6);
    };
    while (true) {
        i++;
        if (i > 1000) {
            throw new Error("Infinite loop");
        }
        semitone += delta;
        ret += delta / 12; // How many octaves we changed
        if (delta > 0) {
            if (semitone >= targetSemitone) {
                if (Math.abs(semitone - targetSemitone) > Math.abs(semitone - 12 - targetSemitone)) {
                    // We went too far, go one back
                    ret -= 1;
                }
                console.log("Closest octave res: ", cleanOctave(note.octave + ret), ret);
                return cleanOctave(note.octave + ret);
            }
        }
        else {
            if (semitone <= targetSemitone) {
                if (Math.abs(semitone - targetSemitone) > Math.abs(semitone + 12 - targetSemitone)) {
                    // We went too far, go one back
                    ret += 1;
                }
                console.log("Closest octave res: ", cleanOctave(note.octave + ret), ret);
                return cleanOctave(note.octave + ret);
            }
        }
    }
};
const majScaleCircle = {};
majScaleCircle[musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.C] = [musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.G, musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.F];
majScaleCircle[musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.G] = [musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.D, musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.C];
majScaleCircle[musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.D] = [musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.A, musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.G];
majScaleCircle[musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.A] = [musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.E, musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.D];
majScaleCircle[musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.E] = [musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.B, musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.A];
majScaleCircle[musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.B] = [musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Fs, musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.E];
majScaleCircle[musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.F] = [musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.C, musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Bb];
majScaleCircle[musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Bb] = [musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.F, musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Eb];
majScaleCircle[musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Eb] = [musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Bb, musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Ab];
majScaleCircle[musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Ab] = [musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Eb, musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Db];
majScaleCircle[musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Db] = [musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Ab, musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Gb];
majScaleCircle[musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Gb] = [musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Db, musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Cb];
majScaleCircle[musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Cb] = [musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Gb, musictheoryjs__WEBPACK_IMPORTED_MODULE_0__.Semitone.Fb];
const majScaleDifference = (semitone1, semitone2) => {
    // Given two major scales, return how closely related they are
    // 0 = same scale
    // 1 = E.G. C and F or C and G
    let currentVal = majScaleCircle[semitone1];
    if (semitone1 == semitone2) {
        return 0;
    }
    for (let i = 0; i < 12; i++) {
        if (currentVal.includes(semitone2)) {
            return i + 1;
        }
        const newCurrentVal = new Set();
        for (const semitone of currentVal) {
            for (const newSemitone of majScaleCircle[semitone]) {
                newCurrentVal.add(newSemitone);
            }
        }
        currentVal = [...newCurrentVal];
    }
    return 12;
};
const semitoneDistance = (tone1, tone2) => {
    // distance from 0 to 11 should be 1
    // 0 - 11 + 12 => 1
    // 11 - 0 + 12 => 23 => 11
    // 0 - 6 + 12 => 6
    // 6 - 0 + 12 => 18 => 6
    // 0 + 6 - 3 + 6 = 6 - 9 = -3
    // 6 + 6 - 9 + 6 = 12 - 15 = 0 - 3 = -3
    // 11 + 6 - 0 + 6 = 17 - 6 = 5 - 6 = -1
    // 0 + 6 - 11 + 6 = 6 - 17 = 6 - 5 = 1
    return Math.abs((tone1 + 6) % 12 - (tone2 + 6) % 12);
};


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/DocumentPosition.js":
/*!*********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/DocumentPosition.js ***!
  \*********************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 2.4.1
(function() {
  module.exports = {
    Disconnected: 1,
    Preceding: 2,
    Following: 4,
    Contains: 8,
    ContainedBy: 16,
    ImplementationSpecific: 32
  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/NodeType.js":
/*!*************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/NodeType.js ***!
  \*************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 2.4.1
(function() {
  module.exports = {
    Element: 1,
    Attribute: 2,
    Text: 3,
    CData: 4,
    EntityReference: 5,
    EntityDeclaration: 6,
    ProcessingInstruction: 7,
    Comment: 8,
    Document: 9,
    DocType: 10,
    DocumentFragment: 11,
    NotationDeclaration: 12,
    // Numeric codes up to 200 are reserved to W3C for possible future use.
    // Following are types internal to this library:
    Declaration: 201,
    Raw: 202,
    AttributeDeclaration: 203,
    ElementDeclaration: 204,
    Dummy: 205
  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/Utility.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/Utility.js ***!
  \************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 2.4.1
(function() {
  // Copies all enumerable own properties from `sources` to `target`
  var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject,
    hasProp = {}.hasOwnProperty;

  assign = function(target, ...sources) {
    var i, key, len, source;
    if (isFunction(Object.assign)) {
      Object.assign.apply(null, arguments);
    } else {
      for (i = 0, len = sources.length; i < len; i++) {
        source = sources[i];
        if (source != null) {
          for (key in source) {
            if (!hasProp.call(source, key)) continue;
            target[key] = source[key];
          }
        }
      }
    }
    return target;
  };

  // Determines if `val` is a Function object
  isFunction = function(val) {
    return !!val && Object.prototype.toString.call(val) === '[object Function]';
  };

  // Determines if `val` is an Object
  isObject = function(val) {
    var ref;
    return !!val && ((ref = typeof val) === 'function' || ref === 'object');
  };

  // Determines if `val` is an Array
  isArray = function(val) {
    if (isFunction(Array.isArray)) {
      return Array.isArray(val);
    } else {
      return Object.prototype.toString.call(val) === '[object Array]';
    }
  };

  // Determines if `val` is an empty Array or an Object with no own properties
  isEmpty = function(val) {
    var key;
    if (isArray(val)) {
      return !val.length;
    } else {
      for (key in val) {
        if (!hasProp.call(val, key)) continue;
        return false;
      }
      return true;
    }
  };

  // Determines if `val` is a plain Object
  isPlainObject = function(val) {
    var ctor, proto;
    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));
  };

  // Gets the primitive value of an object
  getValue = function(obj) {
    if (isFunction(obj.valueOf)) {
      return obj.valueOf();
    } else {
      return obj;
    }
  };

  module.exports.assign = assign;

  module.exports.isFunction = isFunction;

  module.exports.isObject = isObject;

  module.exports.isArray = isArray;

  module.exports.isEmpty = isEmpty;

  module.exports.isPlainObject = isPlainObject;

  module.exports.getValue = getValue;

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/WriterState.js":
/*!****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/WriterState.js ***!
  \****************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 2.4.1
(function() {
  module.exports = {
    None: 0,
    OpenTag: 1,
    InsideTag: 2,
    CloseTag: 3
  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLAttribute.js":
/*!*****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLAttribute.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLAttribute, XMLNode;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  // Represents an attribute
  module.exports = XMLAttribute = (function() {
    class XMLAttribute {
      // Initializes a new instance of `XMLAttribute`

      // `parent` the parent node
      // `name` attribute target
      // `value` attribute value
      constructor(parent, name, value) {
        this.parent = parent;
        if (this.parent) {
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }
        if (name == null) {
          throw new Error("Missing attribute name. " + this.debugInfo(name));
        }
        this.name = this.stringify.name(name);
        this.value = this.stringify.attValue(value);
        this.type = NodeType.Attribute;
        // DOM level 3
        this.isId = false;
        this.schemaTypeInfo = null;
      }

      // Creates and returns a deep clone of `this`
      clone() {
        return Object.create(this);
      }

      // Converts the XML fragment to string

      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      toString(options) {
        return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
      }

      
      // Returns debug string for this node
      debugInfo(name) {
        name = name || this.name;
        if (name == null) {
          return "parent: <" + this.parent.name + ">";
        } else {
          return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
        }
      }

      isEqualNode(node) {
        if (node.namespaceURI !== this.namespaceURI) {
          return false;
        }
        if (node.prefix !== this.prefix) {
          return false;
        }
        if (node.localName !== this.localName) {
          return false;
        }
        if (node.value !== this.value) {
          return false;
        }
        return true;
      }

    };

    // DOM level 1
    Object.defineProperty(XMLAttribute.prototype, 'nodeType', {
      get: function() {
        return this.type;
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'ownerElement', {
      get: function() {
        return this.parent;
      }
    });

    // DOM level 3
    Object.defineProperty(XMLAttribute.prototype, 'textContent', {
      get: function() {
        return this.value;
      },
      set: function(value) {
        return this.value = value || '';
      }
    });

    // DOM level 4
    Object.defineProperty(XMLAttribute.prototype, 'namespaceURI', {
      get: function() {
        return '';
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'prefix', {
      get: function() {
        return '';
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'localName', {
      get: function() {
        return this.name;
      }
    });

    Object.defineProperty(XMLAttribute.prototype, 'specified', {
      get: function() {
        return true;
      }
    });

    return XMLAttribute;

  }).call(this);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLCData.js":
/*!*************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLCData.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLCData, XMLCharacterData;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLCharacterData = __webpack_require__(/*! ./XMLCharacterData */ "./node_modules/xmlbuilder/lib/XMLCharacterData.js");

  // Represents a  CDATA node
  module.exports = XMLCData = class XMLCData extends XMLCharacterData {
    // Initializes a new instance of `XMLCData`

    // `text` CDATA text
    constructor(parent, text) {
      super(parent);
      if (text == null) {
        throw new Error("Missing CDATA text. " + this.debugInfo());
      }
      this.name = "#cdata-section";
      this.type = NodeType.CData;
      this.value = this.stringify.cdata(text);
    }

    // Creates and returns a deep clone of `this`
    clone() {
      return Object.create(this);
    }

    // Converts the XML fragment to string

    // `options.pretty` pretty prints the result
    // `options.indent` indentation for pretty print
    // `options.offset` how many indentations to add to every line for pretty print
    // `options.newline` newline sequence for pretty print
    toString(options) {
      return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
    }

  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLCharacterData.js":
/*!*********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLCharacterData.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var XMLCharacterData, XMLNode;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  // Represents a character data node
  module.exports = XMLCharacterData = (function() {
    class XMLCharacterData extends XMLNode {
      // Initializes a new instance of `XMLCharacterData`

      constructor(parent) {
        super(parent);
        this.value = '';
      }

      
      // Creates and returns a deep clone of `this`
      clone() {
        return Object.create(this);
      }

      // DOM level 1 functions to be implemented later
      substringData(offset, count) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      appendData(arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      insertData(offset, arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      deleteData(offset, count) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      replaceData(offset, count, arg) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      isEqualNode(node) {
        if (!super.isEqualNode(node)) {
          return false;
        }
        if (node.data !== this.data) {
          return false;
        }
        return true;
      }

    };

    // DOM level 1
    Object.defineProperty(XMLCharacterData.prototype, 'data', {
      get: function() {
        return this.value;
      },
      set: function(value) {
        return this.value = value || '';
      }
    });

    Object.defineProperty(XMLCharacterData.prototype, 'length', {
      get: function() {
        return this.value.length;
      }
    });

    // DOM level 3
    Object.defineProperty(XMLCharacterData.prototype, 'textContent', {
      get: function() {
        return this.value;
      },
      set: function(value) {
        return this.value = value || '';
      }
    });

    return XMLCharacterData;

  }).call(this);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLComment.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLComment.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLCharacterData, XMLComment;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLCharacterData = __webpack_require__(/*! ./XMLCharacterData */ "./node_modules/xmlbuilder/lib/XMLCharacterData.js");

  // Represents a comment node
  module.exports = XMLComment = class XMLComment extends XMLCharacterData {
    // Initializes a new instance of `XMLComment`

    // `text` comment text
    constructor(parent, text) {
      super(parent);
      if (text == null) {
        throw new Error("Missing comment text. " + this.debugInfo());
      }
      this.name = "#comment";
      this.type = NodeType.Comment;
      this.value = this.stringify.comment(text);
    }

    // Creates and returns a deep clone of `this`
    clone() {
      return Object.create(this);
    }

    // Converts the XML fragment to string

    // `options.pretty` pretty prints the result
    // `options.indent` indentation for pretty print
    // `options.offset` how many indentations to add to every line for pretty print
    // `options.newline` newline sequence for pretty print
    toString(options) {
      return this.options.writer.comment(this, this.options.writer.filterOptions(options));
    }

  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDOMConfiguration.js":
/*!************************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDOMConfiguration.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;

  XMLDOMErrorHandler = __webpack_require__(/*! ./XMLDOMErrorHandler */ "./node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js");

  XMLDOMStringList = __webpack_require__(/*! ./XMLDOMStringList */ "./node_modules/xmlbuilder/lib/XMLDOMStringList.js");

  // Implements the DOMConfiguration interface
  module.exports = XMLDOMConfiguration = (function() {
    class XMLDOMConfiguration {
      constructor() {
        var clonedSelf;
        this.defaultParams = {
          "canonical-form": false,
          "cdata-sections": false,
          "comments": false,
          "datatype-normalization": false,
          "element-content-whitespace": true,
          "entities": true,
          "error-handler": new XMLDOMErrorHandler(),
          "infoset": true,
          "validate-if-schema": false,
          "namespaces": true,
          "namespace-declarations": true,
          "normalize-characters": false,
          "schema-location": '',
          "schema-type": '',
          "split-cdata-sections": true,
          "validate": false,
          "well-formed": true
        };
        this.params = clonedSelf = Object.create(this.defaultParams);
      }

      // Gets the value of a parameter.

      // `name` name of the parameter
      getParameter(name) {
        if (this.params.hasOwnProperty(name)) {
          return this.params[name];
        } else {
          return null;
        }
      }

      // Checks if setting a parameter to a specific value is supported.

      // `name` name of the parameter
      // `value` parameter value
      canSetParameter(name, value) {
        return true;
      }

      // Sets the value of a parameter.

      // `name` name of the parameter
      // `value` new value or null if the user wishes to unset the parameter
      setParameter(name, value) {
        if (value != null) {
          return this.params[name] = value;
        } else {
          return delete this.params[name];
        }
      }

    };

    // Returns the list of parameter names
    Object.defineProperty(XMLDOMConfiguration.prototype, 'parameterNames', {
      get: function() {
        return new XMLDOMStringList(Object.keys(this.defaultParams));
      }
    });

    return XMLDOMConfiguration;

  }).call(this);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js":
/*!***********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js ***!
  \***********************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 2.4.1
(function() {
  // Represents the error handler for DOM operations
  var XMLDOMErrorHandler;

  module.exports = XMLDOMErrorHandler = class XMLDOMErrorHandler {
    // Initializes a new instance of `XMLDOMErrorHandler`

    constructor() {}

    // Called on the error handler when an error occurs.

    // `error` the error message as a string
    handleError(error) {
      throw new Error(error);
    }

  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDOMImplementation.js":
/*!*************************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDOMImplementation.js ***!
  \*************************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 2.4.1
(function() {
  // Implements the DOMImplementation interface
  var XMLDOMImplementation;

  module.exports = XMLDOMImplementation = class XMLDOMImplementation {
    // Tests if the DOM implementation implements a specific feature.

    // `feature` package name of the feature to test. In Level 1, the
    //           legal values are "HTML" and "XML" (case-insensitive).
    // `version` version number of the package name to test. 
    //           In Level 1, this is the string "1.0". If the version is 
    //           not specified, supporting any version of the feature will 
    //           cause the method to return true.
    hasFeature(feature, version) {
      return true;
    }

    // Creates a new document type declaration.

    // `qualifiedName` qualified name of the document type to be created
    // `publicId` public identifier of the external subset
    // `systemId` system identifier of the external subset
    createDocumentType(qualifiedName, publicId, systemId) {
      throw new Error("This DOM method is not implemented.");
    }

    // Creates a new document.

    // `namespaceURI` namespace URI of the document element to create
    // `qualifiedName` the qualified name of the document to be created
    // `doctype` the type of document to be created or null
    createDocument(namespaceURI, qualifiedName, doctype) {
      throw new Error("This DOM method is not implemented.");
    }

    // Creates a new HTML document.

    // `title` document title
    createHTMLDocument(title) {
      throw new Error("This DOM method is not implemented.");
    }

    // Returns a specialized object which implements the specialized APIs 
    // of the specified feature and version.

    // `feature` name of the feature requested.
    // `version` version number of the feature to test
    getFeature(feature, version) {
      throw new Error("This DOM method is not implemented.");
    }

  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDOMStringList.js":
/*!*********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDOMStringList.js ***!
  \*********************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 2.4.1
(function() {
  // Represents a list of string entries
  var XMLDOMStringList;

  module.exports = XMLDOMStringList = (function() {
    class XMLDOMStringList {
      // Initializes a new instance of `XMLDOMStringList`
      // This is just a wrapper around an ordinary
      // JS array.

      // `arr` the array of string values
      constructor(arr) {
        this.arr = arr || [];
      }

      // Returns the indexth item in the collection.

      // `index` index into the collection
      item(index) {
        return this.arr[index] || null;
      }

      // Test if a string is part of this DOMStringList.

      // `str` the string to look for
      contains(str) {
        return this.arr.indexOf(str) !== -1;
      }

    };

    // Returns the number of strings in the list.
    Object.defineProperty(XMLDOMStringList.prototype, 'length', {
      get: function() {
        return this.arr.length;
      }
    });

    return XMLDOMStringList;

  }).call(this);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDAttList.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLDTDAttList, XMLNode;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  // Represents an attribute list
  module.exports = XMLDTDAttList = class XMLDTDAttList extends XMLNode {
    // Initializes a new instance of `XMLDTDAttList`

    // `parent` the parent `XMLDocType` element
    // `elementName` the name of the element containing this attribute
    // `attributeName` attribute name
    // `attributeType` type of the attribute
    // `defaultValueType` default value type (either #REQUIRED, #IMPLIED,
    //                    #FIXED or #DEFAULT)
    // `defaultValue` default value of the attribute
    //                (only used for #FIXED or #DEFAULT)
    constructor(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      super(parent);
      if (elementName == null) {
        throw new Error("Missing DTD element name. " + this.debugInfo());
      }
      if (attributeName == null) {
        throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
      }
      if (!attributeType) {
        throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
      }
      if (!defaultValueType) {
        throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
      }
      if (defaultValueType.indexOf('#') !== 0) {
        defaultValueType = '#' + defaultValueType;
      }
      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
      }
      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
        throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
      }
      this.elementName = this.stringify.name(elementName);
      this.type = NodeType.AttributeDeclaration;
      this.attributeName = this.stringify.name(attributeName);
      this.attributeType = this.stringify.dtdAttType(attributeType);
      if (defaultValue) {
        this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
      }
      this.defaultValueType = defaultValueType;
    }

    // Converts the XML fragment to string

    // `options.pretty` pretty prints the result
    // `options.indent` indentation for pretty print
    // `options.offset` how many indentations to add to every line for pretty print
    // `options.newline` newline sequence for pretty print
    toString(options) {
      return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
    }

  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDElement.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDElement.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLDTDElement, XMLNode;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  // Represents an attribute
  module.exports = XMLDTDElement = class XMLDTDElement extends XMLNode {
    // Initializes a new instance of `XMLDTDElement`

    // `parent` the parent `XMLDocType` element
    // `name` element name
    // `value` element content (defaults to #PCDATA)
    constructor(parent, name, value) {
      super(parent);
      if (name == null) {
        throw new Error("Missing DTD element name. " + this.debugInfo());
      }
      if (!value) {
        value = '(#PCDATA)';
      }
      if (Array.isArray(value)) {
        value = '(' + value.join(',') + ')';
      }
      this.name = this.stringify.name(name);
      this.type = NodeType.ElementDeclaration;
      this.value = this.stringify.dtdElementValue(value);
    }

    // Converts the XML fragment to string

    // `options.pretty` pretty prints the result
    // `options.indent` indentation for pretty print
    // `options.offset` how many indentations to add to every line for pretty print
    // `options.newline` newline sequence for pretty print
    toString(options) {
      return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
    }

  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js":
/*!*****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDEntity.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLDTDEntity, XMLNode, isObject;

  ({isObject} = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"));

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  // Represents an entity declaration in the DTD
  module.exports = XMLDTDEntity = (function() {
    class XMLDTDEntity extends XMLNode {
      // Initializes a new instance of `XMLDTDEntity`

      // `parent` the parent `XMLDocType` element
      // `pe` whether this is a parameter entity or a general entity
      //      defaults to `false` (general entity)
      // `name` the name of the entity
      // `value` internal entity value or an object with external entity details
      // `value.pubID` public identifier
      // `value.sysID` system identifier
      // `value.nData` notation declaration
      constructor(parent, pe, name, value) {
        super(parent);
        if (name == null) {
          throw new Error("Missing DTD entity name. " + this.debugInfo(name));
        }
        if (value == null) {
          throw new Error("Missing DTD entity value. " + this.debugInfo(name));
        }
        this.pe = !!pe;
        this.name = this.stringify.name(name);
        this.type = NodeType.EntityDeclaration;
        if (!isObject(value)) {
          this.value = this.stringify.dtdEntityValue(value);
          this.internal = true;
        } else {
          if (!value.pubID && !value.sysID) {
            throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
          }
          if (value.pubID && !value.sysID) {
            throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
          }
          this.internal = false;
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
          if (value.nData != null) {
            this.nData = this.stringify.dtdNData(value.nData);
          }
          if (this.pe && this.nData) {
            throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
          }
        }
      }

      // Converts the XML fragment to string

      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      toString(options) {
        return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
      }

    };

    // DOM level 1
    Object.defineProperty(XMLDTDEntity.prototype, 'publicId', {
      get: function() {
        return this.pubID;
      }
    });

    Object.defineProperty(XMLDTDEntity.prototype, 'systemId', {
      get: function() {
        return this.sysID;
      }
    });

    Object.defineProperty(XMLDTDEntity.prototype, 'notationName', {
      get: function() {
        return this.nData || null;
      }
    });

    // DOM level 3
    Object.defineProperty(XMLDTDEntity.prototype, 'inputEncoding', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDTDEntity.prototype, 'xmlEncoding', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDTDEntity.prototype, 'xmlVersion', {
      get: function() {
        return null;
      }
    });

    return XMLDTDEntity;

  }).call(this);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDNotation.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLDTDNotation, XMLNode;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  // Represents a NOTATION entry in the DTD
  module.exports = XMLDTDNotation = (function() {
    class XMLDTDNotation extends XMLNode {
      // Initializes a new instance of `XMLDTDNotation`

      // `parent` the parent `XMLDocType` element
      // `name` the name of the notation
      // `value` an object with external entity details
      // `value.pubID` public identifier
      // `value.sysID` system identifier
      constructor(parent, name, value) {
        super(parent);
        if (name == null) {
          throw new Error("Missing DTD notation name. " + this.debugInfo(name));
        }
        if (!value.pubID && !value.sysID) {
          throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
        }
        this.name = this.stringify.name(name);
        this.type = NodeType.NotationDeclaration;
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
      }

      // Converts the XML fragment to string

      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      toString(options) {
        return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
      }

    };

    // DOM level 1
    Object.defineProperty(XMLDTDNotation.prototype, 'publicId', {
      get: function() {
        return this.pubID;
      }
    });

    Object.defineProperty(XMLDTDNotation.prototype, 'systemId', {
      get: function() {
        return this.sysID;
      }
    });

    return XMLDTDNotation;

  }).call(this);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDeclaration.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDeclaration.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLDeclaration, XMLNode, isObject;

  ({isObject} = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"));

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  // Represents the XML declaration
  module.exports = XMLDeclaration = class XMLDeclaration extends XMLNode {
    // Initializes a new instance of `XMLDeclaration`

    // `parent` the document object

    // `version` A version number string, e.g. 1.0
    // `encoding` Encoding declaration, e.g. UTF-8
    // `standalone` standalone document declaration: true or false
    constructor(parent, version, encoding, standalone) {
      super(parent);
      // arguments may also be passed as an object
      if (isObject(version)) {
        ({version, encoding, standalone} = version);
      }
      if (!version) {
        version = '1.0';
      }
      this.type = NodeType.Declaration;
      this.version = this.stringify.xmlVersion(version);
      if (encoding != null) {
        this.encoding = this.stringify.xmlEncoding(encoding);
      }
      if (standalone != null) {
        this.standalone = this.stringify.xmlStandalone(standalone);
      }
    }

    // Converts to string

    // `options.pretty` pretty prints the result
    // `options.indent` indentation for pretty print
    // `options.offset` how many indentations to add to every line for pretty print
    // `options.newline` newline sequence for pretty print
    toString(options) {
      return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
    }

  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocType.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocType.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject;

  ({isObject} = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"));

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js");

  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js");

  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "./node_modules/xmlbuilder/lib/XMLDTDElement.js");

  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js");

  XMLNamedNodeMap = __webpack_require__(/*! ./XMLNamedNodeMap */ "./node_modules/xmlbuilder/lib/XMLNamedNodeMap.js");

  // Represents doctype declaration
  module.exports = XMLDocType = (function() {
    class XMLDocType extends XMLNode {
      // Initializes a new instance of `XMLDocType`

      // `parent` the document object

      // `pubID` public identifier of the external subset
      // `sysID` system identifier of the external subset
      constructor(parent, pubID, sysID) {
        var child, i, len, ref;
        super(parent);
        this.type = NodeType.DocType;
        // set DTD name to the name of the root node
        if (parent.children) {
          ref = parent.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            if (child.type === NodeType.Element) {
              this.name = child.name;
              break;
            }
          }
        }
        this.documentObject = parent;
        // arguments may also be passed as an object
        if (isObject(pubID)) {
          ({pubID, sysID} = pubID);
        }
        if (sysID == null) {
          [sysID, pubID] = [pubID, sysID];
        }
        if (pubID != null) {
          this.pubID = this.stringify.dtdPubID(pubID);
        }
        if (sysID != null) {
          this.sysID = this.stringify.dtdSysID(sysID);
        }
      }

      // Creates an element type declaration

      // `name` element name
      // `value` element content (defaults to #PCDATA)
      element(name, value) {
        var child;
        child = new XMLDTDElement(this, name, value);
        this.children.push(child);
        return this;
      }

      // Creates an attribute declaration

      // `elementName` the name of the element containing this attribute
      // `attributeName` attribute name
      // `attributeType` type of the attribute (defaults to CDATA)
      // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or
      //                    #DEFAULT) (defaults to #IMPLIED)
      // `defaultValue` default value of the attribute
      //                (only used for #FIXED or #DEFAULT)
      attList(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var child;
        child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
        this.children.push(child);
        return this;
      }

      // Creates a general entity declaration

      // `name` the name of the entity
      // `value` internal entity value or an object with external entity details
      // `value.pubID` public identifier
      // `value.sysID` system identifier
      // `value.nData` notation declaration
      entity(name, value) {
        var child;
        child = new XMLDTDEntity(this, false, name, value);
        this.children.push(child);
        return this;
      }

      // Creates a parameter entity declaration

      // `name` the name of the entity
      // `value` internal entity value or an object with external entity details
      // `value.pubID` public identifier
      // `value.sysID` system identifier
      pEntity(name, value) {
        var child;
        child = new XMLDTDEntity(this, true, name, value);
        this.children.push(child);
        return this;
      }

      // Creates a NOTATION declaration

      // `name` the name of the notation
      // `value` an object with external entity details
      // `value.pubID` public identifier
      // `value.sysID` system identifier
      notation(name, value) {
        var child;
        child = new XMLDTDNotation(this, name, value);
        this.children.push(child);
        return this;
      }

      // Converts to string

      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      toString(options) {
        return this.options.writer.docType(this, this.options.writer.filterOptions(options));
      }

      // Aliases
      ele(name, value) {
        return this.element(name, value);
      }

      att(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
      }

      ent(name, value) {
        return this.entity(name, value);
      }

      pent(name, value) {
        return this.pEntity(name, value);
      }

      not(name, value) {
        return this.notation(name, value);
      }

      up() {
        return this.root() || this.documentObject;
      }

      isEqualNode(node) {
        if (!super.isEqualNode(node)) {
          return false;
        }
        if (node.name !== this.name) {
          return false;
        }
        if (node.publicId !== this.publicId) {
          return false;
        }
        if (node.systemId !== this.systemId) {
          return false;
        }
        return true;
      }

    };

    // DOM level 1
    Object.defineProperty(XMLDocType.prototype, 'entities', {
      get: function() {
        var child, i, len, nodes, ref;
        nodes = {};
        ref = this.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if ((child.type === NodeType.EntityDeclaration) && !child.pe) {
            nodes[child.name] = child;
          }
        }
        return new XMLNamedNodeMap(nodes);
      }
    });

    Object.defineProperty(XMLDocType.prototype, 'notations', {
      get: function() {
        var child, i, len, nodes, ref;
        nodes = {};
        ref = this.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if (child.type === NodeType.NotationDeclaration) {
            nodes[child.name] = child;
          }
        }
        return new XMLNamedNodeMap(nodes);
      }
    });

    // DOM level 2
    Object.defineProperty(XMLDocType.prototype, 'publicId', {
      get: function() {
        return this.pubID;
      }
    });

    Object.defineProperty(XMLDocType.prototype, 'systemId', {
      get: function() {
        return this.sysID;
      }
    });

    Object.defineProperty(XMLDocType.prototype, 'internalSubset', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    return XMLDocType;

  }).call(this);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocument.js":
/*!****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocument.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject;

  ({isPlainObject} = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"));

  XMLDOMImplementation = __webpack_require__(/*! ./XMLDOMImplementation */ "./node_modules/xmlbuilder/lib/XMLDOMImplementation.js");

  XMLDOMConfiguration = __webpack_require__(/*! ./XMLDOMConfiguration */ "./node_modules/xmlbuilder/lib/XMLDOMConfiguration.js");

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ "./node_modules/xmlbuilder/lib/XMLStringifier.js");

  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "./node_modules/xmlbuilder/lib/XMLStringWriter.js");

  // Represents an XML builder
  module.exports = XMLDocument = (function() {
    class XMLDocument extends XMLNode {
      // Initializes a new instance of `XMLDocument`

      // `options.keepNullNodes` whether nodes with null values will be kept
      //     or ignored: true or false
      // `options.keepNullAttributes` whether attributes with null values will be
      //     kept or ignored: true or false
      // `options.ignoreDecorators` whether decorator strings will be ignored when
      //     converting JS objects: true or false
      // `options.separateArrayItems` whether array items are created as separate
      //     nodes when passed as an object value: true or false
      // `options.noDoubleEncoding` whether existing html entities are encoded:
      //     true or false
      // `options.stringify` a set of functions to use for converting values to
      //     strings
      // `options.writer` the default XML writer to use for converting nodes to
      //     string. If the default writer is not set, the built-in XMLStringWriter
      //     will be used instead.
      constructor(options) {
        super(null);
        this.name = "#document";
        this.type = NodeType.Document;
        this.documentURI = null;
        this.domConfig = new XMLDOMConfiguration();
        options || (options = {});
        if (!options.writer) {
          options.writer = new XMLStringWriter();
        }
        this.options = options;
        this.stringify = new XMLStringifier(options);
      }

      // Ends the document and passes it to the given XML writer

      // `writer` is either an XML writer or a plain object to pass to the
      // constructor of the default XML writer. The default writer is assigned when
      // creating the XML document. Following flags are recognized by the
      // built-in XMLStringWriter:
      //   `writer.pretty` pretty prints the result
      //   `writer.indent` indentation for pretty print
      //   `writer.offset` how many indentations to add to every line for pretty print
      //   `writer.newline` newline sequence for pretty print
      end(writer) {
        var writerOptions;
        writerOptions = {};
        if (!writer) {
          writer = this.options.writer;
        } else if (isPlainObject(writer)) {
          writerOptions = writer;
          writer = this.options.writer;
        }
        return writer.document(this, writer.filterOptions(writerOptions));
      }

      // Converts the XML document to string

      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      toString(options) {
        return this.options.writer.document(this, this.options.writer.filterOptions(options));
      }

      // DOM level 1 functions to be implemented later
      createElement(tagName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      createDocumentFragment() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      createTextNode(data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      createComment(data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      createCDATASection(data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      createProcessingInstruction(target, data) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      createAttribute(name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      createEntityReference(name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      getElementsByTagName(tagname) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      // DOM level 2 functions to be implemented later
      importNode(importedNode, deep) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      createElementNS(namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      createAttributeNS(namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      getElementsByTagNameNS(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      getElementById(elementId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      // DOM level 3 functions to be implemented later
      adoptNode(source) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      normalizeDocument() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      renameNode(node, namespaceURI, qualifiedName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      // DOM level 4 functions to be implemented later
      getElementsByClassName(classNames) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      createEvent(eventInterface) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      createRange() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      createNodeIterator(root, whatToShow, filter) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      createTreeWalker(root, whatToShow, filter) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

    };

    // DOM level 1
    Object.defineProperty(XMLDocument.prototype, 'implementation', {
      value: new XMLDOMImplementation()
    });

    Object.defineProperty(XMLDocument.prototype, 'doctype', {
      get: function() {
        var child, i, len, ref;
        ref = this.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          if (child.type === NodeType.DocType) {
            return child;
          }
        }
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'documentElement', {
      get: function() {
        return this.rootObject || null;
      }
    });

    // DOM level 3
    Object.defineProperty(XMLDocument.prototype, 'inputEncoding', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'strictErrorChecking', {
      get: function() {
        return false;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'xmlEncoding', {
      get: function() {
        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
          return this.children[0].encoding;
        } else {
          return null;
        }
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'xmlStandalone', {
      get: function() {
        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
          return this.children[0].standalone === 'yes';
        } else {
          return false;
        }
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'xmlVersion', {
      get: function() {
        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
          return this.children[0].version;
        } else {
          return "1.0";
        }
      }
    });

    // DOM level 4
    Object.defineProperty(XMLDocument.prototype, 'URL', {
      get: function() {
        return this.documentURI;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'origin', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'compatMode', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'characterSet', {
      get: function() {
        return null;
      }
    });

    Object.defineProperty(XMLDocument.prototype, 'contentType', {
      get: function() {
        return null;
      }
    });

    return XMLDocument;

  }).call(this);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocumentCB.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocumentCB.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject,
    hasProp = {}.hasOwnProperty;

  ({isObject, isFunction, isPlainObject, getValue} = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"));

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLDocument = __webpack_require__(/*! ./XMLDocument */ "./node_modules/xmlbuilder/lib/XMLDocument.js");

  XMLElement = __webpack_require__(/*! ./XMLElement */ "./node_modules/xmlbuilder/lib/XMLElement.js");

  XMLCData = __webpack_require__(/*! ./XMLCData */ "./node_modules/xmlbuilder/lib/XMLCData.js");

  XMLComment = __webpack_require__(/*! ./XMLComment */ "./node_modules/xmlbuilder/lib/XMLComment.js");

  XMLRaw = __webpack_require__(/*! ./XMLRaw */ "./node_modules/xmlbuilder/lib/XMLRaw.js");

  XMLText = __webpack_require__(/*! ./XMLText */ "./node_modules/xmlbuilder/lib/XMLText.js");

  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");

  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "./node_modules/xmlbuilder/lib/XMLDeclaration.js");

  XMLDocType = __webpack_require__(/*! ./XMLDocType */ "./node_modules/xmlbuilder/lib/XMLDocType.js");

  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js");

  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js");

  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "./node_modules/xmlbuilder/lib/XMLDTDElement.js");

  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js");

  XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ "./node_modules/xmlbuilder/lib/XMLAttribute.js");

  XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ "./node_modules/xmlbuilder/lib/XMLStringifier.js");

  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "./node_modules/xmlbuilder/lib/XMLStringWriter.js");

  WriterState = __webpack_require__(/*! ./WriterState */ "./node_modules/xmlbuilder/lib/WriterState.js");

  // Represents an XML builder
  module.exports = XMLDocumentCB = class XMLDocumentCB {
    // Initializes a new instance of `XMLDocumentCB`

    // `options.keepNullNodes` whether nodes with null values will be kept
    //     or ignored: true or false
    // `options.keepNullAttributes` whether attributes with null values will be
    //     kept or ignored: true or false
    // `options.ignoreDecorators` whether decorator strings will be ignored when
    //     converting JS objects: true or false
    // `options.separateArrayItems` whether array items are created as separate
    //     nodes when passed as an object value: true or false
    // `options.noDoubleEncoding` whether existing html entities are encoded:
    //     true or false
    // `options.stringify` a set of functions to use for converting values to
    //     strings
    // `options.writer` the default XML writer to use for converting nodes to
    //     string. If the default writer is not set, the built-in XMLStringWriter
    //     will be used instead.

    // `onData` the function to be called when a new chunk of XML is output. The
    //          string containing the XML chunk is passed to `onData` as its first
    //          argument, and the current indentation level as its second argument.
    // `onEnd`  the function to be called when the XML document is completed with
    //          `end`. `onEnd` does not receive any arguments.
    constructor(options, onData, onEnd) {
      var writerOptions;
      this.name = "?xml";
      this.type = NodeType.Document;
      options || (options = {});
      writerOptions = {};
      if (!options.writer) {
        options.writer = new XMLStringWriter();
      } else if (isPlainObject(options.writer)) {
        writerOptions = options.writer;
        options.writer = new XMLStringWriter();
      }
      this.options = options;
      this.writer = options.writer;
      this.writerOptions = this.writer.filterOptions(writerOptions);
      this.stringify = new XMLStringifier(options);
      this.onDataCallback = onData || function() {};
      this.onEndCallback = onEnd || function() {};
      this.currentNode = null;
      this.currentLevel = -1;
      this.openTags = {};
      this.documentStarted = false;
      this.documentCompleted = false;
      this.root = null;
    }

    // Creates a child element node from the given XMLNode

    // `node` the child node
    createChildNode(node) {
      var att, attName, attributes, child, i, len, ref, ref1;
      switch (node.type) {
        case NodeType.CData:
          this.cdata(node.value);
          break;
        case NodeType.Comment:
          this.comment(node.value);
          break;
        case NodeType.Element:
          attributes = {};
          ref = node.attribs;
          for (attName in ref) {
            if (!hasProp.call(ref, attName)) continue;
            att = ref[attName];
            attributes[attName] = att.value;
          }
          this.node(node.name, attributes);
          break;
        case NodeType.Dummy:
          this.dummy();
          break;
        case NodeType.Raw:
          this.raw(node.value);
          break;
        case NodeType.Text:
          this.text(node.value);
          break;
        case NodeType.ProcessingInstruction:
          this.instruction(node.target, node.value);
          break;
        default:
          throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
      }
      ref1 = node.children;
      // write child nodes recursively
      for (i = 0, len = ref1.length; i < len; i++) {
        child = ref1[i];
        this.createChildNode(child);
        if (child.type === NodeType.Element) {
          this.up();
        }
      }
      return this;
    }

    // Creates a dummy node

    dummy() {
      // no-op, just return this
      return this;
    }

    // Creates a node

    // `name` name of the node
    // `attributes` an object containing name/value pairs of attributes
    // `text` element text
    node(name, attributes, text) {
      if (name == null) {
        throw new Error("Missing node name.");
      }
      if (this.root && this.currentLevel === -1) {
        throw new Error("Document can only have one root node. " + this.debugInfo(name));
      }
      this.openCurrent();
      name = getValue(name);
      if (attributes == null) {
        attributes = {};
      }
      attributes = getValue(attributes);
      // swap argument order: text <-> attributes
      if (!isObject(attributes)) {
        [text, attributes] = [attributes, text];
      }
      this.currentNode = new XMLElement(this, name, attributes);
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      if (text != null) {
        this.text(text);
      }
      return this;
    }

    // Creates a child element node or an element type declaration when called
    // inside the DTD

    // `name` name of the node
    // `attributes` an object containing name/value pairs of attributes
    // `text` element text
    element(name, attributes, text) {
      var child, i, len, oldValidationFlag, ref, root;
      if (this.currentNode && this.currentNode.type === NodeType.DocType) {
        this.dtdElement(...arguments);
      } else {
        if (Array.isArray(name) || isObject(name) || isFunction(name)) {
          oldValidationFlag = this.options.noValidation;
          this.options.noValidation = true;
          root = new XMLDocument(this.options).element('TEMP_ROOT');
          root.element(name);
          this.options.noValidation = oldValidationFlag;
          ref = root.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            this.createChildNode(child);
            if (child.type === NodeType.Element) {
              this.up();
            }
          }
        } else {
          this.node(name, attributes, text);
        }
      }
      return this;
    }

    // Adds or modifies an attribute

    // `name` attribute name
    // `value` attribute value
    attribute(name, value) {
      var attName, attValue;
      if (!this.currentNode || this.currentNode.children) {
        throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
      }
      if (name != null) {
        name = getValue(name);
      }
      if (isObject(name)) { // expand if object
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (this.options.keepNullAttributes && (value == null)) {
          this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
        } else if (value != null) {
          this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    }

    // Creates a text node

    // `value` element text
    text(value) {
      var node;
      this.openCurrent();
      node = new XMLText(this, value);
      this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    }

    // Creates a CDATA node

    // `value` element text without CDATA delimiters
    cdata(value) {
      var node;
      this.openCurrent();
      node = new XMLCData(this, value);
      this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    }

    // Creates a comment node

    // `value` comment text
    comment(value) {
      var node;
      this.openCurrent();
      node = new XMLComment(this, value);
      this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    }

    // Adds unescaped raw text

    // `value` text
    raw(value) {
      var node;
      this.openCurrent();
      node = new XMLRaw(this, value);
      this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    }

    // Adds a processing instruction

    // `target` instruction target
    // `value` instruction value
    instruction(target, value) {
      var i, insTarget, insValue, len, node;
      this.openCurrent();
      if (target != null) {
        target = getValue(target);
      }
      if (value != null) {
        value = getValue(value);
      }
      if (Array.isArray(target)) { // expand if array
        for (i = 0, len = target.length; i < len; i++) {
          insTarget = target[i];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) { // expand if object
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        node = new XMLProcessingInstruction(this, target, value);
        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      }
      return this;
    }

    // Creates the xml declaration

    // `version` A version number string, e.g. 1.0
    // `encoding` Encoding declaration, e.g. UTF-8
    // `standalone` standalone document declaration: true or false
    declaration(version, encoding, standalone) {
      var node;
      this.openCurrent();
      if (this.documentStarted) {
        throw new Error("declaration() must be the first node.");
      }
      node = new XMLDeclaration(this, version, encoding, standalone);
      this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    }

    // Creates the document type declaration

    // `root`  the name of the root node
    // `pubID` the public identifier of the external subset
    // `sysID` the system identifier of the external subset
    doctype(root, pubID, sysID) {
      this.openCurrent();
      if (root == null) {
        throw new Error("Missing root node name.");
      }
      if (this.root) {
        throw new Error("dtd() must come before the root node.");
      }
      this.currentNode = new XMLDocType(this, pubID, sysID);
      this.currentNode.rootNodeName = root;
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      return this;
    }

    // Creates an element type declaration

    // `name` element name
    // `value` element content (defaults to #PCDATA)
    dtdElement(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDElement(this, name, value);
      this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    }

    // Creates an attribute declaration

    // `elementName` the name of the element containing this attribute
    // `attributeName` attribute name
    // `attributeType` type of the attribute (defaults to CDATA)
    // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or
    //                    #DEFAULT) (defaults to #IMPLIED)
    // `defaultValue` default value of the attribute
    //                (only used for #FIXED or #DEFAULT)
    attList(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var node;
      this.openCurrent();
      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    }

    // Creates a general entity declaration

    // `name` the name of the entity
    // `value` internal entity value or an object with external entity details
    // `value.pubID` public identifier
    // `value.sysID` system identifier
    // `value.nData` notation declaration
    entity(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, false, name, value);
      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    }

    // Creates a parameter entity declaration

    // `name` the name of the entity
    // `value` internal entity value or an object with external entity details
    // `value.pubID` public identifier
    // `value.sysID` system identifier
    pEntity(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, true, name, value);
      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    }

    // Creates a NOTATION declaration

    // `name` the name of the notation
    // `value` an object with external entity details
    // `value.pubID` public identifier
    // `value.sysID` system identifier
    notation(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDNotation(this, name, value);
      this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
      return this;
    }

    // Gets the parent node
    up() {
      if (this.currentLevel < 0) {
        throw new Error("The document node has no parent.");
      }
      if (this.currentNode) {
        if (this.currentNode.children) {
          this.closeNode(this.currentNode);
        } else {
          this.openNode(this.currentNode);
        }
        this.currentNode = null;
      } else {
        this.closeNode(this.openTags[this.currentLevel]);
      }
      delete this.openTags[this.currentLevel];
      this.currentLevel--;
      return this;
    }

    // Ends the document
    end() {
      while (this.currentLevel >= 0) {
        this.up();
      }
      return this.onEnd();
    }

    // Opens the current parent node
    openCurrent() {
      if (this.currentNode) {
        this.currentNode.children = true;
        return this.openNode(this.currentNode);
      }
    }

    // Writes the opening tag of the current node or the entire node if it has
    // no child nodes
    openNode(node) {
      var att, chunk, name, ref;
      if (!node.isOpen) {
        if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
          this.root = node;
        }
        chunk = '';
        if (node.type === NodeType.Element) {
          this.writerOptions.state = WriterState.OpenTag;
          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;
          ref = node.attribs;
          for (name in ref) {
            if (!hasProp.call(ref, name)) continue;
            att = ref[name];
            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
          }
          chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);
          this.writerOptions.state = WriterState.InsideTag; // if node.type is NodeType.DocType
        } else {
          this.writerOptions.state = WriterState.OpenTag;
          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;
          
          // external identifier
          if (node.pubID && node.sysID) {
            chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            chunk += ' SYSTEM "' + node.sysID + '"';
          }
          
          // internal subset
          if (node.children) {
            chunk += ' [';
            this.writerOptions.state = WriterState.InsideTag;
          } else {
            this.writerOptions.state = WriterState.CloseTag;
            chunk += '>';
          }
          chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
        }
        this.onData(chunk, this.currentLevel);
        return node.isOpen = true;
      }
    }

    // Writes the closing tag of the current node
    closeNode(node) {
      var chunk;
      if (!node.isClosed) {
        chunk = '';
        this.writerOptions.state = WriterState.CloseTag;
        if (node.type === NodeType.Element) {
          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel); // if node.type is NodeType.DocType
        } else {
          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);
        }
        this.writerOptions.state = WriterState.None;
        this.onData(chunk, this.currentLevel);
        return node.isClosed = true;
      }
    }

    // Called when a new chunk of XML is output

    // `chunk` a string containing the XML chunk
    // `level` current indentation level
    onData(chunk, level) {
      this.documentStarted = true;
      return this.onDataCallback(chunk, level + 1);
    }

    // Called when the XML document is completed
    onEnd() {
      this.documentCompleted = true;
      return this.onEndCallback();
    }

    // Returns debug string
    debugInfo(name) {
      if (name == null) {
        return "";
      } else {
        return "node: <" + name + ">";
      }
    }

    // Node aliases
    ele() {
      return this.element(...arguments);
    }

    nod(name, attributes, text) {
      return this.node(name, attributes, text);
    }

    txt(value) {
      return this.text(value);
    }

    dat(value) {
      return this.cdata(value);
    }

    com(value) {
      return this.comment(value);
    }

    ins(target, value) {
      return this.instruction(target, value);
    }

    dec(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    }

    dtd(root, pubID, sysID) {
      return this.doctype(root, pubID, sysID);
    }

    e(name, attributes, text) {
      return this.element(name, attributes, text);
    }

    n(name, attributes, text) {
      return this.node(name, attributes, text);
    }

    t(value) {
      return this.text(value);
    }

    d(value) {
      return this.cdata(value);
    }

    c(value) {
      return this.comment(value);
    }

    r(value) {
      return this.raw(value);
    }

    i(target, value) {
      return this.instruction(target, value);
    }

    // Attribute aliases
    att() {
      if (this.currentNode && this.currentNode.type === NodeType.DocType) {
        return this.attList(...arguments);
      } else {
        return this.attribute(...arguments);
      }
    }

    a() {
      if (this.currentNode && this.currentNode.type === NodeType.DocType) {
        return this.attList(...arguments);
      } else {
        return this.attribute(...arguments);
      }
    }

    // DTD aliases
    // att() and ele() are defined above
    ent(name, value) {
      return this.entity(name, value);
    }

    pent(name, value) {
      return this.pEntity(name, value);
    }

    not(name, value) {
      return this.notation(name, value);
    }

  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDummy.js":
/*!*************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDummy.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLDummy, XMLNode;

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  // Represents a  raw node
  module.exports = XMLDummy = class XMLDummy extends XMLNode {
    // Initializes a new instance of `XMLDummy`

    // `XMLDummy` is a special node representing a node with 
    // a null value. Dummy nodes are created while recursively
    // building the XML tree. Simply skipping null values doesn't
    // work because that would break the recursive chain.
    constructor(parent) {
      super(parent);
      this.type = NodeType.Dummy;
    }

    // Creates and returns a deep clone of `this`
    clone() {
      return Object.create(this);
    }

    // Converts the XML fragment to string

    // `options.pretty` pretty prints the result
    // `options.indent` indentation for pretty print
    // `options.offset` how many indentations to add to every line for pretty print
    // `options.newline` newline sequence for pretty print
    toString(options) {
      return '';
    }

  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLElement.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLElement.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject,
    hasProp = {}.hasOwnProperty;

  ({isObject, isFunction, getValue} = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"));

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ "./node_modules/xmlbuilder/lib/XMLAttribute.js");

  XMLNamedNodeMap = __webpack_require__(/*! ./XMLNamedNodeMap */ "./node_modules/xmlbuilder/lib/XMLNamedNodeMap.js");

  // Represents an element of the XML document
  module.exports = XMLElement = (function() {
    class XMLElement extends XMLNode {
      // Initializes a new instance of `XMLElement`

      // `parent` the parent node
      // `name` element name
      // `attributes` an object containing name/value pairs of attributes
      constructor(parent, name, attributes) {
        var child, j, len, ref;
        super(parent);
        if (name == null) {
          throw new Error("Missing element name. " + this.debugInfo());
        }
        this.name = this.stringify.name(name);
        this.type = NodeType.Element;
        this.attribs = {};
        this.schemaTypeInfo = null;
        if (attributes != null) {
          this.attribute(attributes);
        }
        // set properties if this is the root node
        if (parent.type === NodeType.Document) {
          this.isRoot = true;
          this.documentObject = parent;
          parent.rootObject = this;
          // set dtd name
          if (parent.children) {
            ref = parent.children;
            for (j = 0, len = ref.length; j < len; j++) {
              child = ref[j];
              if (child.type === NodeType.DocType) {
                child.name = this.name;
                break;
              }
            }
          }
        }
      }

      // Creates and returns a deep clone of `this`

      clone() {
        var att, attName, clonedSelf, ref;
        clonedSelf = Object.create(this);
        // remove document element
        if (clonedSelf.isRoot) {
          clonedSelf.documentObject = null;
        }
        // clone attributes
        clonedSelf.attribs = {};
        ref = this.attribs;
        for (attName in ref) {
          if (!hasProp.call(ref, attName)) continue;
          att = ref[attName];
          clonedSelf.attribs[attName] = att.clone();
        }
        // clone child nodes
        clonedSelf.children = [];
        this.children.forEach(function(child) {
          var clonedChild;
          clonedChild = child.clone();
          clonedChild.parent = clonedSelf;
          return clonedSelf.children.push(clonedChild);
        });
        return clonedSelf;
      }

      // Adds or modifies an attribute

      // `name` attribute name
      // `value` attribute value
      attribute(name, value) {
        var attName, attValue;
        if (name != null) {
          name = getValue(name);
        }
        if (isObject(name)) { // expand if object
          for (attName in name) {
            if (!hasProp.call(name, attName)) continue;
            attValue = name[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          if (this.options.keepNullAttributes && (value == null)) {
            this.attribs[name] = new XMLAttribute(this, name, "");
          } else if (value != null) {
            this.attribs[name] = new XMLAttribute(this, name, value);
          }
        }
        return this;
      }

      // Removes an attribute

      // `name` attribute name
      removeAttribute(name) {
        var attName, j, len;
        // Also defined in DOM level 1
        // removeAttribute(name) removes an attribute by name.
        if (name == null) {
          throw new Error("Missing attribute name. " + this.debugInfo());
        }
        name = getValue(name);
        if (Array.isArray(name)) { // expand if array
          for (j = 0, len = name.length; j < len; j++) {
            attName = name[j];
            delete this.attribs[attName];
          }
        } else {
          delete this.attribs[name];
        }
        return this;
      }

      // Converts the XML fragment to string

      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      // `options.allowEmpty` do not self close empty element tags
      toString(options) {
        return this.options.writer.element(this, this.options.writer.filterOptions(options));
      }

      // Aliases
      att(name, value) {
        return this.attribute(name, value);
      }

      a(name, value) {
        return this.attribute(name, value);
      }

      // DOM Level 1
      getAttribute(name) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name].value;
        } else {
          return null;
        }
      }

      setAttribute(name, value) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      getAttributeNode(name) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name];
        } else {
          return null;
        }
      }

      setAttributeNode(newAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      removeAttributeNode(oldAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      getElementsByTagName(name) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      // DOM Level 2
      getAttributeNS(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      setAttributeNS(namespaceURI, qualifiedName, value) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      removeAttributeNS(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      getAttributeNodeNS(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      setAttributeNodeNS(newAttr) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      getElementsByTagNameNS(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      hasAttribute(name) {
        return this.attribs.hasOwnProperty(name);
      }

      hasAttributeNS(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      // DOM Level 3
      setIdAttribute(name, isId) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name].isId;
        } else {
          return isId;
        }
      }

      setIdAttributeNS(namespaceURI, localName, isId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      setIdAttributeNode(idAttr, isId) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      // DOM Level 4
      getElementsByTagName(tagname) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      getElementsByTagNameNS(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      getElementsByClassName(classNames) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      isEqualNode(node) {
        var i, j, ref;
        if (!super.isEqualNode(node)) {
          return false;
        }
        if (node.namespaceURI !== this.namespaceURI) {
          return false;
        }
        if (node.prefix !== this.prefix) {
          return false;
        }
        if (node.localName !== this.localName) {
          return false;
        }
        if (node.attribs.length !== this.attribs.length) {
          return false;
        }
        for (i = j = 0, ref = this.attribs.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
          if (!this.attribs[i].isEqualNode(node.attribs[i])) {
            return false;
          }
        }
        return true;
      }

    };

    // DOM level 1
    Object.defineProperty(XMLElement.prototype, 'tagName', {
      get: function() {
        return this.name;
      }
    });

    // DOM level 4
    Object.defineProperty(XMLElement.prototype, 'namespaceURI', {
      get: function() {
        return '';
      }
    });

    Object.defineProperty(XMLElement.prototype, 'prefix', {
      get: function() {
        return '';
      }
    });

    Object.defineProperty(XMLElement.prototype, 'localName', {
      get: function() {
        return this.name;
      }
    });

    Object.defineProperty(XMLElement.prototype, 'id', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    Object.defineProperty(XMLElement.prototype, 'className', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    Object.defineProperty(XMLElement.prototype, 'classList', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    Object.defineProperty(XMLElement.prototype, 'attributes', {
      get: function() {
        if (!this.attributeMap || !this.attributeMap.nodes) {
          this.attributeMap = new XMLNamedNodeMap(this.attribs);
        }
        return this.attributeMap;
      }
    });

    return XMLElement;

  }).call(this);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLNamedNodeMap.js":
/*!********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLNamedNodeMap.js ***!
  \********************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 2.4.1
(function() {
  // Represents a map of nodes accessed by a string key
  var XMLNamedNodeMap;

  module.exports = XMLNamedNodeMap = (function() {
    class XMLNamedNodeMap {
      // Initializes a new instance of `XMLNamedNodeMap`
      // This is just a wrapper around an ordinary
      // JS object.

      // `nodes` the object containing nodes.
      constructor(nodes) {
        this.nodes = nodes;
      }

      // Creates and returns a deep clone of `this`

      clone() {
        // this class should not be cloned since it wraps
        // around a given object. The calling function should check
        // whether the wrapped object is null and supply a new object
        // (from the clone).
        return this.nodes = null;
      }

      // DOM Level 1
      getNamedItem(name) {
        return this.nodes[name];
      }

      setNamedItem(node) {
        var oldNode;
        oldNode = this.nodes[node.nodeName];
        this.nodes[node.nodeName] = node;
        return oldNode || null;
      }

      removeNamedItem(name) {
        var oldNode;
        oldNode = this.nodes[name];
        delete this.nodes[name];
        return oldNode || null;
      }

      item(index) {
        return this.nodes[Object.keys(this.nodes)[index]] || null;
      }

      // DOM level 2 functions to be implemented later
      getNamedItemNS(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented.");
      }

      setNamedItemNS(node) {
        throw new Error("This DOM method is not implemented.");
      }

      removeNamedItemNS(namespaceURI, localName) {
        throw new Error("This DOM method is not implemented.");
      }

    };

    
    // DOM level 1
    Object.defineProperty(XMLNamedNodeMap.prototype, 'length', {
      get: function() {
        return Object.keys(this.nodes).length || 0;
      }
    });

    return XMLNamedNodeMap;

  }).call(this);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLNode.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLNode.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject,
    hasProp = {}.hasOwnProperty,
    splice = [].splice;

  ({isObject, isFunction, isEmpty, getValue} = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"));

  XMLElement = null;

  XMLCData = null;

  XMLComment = null;

  XMLDeclaration = null;

  XMLDocType = null;

  XMLRaw = null;

  XMLText = null;

  XMLProcessingInstruction = null;

  XMLDummy = null;

  NodeType = null;

  XMLNodeList = null;

  XMLNamedNodeMap = null;

  DocumentPosition = null;

  // Represents a generic XMl element
  module.exports = XMLNode = (function() {
    class XMLNode {
      // Initializes a new instance of `XMLNode`

      // `parent` the parent node
      constructor(parent1) {
        this.parent = parent1;
        if (this.parent) {
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }
        this.value = null;
        this.children = [];
        this.baseURI = null;
        // first execution, load dependencies that are otherwise
        // circular (so we can't load them at the top)
        if (!XMLElement) {
          XMLElement = __webpack_require__(/*! ./XMLElement */ "./node_modules/xmlbuilder/lib/XMLElement.js");
          XMLCData = __webpack_require__(/*! ./XMLCData */ "./node_modules/xmlbuilder/lib/XMLCData.js");
          XMLComment = __webpack_require__(/*! ./XMLComment */ "./node_modules/xmlbuilder/lib/XMLComment.js");
          XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "./node_modules/xmlbuilder/lib/XMLDeclaration.js");
          XMLDocType = __webpack_require__(/*! ./XMLDocType */ "./node_modules/xmlbuilder/lib/XMLDocType.js");
          XMLRaw = __webpack_require__(/*! ./XMLRaw */ "./node_modules/xmlbuilder/lib/XMLRaw.js");
          XMLText = __webpack_require__(/*! ./XMLText */ "./node_modules/xmlbuilder/lib/XMLText.js");
          XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");
          XMLDummy = __webpack_require__(/*! ./XMLDummy */ "./node_modules/xmlbuilder/lib/XMLDummy.js");
          NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");
          XMLNodeList = __webpack_require__(/*! ./XMLNodeList */ "./node_modules/xmlbuilder/lib/XMLNodeList.js");
          XMLNamedNodeMap = __webpack_require__(/*! ./XMLNamedNodeMap */ "./node_modules/xmlbuilder/lib/XMLNamedNodeMap.js");
          DocumentPosition = __webpack_require__(/*! ./DocumentPosition */ "./node_modules/xmlbuilder/lib/DocumentPosition.js");
        }
      }

      
      // Sets the parent node of this node and its children recursively

      // `parent` the parent node
      setParent(parent) {
        var child, j, len, ref1, results;
        this.parent = parent;
        if (parent) {
          this.options = parent.options;
          this.stringify = parent.stringify;
        }
        ref1 = this.children;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          child = ref1[j];
          results.push(child.setParent(this));
        }
        return results;
      }

      // Creates a child element node

      // `name` node name or an object describing the XML tree
      // `attributes` an object containing name/value pairs of attributes
      // `text` element text
      element(name, attributes, text) {
        var childNode, item, j, k, key, lastChild, len, len1, val;
        lastChild = null;
        if (attributes === null && (text == null)) {
          [attributes, text] = [{}, null];
        }
        if (attributes == null) {
          attributes = {};
        }
        attributes = getValue(attributes);
        // swap argument order: text <-> attributes
        if (!isObject(attributes)) {
          [text, attributes] = [attributes, text];
        }
        if (name != null) {
          name = getValue(name);
        }
        // expand if array
        if (Array.isArray(name)) {
          for (j = 0, len = name.length; j < len; j++) {
            item = name[j];
            lastChild = this.element(item);
          }
        // evaluate if function
        } else if (isFunction(name)) {
          lastChild = this.element(name.apply());
        // expand if object
        } else if (isObject(name)) {
          for (key in name) {
            if (!hasProp.call(name, key)) continue;
            val = name[key];
            if (isFunction(val)) {
              // evaluate if function
              val = val.apply();
            }
            // assign attributes
            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
            // skip empty arrays
            } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
              lastChild = this.dummy();
            // empty objects produce one node
            } else if (isObject(val) && isEmpty(val)) {
              lastChild = this.element(key);
            // skip null and undefined nodes
            } else if (!this.options.keepNullNodes && (val == null)) {
              lastChild = this.dummy();
            
            // expand list by creating child nodes
            } else if (!this.options.separateArrayItems && Array.isArray(val)) {
              for (k = 0, len1 = val.length; k < len1; k++) {
                item = val[k];
                childNode = {};
                childNode[key] = item;
                lastChild = this.element(childNode);
              }
            
            // expand child nodes under parent
            } else if (isObject(val)) {
              // if the key is #text expand child nodes under this node to support mixed content
              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                lastChild = this.element(val);
              } else {
                lastChild = this.element(key);
                lastChild.element(val);
              }
            } else {
              
              // text node
              lastChild = this.element(key, val);
            }
          }
        // skip null nodes
        } else if (!this.options.keepNullNodes && text === null) {
          lastChild = this.dummy();
        } else {
          // text node
          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
            lastChild = this.text(text);
          // cdata node
          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
            lastChild = this.cdata(text);
          // comment node
          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
            lastChild = this.comment(text);
          // raw text node
          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
            lastChild = this.raw(text);
          // processing instruction
          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
            lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
          } else {
            // element node
            lastChild = this.node(name, attributes, text);
          }
        }
        if (lastChild == null) {
          throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
        }
        return lastChild;
      }

      // Creates a child element node before the current node

      // `name` node name or an object describing the XML tree
      // `attributes` an object containing name/value pairs of attributes
      // `text` element text
      insertBefore(name, attributes, text) {
        var child, i, newChild, refChild, removed;
        // DOM level 1
        // insertBefore(newChild, refChild) inserts the child node newChild before refChild
        if (name != null ? name.type : void 0) {
          newChild = name;
          refChild = attributes;
          newChild.setParent(this);
          if (refChild) {
            // temporarily remove children starting *with* refChild
            i = children.indexOf(refChild);
            removed = children.splice(i);
            
            // add the new child
            children.push(newChild);
            
            // add back removed children after new child
            Array.prototype.push.apply(children, removed);
          } else {
            children.push(newChild);
          }
          return newChild;
        } else {
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
          }
          
          // temporarily remove children starting *with* this
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          
          // add the new child
          child = this.parent.element(name, attributes, text);
          
          // add back removed children after new child
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        }
      }

      // Creates a child element node after the current node

      // `name` node name or an object describing the XML tree
      // `attributes` an object containing name/value pairs of attributes
      // `text` element text
      insertAfter(name, attributes, text) {
        var child, i, removed;
        if (this.isRoot) {
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
        }
        
        // temporarily remove children starting *after* this
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        
        // add the new child
        child = this.parent.element(name, attributes, text);
        
        // add back removed children after new child
        Array.prototype.push.apply(this.parent.children, removed);
        return child;
      }

      // Deletes a child element node

      remove() {
        var i, ref1;
        if (this.isRoot) {
          throw new Error("Cannot remove the root element. " + this.debugInfo());
        }
        i = this.parent.children.indexOf(this);
        splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;
        return this.parent;
      }

      // Creates a node

      // `name` name of the node
      // `attributes` an object containing name/value pairs of attributes
      // `text` element text
      node(name, attributes, text) {
        var child;
        if (name != null) {
          name = getValue(name);
        }
        attributes || (attributes = {});
        attributes = getValue(attributes);
        // swap argument order: text <-> attributes
        if (!isObject(attributes)) {
          [text, attributes] = [attributes, text];
        }
        child = new XMLElement(this, name, attributes);
        if (text != null) {
          child.text(text);
        }
        this.children.push(child);
        return child;
      }

      // Creates a text node

      // `value` element text
      text(value) {
        var child;
        if (isObject(value)) {
          this.element(value);
        }
        child = new XMLText(this, value);
        this.children.push(child);
        return this;
      }

      // Creates a CDATA node

      // `value` element text without CDATA delimiters
      cdata(value) {
        var child;
        child = new XMLCData(this, value);
        this.children.push(child);
        return this;
      }

      // Creates a comment node

      // `value` comment text
      comment(value) {
        var child;
        child = new XMLComment(this, value);
        this.children.push(child);
        return this;
      }

      // Creates a comment node before the current node

      // `value` comment text
      commentBefore(value) {
        var child, i, removed;
        // temporarily remove children starting *with* this
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        // add the new child
        child = this.parent.comment(value);
        // add back removed children after new child
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      }

      // Creates a comment node after the current node

      // `value` comment text
      commentAfter(value) {
        var child, i, removed;
        // temporarily remove children starting *after* this
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        // add the new child
        child = this.parent.comment(value);
        // add back removed children after new child
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      }

      // Adds unescaped raw text

      // `value` text
      raw(value) {
        var child;
        child = new XMLRaw(this, value);
        this.children.push(child);
        return this;
      }

      // Adds a dummy node
      dummy() {
        var child;
        child = new XMLDummy(this);
        // Normally when a new node is created it is added to the child node collection.
        // However, dummy nodes are never added to the XML tree. They are created while
        // converting JS objects to XML nodes in order not to break the recursive function
        // chain. They can be thought of as invisible nodes. They can be traversed through
        // by using prev(), next(), up(), etc. functions but they do not exists in the tree.

        // @children.push child
        return child;
      }

      // Adds a processing instruction

      // `target` instruction target
      // `value` instruction value
      instruction(target, value) {
        var insTarget, insValue, instruction, j, len;
        if (target != null) {
          target = getValue(target);
        }
        if (value != null) {
          value = getValue(value);
        }
        if (Array.isArray(target)) { // expand if array
          for (j = 0, len = target.length; j < len; j++) {
            insTarget = target[j];
            this.instruction(insTarget);
          }
        } else if (isObject(target)) { // expand if object
          for (insTarget in target) {
            if (!hasProp.call(target, insTarget)) continue;
            insValue = target[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          instruction = new XMLProcessingInstruction(this, target, value);
          this.children.push(instruction);
        }
        return this;
      }

      // Creates a processing instruction node before the current node

      // `target` instruction target
      // `value` instruction value
      instructionBefore(target, value) {
        var child, i, removed;
        // temporarily remove children starting *with* this
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        // add the new child
        child = this.parent.instruction(target, value);
        // add back removed children after new child
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      }

      // Creates a processing instruction node after the current node

      // `target` instruction target
      // `value` instruction value
      instructionAfter(target, value) {
        var child, i, removed;
        // temporarily remove children starting *after* this
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        // add the new child
        child = this.parent.instruction(target, value);
        // add back removed children after new child
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      }

      // Creates the xml declaration

      // `version` A version number string, e.g. 1.0
      // `encoding` Encoding declaration, e.g. UTF-8
      // `standalone` standalone document declaration: true or false
      declaration(version, encoding, standalone) {
        var doc, xmldec;
        doc = this.document();
        xmldec = new XMLDeclaration(doc, version, encoding, standalone);
        // Replace XML declaration if exists, otherwise insert at top
        if (doc.children.length === 0) {
          doc.children.unshift(xmldec);
        } else if (doc.children[0].type === NodeType.Declaration) {
          doc.children[0] = xmldec;
        } else {
          doc.children.unshift(xmldec);
        }
        return doc.root() || doc;
      }

      // Creates the document type declaration

      // `pubID` the public identifier of the external subset
      // `sysID` the system identifier of the external subset
      dtd(pubID, sysID) {
        var child, doc, doctype, i, j, k, len, len1, ref1, ref2;
        doc = this.document();
        doctype = new XMLDocType(doc, pubID, sysID);
        ref1 = doc.children;
        // Replace DTD if exists
        for (i = j = 0, len = ref1.length; j < len; i = ++j) {
          child = ref1[i];
          if (child.type === NodeType.DocType) {
            doc.children[i] = doctype;
            return doctype;
          }
        }
        ref2 = doc.children;
        // insert before root node if the root node exists
        for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
          child = ref2[i];
          if (child.isRoot) {
            doc.children.splice(i, 0, doctype);
            return doctype;
          }
        }
        // otherwise append to end
        doc.children.push(doctype);
        return doctype;
      }

      // Gets the parent node
      up() {
        if (this.isRoot) {
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        }
        return this.parent;
      }

      // Gets the root node
      root() {
        var node;
        node = this;
        while (node) {
          if (node.type === NodeType.Document) {
            return node.rootObject;
          } else if (node.isRoot) {
            return node;
          } else {
            node = node.parent;
          }
        }
      }

      // Gets the node representing the XML document
      document() {
        var node;
        node = this;
        while (node) {
          if (node.type === NodeType.Document) {
            return node;
          } else {
            node = node.parent;
          }
        }
      }

      // Ends the document and converts string
      end(options) {
        return this.document().end(options);
      }

      // Gets the previous node
      prev() {
        var i;
        i = this.parent.children.indexOf(this);
        if (i < 1) {
          throw new Error("Already at the first node. " + this.debugInfo());
        }
        return this.parent.children[i - 1];
      }

      // Gets the next node
      next() {
        var i;
        i = this.parent.children.indexOf(this);
        if (i === -1 || i === this.parent.children.length - 1) {
          throw new Error("Already at the last node. " + this.debugInfo());
        }
        return this.parent.children[i + 1];
      }

      // Imports cloned root from another XML document

      // `doc` the XML document to insert nodes from
      importDocument(doc) {
        var child, clonedRoot, j, len, ref1;
        clonedRoot = doc.root().clone();
        clonedRoot.parent = this;
        clonedRoot.isRoot = false;
        this.children.push(clonedRoot);
        // set properties if imported element becomes the root node
        if (this.type === NodeType.Document) {
          clonedRoot.isRoot = true;
          clonedRoot.documentObject = this;
          this.rootObject = clonedRoot;
          // set dtd name
          if (this.children) {
            ref1 = this.children;
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              if (child.type === NodeType.DocType) {
                child.name = clonedRoot.name;
                break;
              }
            }
          }
        }
        return this;
      }

      
      // Returns debug string for this node
      debugInfo(name) {
        var ref1, ref2;
        name = name || this.name;
        if ((name == null) && !((ref1 = this.parent) != null ? ref1.name : void 0)) {
          return "";
        } else if (name == null) {
          return "parent: <" + this.parent.name + ">";
        } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {
          return "node: <" + name + ">";
        } else {
          return "node: <" + name + ">, parent: <" + this.parent.name + ">";
        }
      }

      // Aliases
      ele(name, attributes, text) {
        return this.element(name, attributes, text);
      }

      nod(name, attributes, text) {
        return this.node(name, attributes, text);
      }

      txt(value) {
        return this.text(value);
      }

      dat(value) {
        return this.cdata(value);
      }

      com(value) {
        return this.comment(value);
      }

      ins(target, value) {
        return this.instruction(target, value);
      }

      doc() {
        return this.document();
      }

      dec(version, encoding, standalone) {
        return this.declaration(version, encoding, standalone);
      }

      e(name, attributes, text) {
        return this.element(name, attributes, text);
      }

      n(name, attributes, text) {
        return this.node(name, attributes, text);
      }

      t(value) {
        return this.text(value);
      }

      d(value) {
        return this.cdata(value);
      }

      c(value) {
        return this.comment(value);
      }

      r(value) {
        return this.raw(value);
      }

      i(target, value) {
        return this.instruction(target, value);
      }

      u() {
        return this.up();
      }

      // can be deprecated in a future release
      importXMLBuilder(doc) {
        return this.importDocument(doc);
      }

      // Adds or modifies an attribute.

      // `name` attribute name
      // `value` attribute value
      attribute(name, value) {
        throw new Error("attribute() applies to element nodes only.");
      }

      att(name, value) {
        return this.attribute(name, value);
      }

      a(name, value) {
        return this.attribute(name, value);
      }

      // Removes an attribute

      // `name` attribute name
      removeAttribute(name) {
        throw new Error("attribute() applies to element nodes only.");
      }

      // DOM level 1 functions to be implemented later
      replaceChild(newChild, oldChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      removeChild(oldChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      appendChild(newChild) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      hasChildNodes() {
        return this.children.length !== 0;
      }

      cloneNode(deep) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      normalize() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      // DOM level 2
      isSupported(feature, version) {
        return true;
      }

      hasAttributes() {
        return this.attribs.length !== 0;
      }

      // DOM level 3 functions to be implemented later
      compareDocumentPosition(other) {
        var ref, res;
        ref = this;
        if (ref === other) {
          return 0;
        } else if (this.document() !== other.document()) {
          res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
          if (Math.random() < 0.5) {
            res |= DocumentPosition.Preceding;
          } else {
            res |= DocumentPosition.Following;
          }
          return res;
        } else if (ref.isAncestor(other)) {
          return DocumentPosition.Contains | DocumentPosition.Preceding;
        } else if (ref.isDescendant(other)) {
          return DocumentPosition.Contains | DocumentPosition.Following;
        } else if (ref.isPreceding(other)) {
          return DocumentPosition.Preceding;
        } else {
          return DocumentPosition.Following;
        }
      }

      isSameNode(other) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      lookupPrefix(namespaceURI) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      isDefaultNamespace(namespaceURI) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      lookupNamespaceURI(prefix) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      isEqualNode(node) {
        var i, j, ref1;
        if (node.nodeType !== this.nodeType) {
          return false;
        }
        if (node.children.length !== this.children.length) {
          return false;
        }
        for (i = j = 0, ref1 = this.children.length - 1; (0 <= ref1 ? j <= ref1 : j >= ref1); i = 0 <= ref1 ? ++j : --j) {
          if (!this.children[i].isEqualNode(node.children[i])) {
            return false;
          }
        }
        return true;
      }

      getFeature(feature, version) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      setUserData(key, data, handler) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      getUserData(key) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      // Returns true if other is an inclusive descendant of node,
      // and false otherwise.
      contains(other) {
        if (!other) {
          return false;
        }
        return other === this || this.isDescendant(other);
      }

      // An object A is called a descendant of an object B, if either A is 
      // a child of B or A is a child of an object C that is a descendant of B.
      isDescendant(node) {
        var child, isDescendantChild, j, len, ref1;
        ref1 = this.children;
        for (j = 0, len = ref1.length; j < len; j++) {
          child = ref1[j];
          if (node === child) {
            return true;
          }
          isDescendantChild = child.isDescendant(node);
          if (isDescendantChild) {
            return true;
          }
        }
        return false;
      }

      // An object A is called an ancestor of an object B if and only if
      // B is a descendant of A.
      isAncestor(node) {
        return node.isDescendant(this);
      }

      // An object A is preceding an object B if A and B are in the 
      // same tree and A comes before B in tree order.
      isPreceding(node) {
        var nodePos, thisPos;
        nodePos = this.treePosition(node);
        thisPos = this.treePosition(this);
        if (nodePos === -1 || thisPos === -1) {
          return false;
        } else {
          return nodePos < thisPos;
        }
      }

      // An object A is folllowing an object B if A and B are in the 
      // same tree and A comes after B in tree order.
      isFollowing(node) {
        var nodePos, thisPos;
        nodePos = this.treePosition(node);
        thisPos = this.treePosition(this);
        if (nodePos === -1 || thisPos === -1) {
          return false;
        } else {
          return nodePos > thisPos;
        }
      }

      // Returns the preorder position of the given node in the tree, or -1
      // if the node is not in the tree.
      treePosition(node) {
        var found, pos;
        pos = 0;
        found = false;
        this.foreachTreeNode(this.document(), function(childNode) {
          pos++;
          if (!found && childNode === node) {
            return found = true;
          }
        });
        if (found) {
          return pos;
        } else {
          return -1;
        }
      }

      
      // Depth-first preorder traversal through the XML tree
      foreachTreeNode(node, func) {
        var child, j, len, ref1, res;
        node || (node = this.document());
        ref1 = node.children;
        for (j = 0, len = ref1.length; j < len; j++) {
          child = ref1[j];
          if (res = func(child)) {
            return res;
          } else {
            res = this.foreachTreeNode(child, func);
            if (res) {
              return res;
            }
          }
        }
      }

    };

    // DOM level 1
    Object.defineProperty(XMLNode.prototype, 'nodeName', {
      get: function() {
        return this.name;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'nodeType', {
      get: function() {
        return this.type;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'nodeValue', {
      get: function() {
        return this.value;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'parentNode', {
      get: function() {
        return this.parent;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'childNodes', {
      get: function() {
        if (!this.childNodeList || !this.childNodeList.nodes) {
          this.childNodeList = new XMLNodeList(this.children);
        }
        return this.childNodeList;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'firstChild', {
      get: function() {
        return this.children[0] || null;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'lastChild', {
      get: function() {
        return this.children[this.children.length - 1] || null;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'previousSibling', {
      get: function() {
        var i;
        i = this.parent.children.indexOf(this);
        return this.parent.children[i - 1] || null;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'nextSibling', {
      get: function() {
        var i;
        i = this.parent.children.indexOf(this);
        return this.parent.children[i + 1] || null;
      }
    });

    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {
      get: function() {
        return this.document() || null;
      }
    });

    // DOM level 3
    Object.defineProperty(XMLNode.prototype, 'textContent', {
      get: function() {
        var child, j, len, ref1, str;
        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
          str = '';
          ref1 = this.children;
          for (j = 0, len = ref1.length; j < len; j++) {
            child = ref1[j];
            if (child.textContent) {
              str += child.textContent;
            }
          }
          return str;
        } else {
          return null;
        }
      },
      set: function(value) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    return XMLNode;

  }).call(this);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLNodeList.js":
/*!****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLNodeList.js ***!
  \****************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 2.4.1
(function() {
  // Represents a list of nodes
  var XMLNodeList;

  module.exports = XMLNodeList = (function() {
    class XMLNodeList {
      // Initializes a new instance of `XMLNodeList`
      // This is just a wrapper around an ordinary
      // JS array.

      // `nodes` the array containing nodes.
      constructor(nodes) {
        this.nodes = nodes;
      }

      // Creates and returns a deep clone of `this`

      clone() {
        // this class should not be cloned since it wraps
        // around a given array. The calling function should check
        // whether the wrapped array is null and supply a new array
        // (from the clone).
        return this.nodes = null;
      }

      // DOM Level 1
      item(index) {
        return this.nodes[index] || null;
      }

    };

    // DOM level 1
    Object.defineProperty(XMLNodeList.prototype, 'length', {
      get: function() {
        return this.nodes.length || 0;
      }
    });

    return XMLNodeList;

  }).call(this);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLCharacterData, XMLProcessingInstruction;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLCharacterData = __webpack_require__(/*! ./XMLCharacterData */ "./node_modules/xmlbuilder/lib/XMLCharacterData.js");

  // Represents a processing instruction
  module.exports = XMLProcessingInstruction = class XMLProcessingInstruction extends XMLCharacterData {
    // Initializes a new instance of `XMLProcessingInstruction`

    // `parent` the parent node
    // `target` instruction target
    // `value` instruction value
    constructor(parent, target, value) {
      super(parent);
      if (target == null) {
        throw new Error("Missing instruction target. " + this.debugInfo());
      }
      this.type = NodeType.ProcessingInstruction;
      this.target = this.stringify.insTarget(target);
      this.name = this.target;
      if (value) {
        this.value = this.stringify.insValue(value);
      }
    }

    // Creates and returns a deep clone of `this`
    clone() {
      return Object.create(this);
    }

    // Converts the XML fragment to string

    // `options.pretty` pretty prints the result
    // `options.indent` indentation for pretty print
    // `options.offset` how many indentations to add to every line for pretty print
    // `options.newline` newline sequence for pretty print
    toString(options) {
      return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
    }

    isEqualNode(node) {
      if (!super.isEqualNode(node)) {
        return false;
      }
      if (node.target !== this.target) {
        return false;
      }
      return true;
    }

  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLRaw.js":
/*!***********************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLRaw.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLNode, XMLRaw;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLNode = __webpack_require__(/*! ./XMLNode */ "./node_modules/xmlbuilder/lib/XMLNode.js");

  // Represents a  raw node
  module.exports = XMLRaw = class XMLRaw extends XMLNode {
    // Initializes a new instance of `XMLRaw`

    // `text` raw text
    constructor(parent, text) {
      super(parent);
      if (text == null) {
        throw new Error("Missing raw text. " + this.debugInfo());
      }
      this.type = NodeType.Raw;
      this.value = this.stringify.raw(text);
    }

    // Creates and returns a deep clone of `this`
    clone() {
      return Object.create(this);
    }

    // Converts the XML fragment to string

    // `options.pretty` pretty prints the result
    // `options.indent` indentation for pretty print
    // `options.offset` how many indentations to add to every line for pretty print
    // `options.newline` newline sequence for pretty print
    toString(options) {
      return this.options.writer.raw(this, this.options.writer.filterOptions(options));
    }

  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStreamWriter.js":
/*!********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStreamWriter.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, WriterState, XMLStreamWriter, XMLWriterBase,
    hasProp = {}.hasOwnProperty;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLWriterBase = __webpack_require__(/*! ./XMLWriterBase */ "./node_modules/xmlbuilder/lib/XMLWriterBase.js");

  WriterState = __webpack_require__(/*! ./WriterState */ "./node_modules/xmlbuilder/lib/WriterState.js");

  // Prints XML nodes to a stream
  module.exports = XMLStreamWriter = class XMLStreamWriter extends XMLWriterBase {
    // Initializes a new instance of `XMLStreamWriter`

    // `stream` output stream
    // `options.pretty` pretty prints the result
    // `options.indent` indentation string
    // `options.newline` newline sequence
    // `options.offset` a fixed number of indentations to add to every line
    // `options.allowEmpty` do not self close empty element tags
    // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF
    // `options.spaceBeforeSlash` add a space before the closing slash of empty elements
    constructor(stream, options) {
      super(options);
      this.stream = stream;
    }

    endline(node, options, level) {
      if (node.isLastRootNode && options.state === WriterState.CloseTag) {
        return '';
      } else {
        return super.endline(node, options, level);
      }
    }

    document(doc, options) {
      var child, i, j, k, len1, len2, ref, ref1, results;
      ref = doc.children;
      // set a flag so that we don't insert a newline after the last root level node 
      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
        child = ref[i];
        child.isLastRootNode = i === doc.children.length - 1;
      }
      options = this.filterOptions(options);
      ref1 = doc.children;
      results = [];
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        child = ref1[k];
        results.push(this.writeChildNode(child, options, 0));
      }
      return results;
    }

    cdata(node, options, level) {
      return this.stream.write(super.cdata(node, options, level));
    }

    comment(node, options, level) {
      return this.stream.write(super.comment(node, options, level));
    }

    declaration(node, options, level) {
      return this.stream.write(super.declaration(node, options, level));
    }

    docType(node, options, level) {
      var child, j, len1, ref;
      level || (level = 0);
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      this.stream.write(this.indent(node, options, level));
      this.stream.write('<!DOCTYPE ' + node.root().name);
      // external identifier
      if (node.pubID && node.sysID) {
        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
      } else if (node.sysID) {
        this.stream.write(' SYSTEM "' + node.sysID + '"');
      }
      // internal subset
      if (node.children.length > 0) {
        this.stream.write(' [');
        this.stream.write(this.endline(node, options, level));
        options.state = WriterState.InsideTag;
        ref = node.children;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          child = ref[j];
          this.writeChildNode(child, options, level + 1);
        }
        options.state = WriterState.CloseTag;
        this.stream.write(']');
      }
      // close tag
      options.state = WriterState.CloseTag;
      this.stream.write(options.spaceBeforeSlash + '>');
      this.stream.write(this.endline(node, options, level));
      options.state = WriterState.None;
      return this.closeNode(node, options, level);
    }

    element(node, options, level) {
      var att, attLen, child, childNodeCount, firstChildNode, j, len, len1, name, prettySuppressed, r, ratt, ref, ref1, ref2, rline;
      level || (level = 0);
      // open tag
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<' + node.name;
      // attributes
      if (options.pretty && options.width > 0) {
        len = r.length;
        ref = node.attribs;
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          att = ref[name];
          ratt = this.attribute(att, options, level);
          attLen = ratt.length;
          if (len + attLen > options.width) {
            rline = this.indent(node, options, level + 1) + ratt;
            r += this.endline(node, options, level) + rline;
            len = rline.length;
          } else {
            rline = ' ' + ratt;
            r += rline;
            len += rline.length;
          }
        }
      } else {
        ref1 = node.attribs;
        for (name in ref1) {
          if (!hasProp.call(ref1, name)) continue;
          att = ref1[name];
          r += this.attribute(att, options, level);
        }
      }
      this.stream.write(r);
      childNodeCount = node.children.length;
      firstChildNode = childNodeCount === 0 ? null : node.children[0];
      if (childNodeCount === 0 || node.children.every(function(e) {
        return (e.type === NodeType.Text || e.type === NodeType.Raw || e.type === NodeType.CData) && e.value === '';
      })) {
        // empty element
        if (options.allowEmpty) {
          this.stream.write('>');
          options.state = WriterState.CloseTag;
          this.stream.write('</' + node.name + '>');
        } else {
          options.state = WriterState.CloseTag;
          this.stream.write(options.spaceBeforeSlash + '/>');
        }
      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw || firstChildNode.type === NodeType.CData) && (firstChildNode.value != null)) {
        // do not indent text-only nodes
        this.stream.write('>');
        options.state = WriterState.InsideTag;
        options.suppressPrettyCount++;
        prettySuppressed = true;
        this.writeChildNode(firstChildNode, options, level + 1);
        options.suppressPrettyCount--;
        prettySuppressed = false;
        options.state = WriterState.CloseTag;
        this.stream.write('</' + node.name + '>');
      } else {
        this.stream.write('>' + this.endline(node, options, level));
        options.state = WriterState.InsideTag;
        ref2 = node.children;
        // inner tags
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          child = ref2[j];
          this.writeChildNode(child, options, level + 1);
        }
        // close tag
        options.state = WriterState.CloseTag;
        this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');
      }
      this.stream.write(this.endline(node, options, level));
      options.state = WriterState.None;
      return this.closeNode(node, options, level);
    }

    processingInstruction(node, options, level) {
      return this.stream.write(super.processingInstruction(node, options, level));
    }

    raw(node, options, level) {
      return this.stream.write(super.raw(node, options, level));
    }

    text(node, options, level) {
      return this.stream.write(super.text(node, options, level));
    }

    dtdAttList(node, options, level) {
      return this.stream.write(super.dtdAttList(node, options, level));
    }

    dtdElement(node, options, level) {
      return this.stream.write(super.dtdElement(node, options, level));
    }

    dtdEntity(node, options, level) {
      return this.stream.write(super.dtdEntity(node, options, level));
    }

    dtdNotation(node, options, level) {
      return this.stream.write(super.dtdNotation(node, options, level));
    }

  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStringWriter.js":
/*!********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStringWriter.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var XMLStringWriter, XMLWriterBase;

  XMLWriterBase = __webpack_require__(/*! ./XMLWriterBase */ "./node_modules/xmlbuilder/lib/XMLWriterBase.js");

  // Prints XML nodes as plain text
  module.exports = XMLStringWriter = class XMLStringWriter extends XMLWriterBase {
    // Initializes a new instance of `XMLStringWriter`

    // `options.pretty` pretty prints the result
    // `options.indent` indentation string
    // `options.newline` newline sequence
    // `options.offset` a fixed number of indentations to add to every line
    // `options.allowEmpty` do not self close empty element tags
    // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF
    // `options.spaceBeforeSlash` add a space before the closing slash of empty elements
    constructor(options) {
      super(options);
    }

    document(doc, options) {
      var child, i, len, r, ref;
      options = this.filterOptions(options);
      r = '';
      ref = doc.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        r += this.writeChildNode(child, options, 0);
      }
      // remove trailing newline
      if (options.pretty && r.slice(-options.newline.length) === options.newline) {
        r = r.slice(0, -options.newline.length);
      }
      return r;
    }

  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStringifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStringifier.js ***!
  \*******************************************************/
/***/ (function(module) {

// Generated by CoffeeScript 2.4.1
(function() {
  // Converts values to strings
  var XMLStringifier,
    hasProp = {}.hasOwnProperty;

  module.exports = XMLStringifier = (function() {
    class XMLStringifier {
      // Initializes a new instance of `XMLStringifier`

      // `options.version` The version number string of the XML spec to validate against, e.g. 1.0
      // `options.noDoubleEncoding` whether existing html entities are encoded: true or false
      // `options.stringify` a set of functions to use for converting values to strings
      // `options.noValidation` whether values will be validated and escaped or returned as is
      // `options.invalidCharReplacement` a character to replace invalid characters and disable character validation
      constructor(options) {
        var key, ref, value;
        // Checks whether the given string contains legal characters
        // Fails with an exception on error

        // `str` the string to check
        this.assertLegalChar = this.assertLegalChar.bind(this);
        // Checks whether the given string contains legal characters for a name
        // Fails with an exception on error

        // `str` the string to check
        this.assertLegalName = this.assertLegalName.bind(this);
        options || (options = {});
        this.options = options;
        if (!this.options.version) {
          this.options.version = '1.0';
        }
        ref = options.stringify || {};
        for (key in ref) {
          if (!hasProp.call(ref, key)) continue;
          value = ref[key];
          this[key] = value;
        }
      }

      // Defaults
      name(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalName('' + val || '');
      }

      text(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar(this.textEscape('' + val || ''));
      }

      cdata(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = '' + val || '';
        val = val.replace(']]>', ']]]]><![CDATA[>');
        return this.assertLegalChar(val);
      }

      comment(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = '' + val || '';
        if (val.match(/--/)) {
          throw new Error("Comment text cannot contain double-hypen: " + val);
        }
        return this.assertLegalChar(val);
      }

      raw(val) {
        if (this.options.noValidation) {
          return val;
        }
        return '' + val || '';
      }

      attValue(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar(this.attEscape(val = '' + val || ''));
      }

      insTarget(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      }

      insValue(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = '' + val || '';
        if (val.match(/\?>/)) {
          throw new Error("Invalid processing instruction value: " + val);
        }
        return this.assertLegalChar(val);
      }

      xmlVersion(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = '' + val || '';
        if (!val.match(/1\.[0-9]+/)) {
          throw new Error("Invalid version number: " + val);
        }
        return val;
      }

      xmlEncoding(val) {
        if (this.options.noValidation) {
          return val;
        }
        val = '' + val || '';
        if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
          throw new Error("Invalid encoding: " + val);
        }
        return this.assertLegalChar(val);
      }

      xmlStandalone(val) {
        if (this.options.noValidation) {
          return val;
        }
        if (val) {
          return "yes";
        } else {
          return "no";
        }
      }

      dtdPubID(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      }

      dtdSysID(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      }

      dtdElementValue(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      }

      dtdAttType(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      }

      dtdAttDefault(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      }

      dtdEntityValue(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      }

      dtdNData(val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      }

      assertLegalChar(str) {
        var regex, res;
        if (this.options.noValidation) {
          return str;
        }
        if (this.options.version === '1.0') {
          // Valid characters from https://www.w3.org/TR/xml/#charsets
          // any Unicode character, excluding the surrogate blocks, FFFE, and FFFF.
          // #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
          // This ES5 compatible Regexp has been generated using the "regenerate" NPM module:
          //   let xml_10_InvalidChars = regenerate()
          //     .addRange(0x0000, 0x0008)
          //     .add(0x000B, 0x000C)
          //     .addRange(0x000E, 0x001F)
          //     .addRange(0xD800, 0xDFFF)
          //     .addRange(0xFFFE, 0xFFFF)
          regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g;
          if (this.options.invalidCharReplacement !== void 0) {
            str = str.replace(regex, this.options.invalidCharReplacement);
          } else if (res = str.match(regex)) {
            throw new Error(`Invalid character in string: ${str} at index ${res.index}`);
          }
        } else if (this.options.version === '1.1') {
          // Valid characters from https://www.w3.org/TR/xml11/#charsets
          // any Unicode character, excluding the surrogate blocks, FFFE, and FFFF.
          // [#x1-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
          // This ES5 compatible Regexp has been generated using the "regenerate" NPM module:
          //   let xml_11_InvalidChars = regenerate()
          //     .add(0x0000)
          //     .addRange(0xD800, 0xDFFF)
          //     .addRange(0xFFFE, 0xFFFF)
          regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g;
          if (this.options.invalidCharReplacement !== void 0) {
            str = str.replace(regex, this.options.invalidCharReplacement);
          } else if (res = str.match(regex)) {
            throw new Error(`Invalid character in string: ${str} at index ${res.index}`);
          }
        }
        return str;
      }

      assertLegalName(str) {
        var regex;
        if (this.options.noValidation) {
          return str;
        }
        str = this.assertLegalChar(str);
        regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
        if (!str.match(regex)) {
          throw new Error(`Invalid character in name: ${str}`);
        }
        return str;
      }

      // Escapes special characters in text

      // See http://www.w3.org/TR/2000/WD-xml-c14n-20000119.html#charescaping

      // `str` the string to escape
      textEscape(str) {
        var ampregex;
        if (this.options.noValidation) {
          return str;
        }
        ampregex = this.options.noDoubleEncoding ? /(?!&(lt|gt|amp|apos|quot);)&/g : /&/g;
        return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
      }

      // Escapes special characters in attribute values

      // See http://www.w3.org/TR/2000/WD-xml-c14n-20000119.html#charescaping

      // `str` the string to escape
      attEscape(str) {
        var ampregex;
        if (this.options.noValidation) {
          return str;
        }
        ampregex = this.options.noDoubleEncoding ? /(?!&(lt|gt|amp|apos|quot);)&/g : /&/g;
        return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
      }

    };

    // strings to match while converting from JS objects
    XMLStringifier.prototype.convertAttKey = '@';

    XMLStringifier.prototype.convertPIKey = '?';

    XMLStringifier.prototype.convertTextKey = '#text';

    XMLStringifier.prototype.convertCDataKey = '#cdata';

    XMLStringifier.prototype.convertCommentKey = '#comment';

    XMLStringifier.prototype.convertRawKey = '#raw';

    return XMLStringifier;

  }).call(this);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLText.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLText.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, XMLCharacterData, XMLText;

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLCharacterData = __webpack_require__(/*! ./XMLCharacterData */ "./node_modules/xmlbuilder/lib/XMLCharacterData.js");

  // Represents a text node
  module.exports = XMLText = (function() {
    class XMLText extends XMLCharacterData {
      // Initializes a new instance of `XMLText`

      // `text` element text
      constructor(parent, text) {
        super(parent);
        if (text == null) {
          throw new Error("Missing element text. " + this.debugInfo());
        }
        this.name = "#text";
        this.type = NodeType.Text;
        this.value = this.stringify.text(text);
      }

      // Creates and returns a deep clone of `this`
      clone() {
        return Object.create(this);
      }

      // Converts the XML fragment to string

      // `options.pretty` pretty prints the result
      // `options.indent` indentation for pretty print
      // `options.offset` how many indentations to add to every line for pretty print
      // `options.newline` newline sequence for pretty print
      toString(options) {
        return this.options.writer.text(this, this.options.writer.filterOptions(options));
      }

      // DOM level 1 functions to be implemented later
      splitText(offset) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

      // DOM level 3 functions to be implemented later
      replaceWholeText(content) {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }

    };

    // DOM level 3
    Object.defineProperty(XMLText.prototype, 'isElementContentWhitespace', {
      get: function() {
        throw new Error("This DOM method is not implemented." + this.debugInfo());
      }
    });

    Object.defineProperty(XMLText.prototype, 'wholeText', {
      get: function() {
        var next, prev, str;
        str = '';
        prev = this.previousSibling;
        while (prev) {
          str = prev.data + str;
          prev = prev.previousSibling;
        }
        str += this.data;
        next = this.nextSibling;
        while (next) {
          str = str + next.data;
          next = next.nextSibling;
        }
        return str;
      }
    });

    return XMLText;

  }).call(this);

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLWriterBase.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLWriterBase.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign,
    hasProp = {}.hasOwnProperty;

  ({assign} = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"));

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ "./node_modules/xmlbuilder/lib/XMLDeclaration.js");

  XMLDocType = __webpack_require__(/*! ./XMLDocType */ "./node_modules/xmlbuilder/lib/XMLDocType.js");

  XMLCData = __webpack_require__(/*! ./XMLCData */ "./node_modules/xmlbuilder/lib/XMLCData.js");

  XMLComment = __webpack_require__(/*! ./XMLComment */ "./node_modules/xmlbuilder/lib/XMLComment.js");

  XMLElement = __webpack_require__(/*! ./XMLElement */ "./node_modules/xmlbuilder/lib/XMLElement.js");

  XMLRaw = __webpack_require__(/*! ./XMLRaw */ "./node_modules/xmlbuilder/lib/XMLRaw.js");

  XMLText = __webpack_require__(/*! ./XMLText */ "./node_modules/xmlbuilder/lib/XMLText.js");

  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js");

  XMLDummy = __webpack_require__(/*! ./XMLDummy */ "./node_modules/xmlbuilder/lib/XMLDummy.js");

  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js");

  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ "./node_modules/xmlbuilder/lib/XMLDTDElement.js");

  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js");

  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js");

  WriterState = __webpack_require__(/*! ./WriterState */ "./node_modules/xmlbuilder/lib/WriterState.js");

  // Base class for XML writers
  module.exports = XMLWriterBase = class XMLWriterBase {
    // Initializes a new instance of `XMLWriterBase`

    // `options.pretty` pretty prints the result
    // `options.indent` indentation string
    // `options.newline` newline sequence
    // `options.offset` a fixed number of indentations to add to every line
    // `options.width` maximum column width
    // `options.allowEmpty` do not self close empty element tags
    // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF
    // `options.spaceBeforeSlash` add a space before the closing slash of empty elements
    constructor(options) {
      var key, ref, value;
      options || (options = {});
      this.options = options;
      ref = options.writer || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this["_" + key] = this[key];
        this[key] = value;
      }
    }

    // Filters writer options and provides defaults

    // `options` writer options
    filterOptions(options) {
      var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
      options || (options = {});
      options = assign({}, this.options, options);
      filteredOptions = {
        writer: this
      };
      filteredOptions.pretty = options.pretty || false;
      filteredOptions.allowEmpty = options.allowEmpty || false;
      filteredOptions.indent = (ref = options.indent) != null ? ref : '  ';
      filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : '\n';
      filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
      filteredOptions.width = (ref3 = options.width) != null ? ref3 : 0;
      filteredOptions.dontPrettyTextNodes = (ref4 = (ref5 = options.dontPrettyTextNodes) != null ? ref5 : options.dontprettytextnodes) != null ? ref4 : 0;
      filteredOptions.spaceBeforeSlash = (ref6 = (ref7 = options.spaceBeforeSlash) != null ? ref7 : options.spacebeforeslash) != null ? ref6 : '';
      if (filteredOptions.spaceBeforeSlash === true) {
        filteredOptions.spaceBeforeSlash = ' ';
      }
      filteredOptions.suppressPrettyCount = 0;
      filteredOptions.user = {};
      filteredOptions.state = WriterState.None;
      return filteredOptions;
    }

    // Returns the indentation string for the current level

    // `node` current node
    // `options` writer options
    // `level` current indentation level
    indent(node, options, level) {
      var indentLevel;
      if (!options.pretty || options.suppressPrettyCount) {
        return '';
      } else if (options.pretty) {
        indentLevel = (level || 0) + options.offset + 1;
        if (indentLevel > 0) {
          return new Array(indentLevel).join(options.indent);
        }
      }
      return '';
    }

    // Returns the newline string

    // `node` current node
    // `options` writer options
    // `level` current indentation level
    endline(node, options, level) {
      if (!options.pretty || options.suppressPrettyCount) {
        return '';
      } else {
        return options.newline;
      }
    }

    attribute(att, options, level) {
      var r;
      this.openAttribute(att, options, level);
      if (options.pretty && options.width > 0) {
        r = att.name + '="' + att.value + '"';
      } else {
        r = ' ' + att.name + '="' + att.value + '"';
      }
      this.closeAttribute(att, options, level);
      return r;
    }

    cdata(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<![CDATA[';
      options.state = WriterState.InsideTag;
      r += node.value;
      options.state = WriterState.CloseTag;
      r += ']]>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    }

    comment(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!-- ';
      options.state = WriterState.InsideTag;
      r += node.value;
      options.state = WriterState.CloseTag;
      r += ' -->' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    }

    declaration(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<?xml';
      options.state = WriterState.InsideTag;
      r += ' version="' + node.version + '"';
      if (node.encoding != null) {
        r += ' encoding="' + node.encoding + '"';
      }
      if (node.standalone != null) {
        r += ' standalone="' + node.standalone + '"';
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '?>';
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    }

    docType(node, options, level) {
      var child, i, len1, r, ref;
      level || (level = 0);
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level);
      r += '<!DOCTYPE ' + node.root().name;
      // external identifier
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      // internal subset
      if (node.children.length > 0) {
        r += ' [';
        r += this.endline(node, options, level);
        options.state = WriterState.InsideTag;
        ref = node.children;
        for (i = 0, len1 = ref.length; i < len1; i++) {
          child = ref[i];
          r += this.writeChildNode(child, options, level + 1);
        }
        options.state = WriterState.CloseTag;
        r += ']';
      }
      // close tag
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>';
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    }

    element(node, options, level) {
      var att, attLen, child, childNodeCount, firstChildNode, i, j, len, len1, len2, name, prettySuppressed, r, ratt, ref, ref1, ref2, ref3, rline;
      level || (level = 0);
      prettySuppressed = false;
      // open tag
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<' + node.name;
      // attributes
      if (options.pretty && options.width > 0) {
        len = r.length;
        ref = node.attribs;
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          att = ref[name];
          ratt = this.attribute(att, options, level);
          attLen = ratt.length;
          if (len + attLen > options.width) {
            rline = this.indent(node, options, level + 1) + ratt;
            r += this.endline(node, options, level) + rline;
            len = rline.length;
          } else {
            rline = ' ' + ratt;
            r += rline;
            len += rline.length;
          }
        }
      } else {
        ref1 = node.attribs;
        for (name in ref1) {
          if (!hasProp.call(ref1, name)) continue;
          att = ref1[name];
          r += this.attribute(att, options, level);
        }
      }
      childNodeCount = node.children.length;
      firstChildNode = childNodeCount === 0 ? null : node.children[0];
      if (childNodeCount === 0 || node.children.every(function(e) {
        return (e.type === NodeType.Text || e.type === NodeType.Raw || e.type === NodeType.CData) && e.value === '';
      })) {
        // empty element
        if (options.allowEmpty) {
          r += '>';
          options.state = WriterState.CloseTag;
          r += '</' + node.name + '>' + this.endline(node, options, level);
        } else {
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + '/>' + this.endline(node, options, level);
        }
      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw || firstChildNode.type === NodeType.CData) && (firstChildNode.value != null)) {
        // do not indent text-only nodes
        r += '>';
        options.state = WriterState.InsideTag;
        options.suppressPrettyCount++;
        prettySuppressed = true;
        r += this.writeChildNode(firstChildNode, options, level + 1);
        options.suppressPrettyCount--;
        prettySuppressed = false;
        options.state = WriterState.CloseTag;
        r += '</' + node.name + '>' + this.endline(node, options, level);
      } else {
        // if ANY are a text node, then suppress pretty now
        if (options.dontPrettyTextNodes) {
          ref2 = node.children;
          for (i = 0, len1 = ref2.length; i < len1; i++) {
            child = ref2[i];
            if ((child.type === NodeType.Text || child.type === NodeType.Raw || child.type === NodeType.CData) && (child.value != null)) {
              options.suppressPrettyCount++;
              prettySuppressed = true;
              break;
            }
          }
        }
        // close the opening tag, after dealing with newline
        r += '>' + this.endline(node, options, level);
        options.state = WriterState.InsideTag;
        ref3 = node.children;
        // inner tags
        for (j = 0, len2 = ref3.length; j < len2; j++) {
          child = ref3[j];
          r += this.writeChildNode(child, options, level + 1);
        }
        // close tag
        options.state = WriterState.CloseTag;
        r += this.indent(node, options, level) + '</' + node.name + '>';
        if (prettySuppressed) {
          options.suppressPrettyCount--;
        }
        r += this.endline(node, options, level);
        options.state = WriterState.None;
      }
      this.closeNode(node, options, level);
      return r;
    }

    writeChildNode(node, options, level) {
      switch (node.type) {
        case NodeType.CData:
          return this.cdata(node, options, level);
        case NodeType.Comment:
          return this.comment(node, options, level);
        case NodeType.Element:
          return this.element(node, options, level);
        case NodeType.Raw:
          return this.raw(node, options, level);
        case NodeType.Text:
          return this.text(node, options, level);
        case NodeType.ProcessingInstruction:
          return this.processingInstruction(node, options, level);
        case NodeType.Dummy:
          return '';
        case NodeType.Declaration:
          return this.declaration(node, options, level);
        case NodeType.DocType:
          return this.docType(node, options, level);
        case NodeType.AttributeDeclaration:
          return this.dtdAttList(node, options, level);
        case NodeType.ElementDeclaration:
          return this.dtdElement(node, options, level);
        case NodeType.EntityDeclaration:
          return this.dtdEntity(node, options, level);
        case NodeType.NotationDeclaration:
          return this.dtdNotation(node, options, level);
        default:
          throw new Error("Unknown XML node type: " + node.constructor.name);
      }
    }

    processingInstruction(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<?';
      options.state = WriterState.InsideTag;
      r += node.target;
      if (node.value) {
        r += ' ' + node.value;
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '?>';
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    }

    raw(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level);
      options.state = WriterState.InsideTag;
      r += node.value;
      options.state = WriterState.CloseTag;
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    }

    text(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level);
      options.state = WriterState.InsideTag;
      r += node.value;
      options.state = WriterState.CloseTag;
      r += this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    }

    dtdAttList(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!ATTLIST';
      options.state = WriterState.InsideTag;
      r += ' ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
      if (node.defaultValueType !== '#DEFAULT') {
        r += ' ' + node.defaultValueType;
      }
      if (node.defaultValue) {
        r += ' "' + node.defaultValue + '"';
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    }

    dtdElement(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!ELEMENT';
      options.state = WriterState.InsideTag;
      r += ' ' + node.name + ' ' + node.value;
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    }

    dtdEntity(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!ENTITY';
      options.state = WriterState.InsideTag;
      if (node.pe) {
        r += ' %';
      }
      r += ' ' + node.name;
      if (node.value) {
        r += ' "' + node.value + '"';
      } else {
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        if (node.nData) {
          r += ' NDATA ' + node.nData;
        }
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    }

    dtdNotation(node, options, level) {
      var r;
      this.openNode(node, options, level);
      options.state = WriterState.OpenTag;
      r = this.indent(node, options, level) + '<!NOTATION';
      options.state = WriterState.InsideTag;
      r += ' ' + node.name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.pubID) {
        r += ' PUBLIC "' + node.pubID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      options.state = WriterState.CloseTag;
      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);
      options.state = WriterState.None;
      this.closeNode(node, options, level);
      return r;
    }

    openNode(node, options, level) {}

    closeNode(node, options, level) {}

    openAttribute(att, options, level) {}

    closeAttribute(att, options, level) {}

  };

}).call(this);


/***/ }),

/***/ "./node_modules/xmlbuilder/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/xmlbuilder/lib/index.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 2.4.1
(function() {
  var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction;

  ({assign, isFunction} = __webpack_require__(/*! ./Utility */ "./node_modules/xmlbuilder/lib/Utility.js"));

  XMLDOMImplementation = __webpack_require__(/*! ./XMLDOMImplementation */ "./node_modules/xmlbuilder/lib/XMLDOMImplementation.js");

  XMLDocument = __webpack_require__(/*! ./XMLDocument */ "./node_modules/xmlbuilder/lib/XMLDocument.js");

  XMLDocumentCB = __webpack_require__(/*! ./XMLDocumentCB */ "./node_modules/xmlbuilder/lib/XMLDocumentCB.js");

  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ "./node_modules/xmlbuilder/lib/XMLStringWriter.js");

  XMLStreamWriter = __webpack_require__(/*! ./XMLStreamWriter */ "./node_modules/xmlbuilder/lib/XMLStreamWriter.js");

  NodeType = __webpack_require__(/*! ./NodeType */ "./node_modules/xmlbuilder/lib/NodeType.js");

  WriterState = __webpack_require__(/*! ./WriterState */ "./node_modules/xmlbuilder/lib/WriterState.js");

  // Creates a new document and returns the root node for
  // chain-building the document tree

  // `name` name of the root element

  // `xmldec.version` A version number string, e.g. 1.0
  // `xmldec.encoding` Encoding declaration, e.g. UTF-8
  // `xmldec.standalone` standalone document declaration: true or false

  // `doctype.pubID` public identifier of the external subset
  // `doctype.sysID` system identifier of the external subset

  // `options.headless` whether XML declaration and doctype will be included:
  //     true or false
  // `options.keepNullNodes` whether nodes with null values will be kept
  //     or ignored: true or false
  // `options.keepNullAttributes` whether attributes with null values will be
  //     kept or ignored: true or false
  // `options.ignoreDecorators` whether decorator strings will be ignored when
  //     converting JS objects: true or false
  // `options.separateArrayItems` whether array items are created as separate
  //     nodes when passed as an object value: true or false
  // `options.noDoubleEncoding` whether existing html entities are encoded:
  //     true or false
  // `options.stringify` a set of functions to use for converting values to
  //     strings
  // `options.writer` the default XML writer to use for converting nodes to
  //     string. If the default writer is not set, the built-in XMLStringWriter
  //     will be used instead.
  module.exports.create = function(name, xmldec, doctype, options) {
    var doc, root;
    if (name == null) {
      throw new Error("Root element needs a name.");
    }
    options = assign({}, xmldec, doctype, options);
    // create the document node
    doc = new XMLDocument(options);
    // add the root node
    root = doc.element(name);
    // prolog
    if (!options.headless) {
      doc.declaration(options);
      if ((options.pubID != null) || (options.sysID != null)) {
        doc.dtd(options);
      }
    }
    return root;
  };

  // Creates a new document and returns the document node for
  // chain-building the document tree

  // `options.keepNullNodes` whether nodes with null values will be kept
  //     or ignored: true or false
  // `options.keepNullAttributes` whether attributes with null values will be
  //     kept or ignored: true or false
  // `options.ignoreDecorators` whether decorator strings will be ignored when
  //     converting JS objects: true or false
  // `options.separateArrayItems` whether array items are created as separate
  //     nodes when passed as an object value: true or false
  // `options.noDoubleEncoding` whether existing html entities are encoded:
  //     true or false
  // `options.stringify` a set of functions to use for converting values to
  //     strings
  // `options.writer` the default XML writer to use for converting nodes to
  //     string. If the default writer is not set, the built-in XMLStringWriter
  //     will be used instead.

  // `onData` the function to be called when a new chunk of XML is output. The
  //          string containing the XML chunk is passed to `onData` as its single
  //          argument.
  // `onEnd`  the function to be called when the XML document is completed with
  //          `end`. `onEnd` does not receive any arguments.
  module.exports.begin = function(options, onData, onEnd) {
    if (isFunction(options)) {
      [onData, onEnd] = [options, onData];
      options = {};
    }
    if (onData) {
      return new XMLDocumentCB(options, onData, onEnd);
    } else {
      return new XMLDocument(options);
    }
  };

  module.exports.stringWriter = function(options) {
    return new XMLStringWriter(options);
  };

  module.exports.streamWriter = function(stream, options) {
    return new XMLStreamWriter(stream, options);
  };

  module.exports.implementation = new XMLDOMImplementation();

  module.exports.nodeType = NodeType;

  module.exports.writerState = WriterState;

}).call(this);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*******************!*\
  !*** ./worker.ts ***!
  \*******************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_chords__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/chords */ "./src/chords.ts");
/* harmony import */ var _src_musicxmlgen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/musicxmlgen */ "./src/musicxmlgen.ts");
/* harmony import */ var _src_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/utils */ "./src/utils.ts");



(0,_src_chords__WEBPACK_IMPORTED_MODULE_0__.buildTables)();
self.onmessage = (event) => {
    const params = new _src_utils__WEBPACK_IMPORTED_MODULE_2__.MainMusicParams(JSON.parse(event.data.params || "{}"));
    if (event.data.newMelody) {
        (0,_src_chords__WEBPACK_IMPORTED_MODULE_0__.makeMelody)(self.divisionedNotes, params);
        console.groupCollapsed("xml");
        const scoreXML = (0,_src_musicxmlgen__WEBPACK_IMPORTED_MODULE_1__.toXml)(self.divisionedNotes, params);
        console.groupEnd();
        self.postMessage({ xml: scoreXML });
        return;
    }
    if (event.data.giveUp) {
        self.giveUP = true;
        return;
    }
    let promise;
    const progressCallback = (currentBeat, richNotes) => {
        if (currentBeat != null && richNotes && richNotes[0] && richNotes[0].chord) {
            self.postMessage({ progress: { currentBeat, chord: richNotes[0].chord.toString() } });
        }
        if (self.giveUP) {
            return "giveUP";
        }
    };
    (0,_src_chords__WEBPACK_IMPORTED_MODULE_0__.makeMusic)(params, progressCallback).then((result) => {
        const divisionedNotes = result.divisionedNotes;
        if (Object.keys(divisionedNotes).length === 0) {
            return;
        }
        self.divisionedNotes = divisionedNotes;
        console.groupCollapsed("xml");
        const scoreXML = (0,_src_musicxmlgen__WEBPACK_IMPORTED_MODULE_1__.toXml)(divisionedNotes, params);
        console.groupEnd();
        self.postMessage({ xml: scoreXML });
    }).catch((err) => {
        console.error(err);
        self.postMessage({ error: err });
    });
};

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUcsU0FBUztBQUM1RTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxrQkFBa0Isc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrREFBa0Q7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQixFQUFFLGFBQWEsR0FBRyxXQUFXO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVSxHQUFHLGFBQWEsR0FBRywrQkFBK0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQ0FBZ0M7QUFDbkUsMENBQTBDLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGlDQUFpQyxNQUFNLEdBQUcsUUFBUSxHQUFHLHlCQUF5QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDRCQUE0QjtBQUM1QjtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyw2Q0FBNkM7QUFDN0M7QUFDQSx1Q0FBdUM7QUFDdkMsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyw2Q0FBNkM7QUFDN0M7QUFDQSxzQ0FBc0M7QUFDdEMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1QkFBdUIsRUFBRSxhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsYUFBYTs7QUFFL0QsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JxRzBEO0FBRVk7QUFVdkUsTUFBTSxjQUFjLEdBQUcsQ0FBQyxLQUFhLEVBQUUsTUFBbUIsRUFBVyxFQUFFO0lBQ25FLE1BQU0sTUFBTSxHQUFHLElBQUksR0FBRyxFQUFjO0lBQ3BDLHVCQUF1QjtJQUN2QixLQUFLLE1BQU0sU0FBUyxJQUFJLE1BQU0sQ0FBQyxhQUFhLEVBQUU7UUFDMUMsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqRCxJQUFJLFFBQVEsQ0FBQyxPQUFPLEVBQUU7WUFDbEIsS0FBSyxJQUFJLFFBQVEsR0FBQyxDQUFDLEVBQUUsUUFBUSxHQUFHLEVBQUUsRUFBRSxRQUFRLEVBQUUsRUFBRTtnQkFDNUMsTUFBTSxLQUFLLEdBQUcsSUFBSSxnREFBSyxDQUFDLEVBQUMsR0FBRyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUseURBQWMsQ0FBQyxTQUFTLENBQUMsRUFBQyxDQUFDO2dCQUM3RSxNQUFNLENBQUMsR0FBRyxDQUFDO29CQUNQLEdBQUcsRUFBRSxRQUFRO29CQUNiLFlBQVksRUFBRSxTQUFTO29CQUN2QixTQUFTLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO2lCQUN0QyxDQUFDO2FBQ25CO1NBQ0o7S0FDSjtJQUNELEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxFQUFFO1FBQ3BCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRO1FBQzlCLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRTtnQkFDckMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7YUFDdkI7U0FDSjtLQUNKO0lBRUQsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDO0lBQ2YsS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLEVBQUU7UUFDeEIsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLGdEQUFLLENBQUMsRUFBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUseURBQWMsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLEVBQUMsQ0FBQyxDQUFDO0tBQ3RGO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDZixDQUFDO0FBR00sTUFBTSxrQkFBa0IsR0FBRyxDQUFDLE1BTWxDLEVBR0UsRUFBRTtJQUNELE1BQU0sRUFBQyxjQUFjLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUMsR0FBRyxNQUFNLENBQUM7SUFDbEYsc0VBQXNFO0lBQ3RFLE1BQU0sc0JBQXNCLEdBQUcsY0FBYyxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUM7SUFFbEUsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDO0lBQ2YsS0FBSyxNQUFNLEtBQUssSUFBSSxzQkFBc0IsRUFBRTtRQUN4QyxHQUFHLENBQUMsSUFBSSxDQUFDO1lBQ0wsS0FBSztZQUNMLE9BQU8sRUFBRSxDQUFDO1NBQ2IsQ0FBQztLQUNMO0lBRUQsTUFBTSxDQUFDLEdBQUcsQ0FBQyx3QkFBd0IsRUFBRSxzQkFBc0IsQ0FBQztJQUU1RCwrREFBK0Q7SUFDL0QsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUN4QixNQUFNLFFBQVEsR0FBRyxjQUFjLEdBQUcsQ0FBQyxDQUFDLEdBQUcsK0NBQVcsQ0FBQztRQUNuRCxJQUFJLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDaEMsU0FBUztTQUNaO1FBQ0QsTUFBTSxLQUFLLEdBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztRQUMxRSxNQUFNLGVBQWUsR0FBRyxjQUFjLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQztRQUNyRCxLQUFLLE1BQU0sY0FBYyxJQUFJLEdBQUcsRUFBRTtZQUM5QixNQUFNLEtBQUssR0FBRyxlQUFlLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDbEYsSUFBSSxLQUFLLElBQUksQ0FBQyxDQUFDLEVBQUU7Z0JBQ2IsMkNBQTJDO2dCQUMzQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ1IsY0FBYyxDQUFDLE9BQU8sSUFBSSxFQUFFLEVBQUUsOEJBQThCO2lCQUMvRDtxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ2YsY0FBYyxDQUFDLE9BQU8sSUFBSSxFQUFFO2lCQUMvQjtxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ2YsY0FBYyxDQUFDLE9BQU8sSUFBSSxDQUFDO2lCQUM5QjtxQkFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ2YsY0FBYyxDQUFDLE9BQU8sSUFBSSxDQUFDO2lCQUM5QjtnQkFDRCxNQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxjQUFjLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxFQUFDLGdDQUFnQyxFQUFFLFFBQVEsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO2FBQzFIO1NBQ0o7S0FDSjtJQUNELE1BQU0sQ0FBQyxLQUFLLENBQUMsa0JBQWtCLEVBQUUsR0FBRyxDQUFDO0lBRXJDLE9BQU8sR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDLENBQUM7QUFDakQsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdGc0I7QUFDYTtBQUNtRTtBQUNqRDtBQUNUO0FBQ047QUFDTTtBQUNGO0FBQ1k7QUFHdkQsTUFBTSxPQUFPLEdBQUcsQ0FBTyxFQUFVLEVBQWlCLEVBQUU7SUFDaEQsT0FBTyxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMzRCxDQUFDO0FBRUQsTUFBTSxVQUFVLEdBQUcsQ0FBTyxVQUEyQixFQUFFLG1CQUF1QyxJQUFJLEVBQWdDLEVBQUU7SUFDaEkseUJBQXlCO0lBRXpCLE1BQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDO0lBRWhELE1BQU0sUUFBUSxHQUFHLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUMxQyxtSUFBbUk7SUFDbkksSUFBSSxZQUFZLEdBQUcsSUFBSSxnREFBSyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUVwRCxJQUFJLE1BQU0sR0FBd0IsRUFBRSxDQUFDO0lBQ3JDLElBQUksUUFBUSxHQUFrQixFQUFFLENBQUM7SUFDakMsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDO0lBQ3JCLElBQUksaUJBQWlCLEdBQXFCLElBQUksQ0FBQztJQUMvQyxNQUFNLFNBQVMsR0FBZ0IsRUFBRSxDQUFDO0lBQ2xDLE1BQU0sVUFBVSxHQUFXLEVBQUUsQ0FBQztJQUU5QixzQ0FBc0M7SUFDdEMsNkVBQTZFO0lBQzdFLElBQUk7SUFFSixLQUFLLElBQUksUUFBUSxHQUFHLENBQUMsRUFBRSxRQUFRLEdBQUcsUUFBUSxHQUFHLCtDQUFXLEVBQUUsUUFBUSxJQUFJLCtDQUFXLEVBQUU7UUFDL0UsTUFBTSxNQUFNLEdBQUcsVUFBVSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3pELE1BQU0sNEJBQTRCLEdBQUcsTUFBTSxDQUFDLG9CQUFvQixDQUFDO1FBQ2pFLE9BQU8sQ0FBQyxjQUFjLENBQUMsVUFBVSxFQUFFLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUM1SCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRywrQ0FBVyxDQUFDLENBQUM7UUFDdkQsT0FBTyxDQUFDLEdBQUcsQ0FBQyw4QkFBOEIsRUFBRSw0QkFBNEIsQ0FBQyxDQUFDO1FBRTFFLE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDckQsSUFBSSxlQUFlLEdBQUcsSUFBSSxDQUFDO1FBQzNCLElBQUksV0FBVyxFQUFFO1lBQ2IsZUFBZSxHQUFHLFVBQVUsQ0FBQyxXQUFXLENBQUMsT0FBNEIsQ0FBQyxDQUFDO1NBQzFFO2FBQU07WUFDSCxlQUFlLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQztTQUN4QztRQUNELElBQUksV0FBVyxHQUFHLEtBQUssQ0FBQztRQUN4QixNQUFNLGVBQWUsR0FBRyxJQUFJLCtEQUFvQixDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUM7UUFDdEUsSUFBSSxRQUFRLEdBQW9CLElBQUksQ0FBQztRQUNyQyxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDaEIsSUFBSSxRQUFRLEdBQW9CLElBQUksQ0FBQztRQUNyQyxJQUFJLFdBQVcsR0FBb0IsSUFBSSxDQUFDO1FBRXhDLE1BQU0sV0FBVyxHQUFnQixFQUFFLENBQUM7UUFFcEMsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ25CLElBQUksVUFBVSxHQUtWO1lBQ0EsS0FBSyxFQUFFLEVBQUU7WUFDVCxPQUFPLEVBQUUsR0FBRztZQUNaLEtBQUssRUFBRSxZQUFZO1lBQ25CLEtBQUssRUFBRSxJQUFJO1NBQ2QsQ0FBQztRQUVGLElBQUksY0FBYyxHQUFHLENBQUMsR0FBRyxDQUFDO1FBQzFCLElBQUksYUFBYSxHQUFHLENBQUMsQ0FBQztRQUN0QixJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFFbkIsT0FBTyxDQUFDLFdBQVcsRUFBRTtZQUNqQixVQUFVLEVBQUUsQ0FBQztZQUNiLElBQUksVUFBVSxHQUFHLEdBQUcsRUFBRTtnQkFDbEIsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDdEI7WUFDRCxJQUFJLFVBQVUsR0FBRyxJQUFJLEVBQUU7Z0JBQ25CLE9BQU8sQ0FBQyxHQUFHLENBQUMsaURBQWlELEVBQUUsY0FBYyxDQUFDLENBQUM7Z0JBQy9FLE1BQU0sR0FBRyxJQUFJLENBQUM7Z0JBQ2QsTUFBTTthQUNUO1lBQ0QsSUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2xELElBQUksVUFBVSxHQUFHLEdBQUcsSUFBSSxDQUFDLEVBQUU7Z0JBQ3ZCLDREQUE0RDtnQkFDNUQsZUFBZSxDQUFDLE9BQU8sRUFBRSxDQUFDO2FBQzdCO1lBQ0QsUUFBUSxHQUFHLGVBQWUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUN0QyxNQUFNLFdBQVcsR0FBRyxJQUFJLDZDQUFNLEVBQUUsQ0FBQztZQUNqQyxJQUFJLGFBQWEsQ0FBQztZQUNsQixJQUFJLGVBQWUsQ0FBQztZQUVwQixJQUFJLDRCQUE0QixJQUFJLENBQUMsRUFBRTtnQkFDbkMseUJBQXlCO2dCQUN6QixXQUFXLEdBQUcsSUFBSSxDQUFDO2dCQUNuQixXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQztnQkFDL0IsUUFBUSxHQUFHLFNBQVMsQ0FBQztnQkFDckIsT0FBTyxHQUFHLENBQUMsQ0FBQzthQUNmO2lCQUNJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQ2hCLFdBQVcsQ0FBQyxHQUFHLENBQUMsNERBQTRELENBQUMsQ0FBQztnQkFDOUUsSUFBSSxVQUFVLENBQUMsT0FBTyxHQUFHLEVBQUUsSUFBSSxRQUFRLElBQUksQ0FBQyxFQUFFO29CQUMxQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7b0JBQ25CLE9BQU8sQ0FBQyxjQUFjLENBQUMsc0NBQXNDLENBQUMsQ0FBQztvQkFDL0QsV0FBVyxHQUFHLElBQUksQ0FBQztvQkFDbkIsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUMxQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUN0QyxRQUFRLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQztvQkFDNUIsSUFBSSxDQUFDLFNBQVMsRUFBRTt3QkFDWixTQUFTLEdBQUcsUUFBUSxDQUFDO3FCQUN4QjtvQkFDRCxPQUFPLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQztpQkFDaEM7cUJBQU07b0JBQ0gsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO29CQUNuQixPQUFPLENBQUMsR0FBRyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7b0JBQzFELCtDQUErQztvQkFDL0MsV0FBVyxHQUFHLEtBQUssQ0FBQztvQkFDcEIsTUFBTSxHQUFHLElBQUksQ0FBQztvQkFDZCxNQUFNO2lCQUNUO2FBQ0o7aUJBQU07Z0JBQ0gsTUFBTSxvQkFBb0IsR0FBRyxJQUFJLDZDQUFNLENBQUMsV0FBVyxDQUFDO2dCQUNwRCxlQUFlLEdBQUcsb0VBQWtCLENBQUM7b0JBQ2pDLGNBQWMsRUFBRSxRQUFRO29CQUN4QixtQkFBbUIsRUFBRSxNQUFNO29CQUMzQixNQUFNLEVBQUUsTUFBTTtvQkFDZCxXQUFXLEVBQUUsUUFBUSxDQUFDLEtBQUs7b0JBQzNCLE1BQU0sRUFBRSxvQkFBb0I7aUJBQy9CLENBQUM7Z0JBQ0YsSUFBSSxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDdkIsSUFBSSxRQUFRLEdBQUcsV0FBVyxHQUFHLENBQUMsSUFBSSw0QkFBNEIsR0FBRyxDQUFDLElBQUksV0FBVyxHQUFHLENBQUMsRUFBRTt3QkFDbkYsZ0RBQWdEO3dCQUNoRCxlQUFlLEdBQUcsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7cUJBQy9FO2lCQUNKO2dCQUNELElBQUksZUFBZSxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7b0JBQzdCLFNBQVM7aUJBQ1o7Z0JBQ0QsYUFBYSxHQUFHLDBEQUFhLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksNkNBQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxRQUFRLEdBQUcsV0FBVyxDQUFDO2FBQzNIO1lBRUQsSUFBSSxDQUFDLFdBQVcsRUFBRTtnQkFDbEIsS0FBSyxNQUFNLGVBQWUsSUFBSSxhQUFhLEVBQUU7b0JBQ3pDLElBQUksV0FBVyxFQUFFO3dCQUNiLE1BQU07cUJBQ1Q7b0JBQ0QsTUFBTSxlQUFlLEdBQUcsSUFBSSw2Q0FBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO29CQUNoRCxlQUFlLENBQUMsS0FBSyxHQUFHLENBQUMsWUFBWSxFQUFFLEdBQUcsZUFBZSxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7b0JBQzNFLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFFLGtDQUFrQztvQkFDOUUsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDM0MsSUFBSSxXQUFXLEdBQUcsR0FBRyxDQUFDO29CQUN0QixLQUFLLE1BQU0sY0FBYyxJQUFJLGVBQWUsRUFBRTt3QkFDMUMsTUFBTSxXQUFXLEdBQUcsSUFBSSw2Q0FBTSxDQUFDLGVBQWUsQ0FBQzt3QkFDL0MsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLDZDQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7d0JBQ25ELFdBQVcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxRQUFRLEVBQUUsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQzt3QkFDckUsSUFBSSxXQUFXLEVBQUU7NEJBQ2IsTUFBTTt5QkFDVDt3QkFDRCxNQUFNLGFBQWEsR0FBRyxvREFBVSxDQUM1QixNQUFNLEVBQ04sV0FBVyxFQUNYLGNBQWMsQ0FBQyxLQUFLLEVBQ3BCLDRCQUE0QixFQUM1QixNQUFNLEVBQ04sa0JBQWtCLEVBQ2xCLFFBQVEsR0FBRyxXQUFXLEVBQ3RCLGVBQWUsQ0FBQyxhQUFhLEVBQzdCLGlCQUFpQixDQUNwQixDQUFDO3dCQUNGLGtCQUFrQixDQUFDLEtBQUssR0FBRzs0QkFDdkIsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLFFBQVEsRUFBRSxFQUFFLElBQUksRUFBRSxhQUFhLENBQUMsT0FBTzt5QkFDbEc7d0JBQ0QsS0FBSyxNQUFNLEtBQUssSUFBSSxNQUFNLENBQUMsYUFBYSxFQUFFOzRCQUN0QyxNQUFNLFlBQVksR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDOzRCQUNqRCxNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFLElBQUksR0FBRyxDQUFDLENBQUM7NEJBQ2hFLElBQUksUUFBUSxDQUFDLFNBQVMsSUFBSSxLQUFLLEVBQUU7Z0NBQzdCLGFBQWEsQ0FBQyxPQUFPLElBQUksQ0FBQyxVQUFDLFdBQVcsR0FBRyxFQUFFLENBQUMsRUFBSSxDQUFDLEVBQUMsR0FBRyxFQUFFLENBQUM7Z0NBQ3hELGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQzs2QkFDMUc7eUJBQ0o7d0JBQ0QsYUFBYSxDQUFDLE9BQU8sSUFBSSxjQUFjLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO3dCQUMxRixrQkFBa0IsQ0FBQyxHQUFHLENBQUMsaUJBQWlCLEVBQUUsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO3dCQUNqRSxJQUFJLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFOzRCQUN2QixJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUU7Z0NBQzVDLGFBQWEsQ0FBQyxPQUFPLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO2dDQUNyRSxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsd0JBQXdCLEVBQUUsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dDQUN4RSxJQUFJLFFBQVEsR0FBRyxXQUFXLEdBQUcsQ0FBQyxFQUFFO29DQUM1QixrQ0FBa0M7b0NBQ2xDLGFBQWEsQ0FBQyxPQUFPLElBQUksR0FBRyxDQUFDO2lDQUNoQztnQ0FDRCxJQUFJLDRCQUE0QixHQUFHLENBQUMsRUFBRTtvQ0FDbEMsZ0RBQWdEO29DQUNoRCxhQUFhLENBQUMsT0FBTyxJQUFJLEdBQUcsQ0FBQztpQ0FDaEM7Z0NBQ0QsSUFBSSxXQUFXLEdBQUcsQ0FBQyxFQUFFO29DQUNqQixzQ0FBc0M7b0NBQ3RDLGFBQWEsQ0FBQyxPQUFPLElBQUksR0FBRyxDQUFDO2lDQUNoQzs2QkFDSjt5QkFDSjt3QkFDRCxPQUFPLEdBQUcsYUFBYSxDQUFDLE9BQU8sQ0FBQzt3QkFFaEMsYUFBYSxHQUFHLEdBQUcsQ0FBQzt3QkFDcEIsNENBQTRDO3dCQUM1QyxtQ0FBbUM7d0JBQ25DLElBQUk7d0JBQ0osSUFBSSxRQUFRLEdBQUcsV0FBVyxHQUFHLENBQUMsRUFBRTs0QkFDNUIsWUFBWTs0QkFDWixhQUFhLEdBQUcsQ0FBQyxHQUFHO3lCQUN2Qjt3QkFDRCxJQUFJLDRCQUE0QixHQUFHLENBQUMsRUFBRTs0QkFDbEMsYUFBYSxHQUFHLENBQUMsR0FBRyxDQUFDO3lCQUN4Qjs2QkFBTTs0QkFDSCxhQUFhLElBQUksQ0FBQyxHQUFHLEdBQUcsYUFBYSxDQUFDLENBQUM7eUJBQzFDO3dCQUVELElBQUksZUFBZSxJQUFJLElBQUksRUFBRTs0QkFDekIsYUFBYSxHQUFHLFVBQVUsQ0FBQyxlQUFzQixDQUFDLENBQUM7NEJBQ25ELGFBQWEsSUFBSSxDQUFDLEdBQUcsR0FBRyxhQUFhLENBQUMsQ0FBQzt5QkFDMUM7d0JBRUQsSUFBSSxPQUFPLEdBQUcsV0FBVyxFQUFFOzRCQUN2QixXQUFXLEdBQUcsT0FBTyxDQUFDO3lCQUN6Qjt3QkFFRCxJQUFJLE9BQU8sR0FBRyxhQUFhLEVBQUU7NEJBQ3pCLFdBQVcsR0FBRyxJQUFJLENBQUM7NEJBQ25CLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDOzRCQUN2QyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsaUJBQWlCLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxhQUFhLENBQUMsQ0FBQzs0QkFDL0UsaUJBQWlCLEdBQUcsZUFBZSxDQUFDLGFBQWEsQ0FBQzs0QkFDbEQsTUFBTSxDQUFFLCtDQUErQzt5QkFDMUQ7NkJBQU07NEJBQ0gsSUFBSSxPQUFPLEdBQUcsVUFBVSxDQUFDLE9BQU8sRUFBRTtnQ0FDOUIsVUFBVSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7Z0NBQzdCLFVBQVUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dDQUNwRCxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDO2dDQUN0QyxVQUFVLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQzs2QkFDL0I7NEJBQ0Qsa0JBQWtCLENBQUMsR0FBRyxDQUFDLGdCQUFnQixFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsYUFBYSxDQUFDLENBQUM7NEJBQzlFLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEdBQUcsYUFBYSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLEdBQUcsYUFBYSxDQUFDLEVBQUU7Z0NBQzlFLGNBQWMsR0FBRyxPQUFPLENBQUM7NkJBQzVCOzRCQUNELElBQUksZ0JBQWdCLEVBQUU7Z0NBQ2xCLE1BQU0sTUFBTSxHQUFHLGdCQUFnQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztnQ0FDNUMsSUFBSSxNQUFNLEVBQUU7b0NBQ1IsMkNBQTJDO29DQUMzQyxRQUFRO29DQUNSLHVGQUF1RjtvQ0FDdkYsT0FBTyxNQUFNLENBQUM7aUNBQ2pCOzZCQUNKO3lCQUNKO3dCQUNELFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO3dCQUNwQyxXQUFXLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sRUFBRSxDQUFDLENBQUM7cUJBQ3hDLENBQUUsMkJBQTJCO29CQUM5QixlQUFlLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztvQkFDeEMsZUFBZSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxXQUFXLEVBQUUsQ0FBQyxDQUFDO29CQUM3QyxlQUFlLENBQUMsS0FBSyxFQUFFLENBQUM7aUJBQzNCLENBQUUsK0JBQStCO2FBQ2pDO1lBQ0QsV0FBVyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxRQUFRLENBQUMsUUFBUSxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxHQUFHLGFBQWEsR0FBRyxHQUFHLENBQUMsQ0FBQztTQUMvSSxDQUFFLFlBQVk7UUFDZixJQUFJLE1BQU0sRUFBRTtZQUNSLCtDQUErQztZQUMvQyxJQUFJLFFBQVEsSUFBSSxDQUFDLEVBQUU7Z0JBQ2YsUUFBUSxJQUFJLCtDQUFXLEdBQUcsQ0FBQyxDQUFDO2FBQy9CO1lBQ0QsU0FBUztTQUNaO1FBQ0QsSUFBSSxRQUFRLElBQUksSUFBSSxFQUFFO1lBQ2xCLE9BQU8sRUFBRSxDQUFDO1NBQ2I7UUFDRCxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3ZCLE1BQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUMzQyxJQUFJLFFBQVEsRUFBRTtZQUNWLFlBQVksR0FBRyxRQUFRLENBQUM7WUFDeEIsc0RBQXNEO1NBQ3pEO1FBQ0QsSUFBSSxRQUFRLEVBQUU7WUFDVixXQUFXLEdBQUcsUUFBUSxDQUFDO1NBQzFCO1FBQ0QsVUFBVSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoQyx5SEFBeUg7UUFDekgsTUFBTSxDQUFDLFdBQVcsR0FBRywrQ0FBVyxDQUFDLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDbEUsSUFBSSxFQUFFLElBQUk7WUFDVixTQUFTLEVBQUUsS0FBSztZQUNoQixRQUFRLEVBQUUsK0NBQVc7WUFDckIsS0FBSyxFQUFFLFFBQVE7WUFDZixLQUFLLEVBQUUsWUFBWTtZQUNuQixPQUFPLEVBQUUsT0FBTztZQUNoQixhQUFhLEVBQUUsR0FBRyxpQkFBaUIsRUFBRTtTQUN4QyxDQUFhLENBQUMsQ0FBQztRQUVoQixJQUFJLGdCQUFnQixFQUFFO1lBQ2xCLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsV0FBVyxHQUFHLCtDQUFXLENBQUMsQ0FBQyxDQUFDO1NBQ3BFO1FBRUQsU0FBUyxHQUFHLFFBQVEsQ0FBQztRQUVyQixTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdEMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDO1FBRS9CLGVBQWUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUMxQixPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7S0FDdEI7SUFFRCxPQUFPLE1BQU07QUFDakIsQ0FBQztBQUVNLFNBQWUsU0FBUyxDQUFDLE1BQXVCLEVBQUUsbUJBQXVDLElBQUk7O1FBQ2hHLElBQUksZUFBZSxHQUF3QixFQUFFLENBQUM7UUFDOUMsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ25CLE9BQU8sSUFBSSxFQUFFO1lBQ1QsVUFBVSxFQUFFLENBQUM7WUFDYixJQUFJLFVBQVUsR0FBRyxDQUFDLEVBQUU7Z0JBQ2hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsK0JBQStCLENBQUMsQ0FBQztnQkFDN0MsT0FBTztvQkFDSCxlQUFlLEVBQUUsRUFBRTtpQkFDdEI7YUFDSjtZQUNELGVBQWUsR0FBRyxNQUFNLFVBQVUsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztZQUM3RCxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtnQkFDMUMsTUFBTTthQUNUO1lBQ0QsTUFBTSxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztTQUM1RDtRQUVELHFGQUFxRjtRQUNyRiwwREFBYyxDQUFDLGVBQWUsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN4QywwQ0FBMEM7UUFDMUMsd0RBQVksQ0FBQyxlQUFlLEVBQUUsTUFBTSxDQUFDO1FBR3JDLE9BQU87WUFDSCxlQUFlLEVBQUUsZUFBZTtTQUNuQztJQUVMLENBQUM7Q0FBQTtBQUVNLFNBQVMsVUFBVSxDQUFDLGVBQW9DLEVBQUUsVUFBMkI7SUFDeEYsdUNBQXVDO0lBQ3ZDLE1BQU0sUUFBUSxHQUFHLFVBQVUsQ0FBQyxXQUFXLEVBQUU7SUFFekMsS0FBSyxJQUFJLFFBQVEsR0FBQyxDQUFDLEVBQUUsUUFBUSxHQUFHLFFBQVEsR0FBRywrQ0FBVyxFQUFFLFFBQVEsRUFBRSxFQUFFO1FBQ2hFLE1BQU0sTUFBTSxHQUFHLFFBQVEsR0FBRywrQ0FBVyxJQUFJLENBQUMsQ0FBQztRQUMzQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1QsZUFBZSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUU7U0FDakM7YUFBTSxJQUFJLGVBQWUsQ0FBQyxRQUFRLENBQUMsSUFBSSxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMxRSxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFO2dCQUN6QyxRQUFRLENBQUMsUUFBUSxHQUFHLCtDQUFXLENBQUM7Z0JBQ2hDLFFBQVEsQ0FBQyxHQUFHLEdBQUcsU0FBUyxDQUFDO1lBQzdCLENBQUMsQ0FBQztTQUNMO0tBRUo7SUFFRCxxRkFBcUY7SUFDckYsMERBQWMsQ0FBQyxlQUFlLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDNUMsMENBQTBDO0lBQzFDLHdEQUFZLENBQUMsZUFBZSxFQUFFLFVBQVUsQ0FBQztBQUM3QyxDQUFDO0FBRUQsd0RBQXdEO0FBQ3hELDBCQUEwQjtBQUMxQiwrQ0FBK0M7QUFFL0MsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQyw2QkFBNkI7QUFDN0IsbUNBQW1DO0FBQ25DLGdEQUFnRDtBQUNoRCw2Q0FBNkM7QUFDN0MsaUNBQWlDO0FBQ2pDLGdCQUFnQjtBQUNoQixjQUFjO0FBRWQsdURBQXVEO0FBRXZELGtDQUFrQztBQUNsQyx3RUFBd0U7QUFDeEUsMkRBQTJEO0FBQzNELCtDQUErQztBQUMvQyx5REFBeUQ7QUFDekQsVUFBVTtBQUdWLGlDQUFpQztBQUNqQyw0Q0FBNEM7QUFDNUMsbUNBQW1DO0FBQ25DLDZFQUE2RTtBQUM3RSxzSUFBc0k7QUFDdEksNkJBQTZCO0FBQzdCLDJFQUEyRTtBQUMzRSwrQkFBK0I7QUFDL0IsZ0NBQWdDO0FBQ2hDLHFDQUFxQztBQUNyQyw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCLFFBQVE7QUFFUixlQUFlO0FBQ2YsMEJBQTBCO0FBQzFCLDRDQUE0QztBQUM1QyxRQUFRO0FBQ1IsSUFBSTtBQUVrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5WnNEO0FBRXJFLE1BQU0sWUFBWSxHQUFHLENBQUMsZUFBb0MsRUFBRSxVQUEyQixFQUFFLEVBQUU7SUFFOUYsTUFBTSxXQUFXLEdBQUcsVUFBVSxDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUM7SUFDaEQsTUFBTSxZQUFZLEdBQUcsVUFBVSxDQUFDLFdBQVcsRUFBRSxHQUFHLCtDQUFXLENBQUM7SUFFNUQsS0FBSyxJQUFJLFFBQVEsR0FBRyxDQUFDLEVBQUUsUUFBUSxHQUFHLFlBQVksR0FBRywrQ0FBVyxFQUFFLFFBQVEsSUFBSSwrQ0FBVyxFQUFFO1FBQ25GLE1BQU0sTUFBTSxHQUFHLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN6RCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRywrQ0FBVyxDQUFDLEdBQUcsK0NBQVcsQ0FBQztRQUNsRSxJQUFJLDRCQUE0QixHQUFHLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQztRQUMvRCxJQUFJLGFBQWEsR0FBRyw0QkFBNEIsR0FBRyxDQUFDO1FBQ3BELElBQUksTUFBTSxDQUFDLFNBQVMsSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUNwQyw4RUFBOEU7WUFDOUUsbUNBQW1DO1lBQ25DLE1BQU0sYUFBYSxHQUFHLGVBQWUsQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQzNELE1BQU0sWUFBWSxHQUFHLGVBQWUsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDckQsS0FBSyxJQUFJLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDcEIsTUFBTSxZQUFZLEdBQUcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDdEUsTUFBTSxXQUFXLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDcEUsSUFBSSxZQUFZLElBQUksV0FBVyxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDM0UsSUFBSSxZQUFZLENBQUMsUUFBUSxJQUFJLCtDQUFXLEVBQUU7d0JBQ3RDLFNBQVM7cUJBQ1o7b0JBQ0QsSUFBSSxXQUFXLENBQUMsUUFBUSxJQUFJLCtDQUFXLEVBQUU7d0JBQ3JDLFNBQVM7cUJBQ1o7b0JBQ0QsSUFBSSxZQUFZLENBQUMsR0FBRyxJQUFJLElBQUksRUFBRTt3QkFDMUIsU0FBUztxQkFDWjtvQkFDRCxZQUFZLENBQUMsR0FBRyxHQUFHLE9BQU8sQ0FBQztvQkFDM0IsV0FBVyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUM7aUJBQzVCO2FBQ0o7WUFDRCxPQUFPLENBQUMsR0FBRyxDQUFDLGlCQUFpQixFQUFFLGFBQWEsQ0FBQyxDQUFDO1NBQ2pEO0tBQ0o7QUFDTCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckNvQztBQUUwQztBQWV4RSxNQUFNLGFBQWEsR0FBRyxDQUFDLEtBQVksRUFBRSxTQUFzQixFQUFFLElBQVksRUFBRSxNQUFtQixFQUFFLE1BQWMsRUFBRSx5QkFBaUMsRUFBZ0MsRUFBRTtJQUN0TCxtRUFBbUU7SUFDbkUsZ0JBQWdCO0lBRWhCLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQztJQUM1QyxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUM7SUFDNUMsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDO0lBQzVDLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQztJQUU1QyxNQUFNLHVCQUF1QixHQUFHO1FBQzVCLHNEQUFjLENBQUMsSUFBSSwrQ0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2hDLHNEQUFjLENBQUMsSUFBSSwrQ0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2hDLHNEQUFjLENBQUMsSUFBSSwrQ0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2hDLHNEQUFjLENBQUMsSUFBSSwrQ0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQ25DO0lBRUQsTUFBTSxjQUFjLEdBQUc7UUFDbkIsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZFLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsdUJBQXVCLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN2RSxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLHVCQUF1QixDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDdkUsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0tBQzFFO0lBQ0QsTUFBTSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUM7SUFFMUIsMkNBQTJDO0lBQzNDLE1BQU0sR0FBRyxHQUFpQyxFQUFFLENBQUM7SUFFN0MsSUFBSSx1QkFBdUIsR0FBRyxDQUFDLEdBQUcsdUJBQXVCLENBQUM7SUFDMUQsSUFBSSxTQUFTLEVBQUU7UUFDWCx1QkFBdUIsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsc0RBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0tBQ3pFO0lBRUQsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNSLE9BQU8sRUFBRSxDQUFDO0tBQ2I7SUFFRCxJQUFJLEtBQUssRUFBRTtRQUNQLHdFQUF3RTtRQUV4RSxTQUFTO1FBQ1QsK0NBQStDO1FBRS9DLDJGQUEyRjtRQUMzRixvRUFBb0U7UUFFcEUsbURBQW1EO1FBRW5ELG9HQUFvRztRQUNwRyxzREFBc0Q7UUFFdEQsTUFBTSxhQUFhLEdBQUcsd0RBQWdCLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7UUFDeEYsTUFBTSxXQUFXLEdBQUcsYUFBYSxJQUFJLENBQUMsSUFBSSxhQUFhLElBQUksQ0FBQyxDQUFDO1FBQzdELE1BQU0sQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUUxRCwwRUFBMEU7UUFFMUUsSUFBSSxjQUFjLEdBQUcsQ0FBQyxNQUFNLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBRSxhQUFhLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDcEYsSUFBSSxnQkFBZ0IsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNqQyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUN4QixjQUFjLEdBQUcsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztTQUN6RDtRQUVELEtBQUssSUFBSSxjQUFjLEdBQUcsQ0FBQyxFQUFFLGNBQWMsR0FBRyxDQUFDLEVBQUUsY0FBYyxFQUFFLEVBQUU7WUFDbkUsS0FBSyxJQUFJLGNBQWMsR0FBQyxDQUFDLEVBQUUsY0FBYyxHQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsY0FBYyxFQUFFLEVBQUU7Z0JBQ25GLEtBQUssSUFBSSxnQkFBZ0IsR0FBQyxDQUFDLEVBQUUsZ0JBQWdCLEdBQUMsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsRUFBRTtvQkFDaEYsTUFBTSxTQUFTLEdBQUcsY0FBYyxJQUFJLENBQUMsQ0FBQztvQkFFdEMsd0NBQXdDO29CQUN4QyxNQUFNLFNBQVMsR0FBRyxjQUFjLENBQUMsY0FBYyxDQUFDLENBQUM7b0JBQ2pELElBQUkseUJBQXlCLEdBQUcsQ0FBQyxFQUFFO3dCQUMvQixJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRTs0QkFDL0IsU0FBUyxDQUFDLHdEQUF3RDt5QkFDckU7cUJBQ0o7b0JBRUQsTUFBTSxlQUFlLEdBQW9CO3dCQUNyQyxVQUFVLEVBQUUsRUFBRTt3QkFDZCxLQUFLLEVBQUUsRUFBRTt3QkFDVCxNQUFNLEVBQUUsQ0FBQzt3QkFDVCxhQUFhLEVBQUUsY0FBYyxDQUFDLGNBQWMsQ0FBQztxQkFDaEQsQ0FBQztvQkFDRixJQUFJLFNBQVMsRUFBRTt3QkFDWCxlQUFlLENBQUMsYUFBYSxJQUFJLFlBQVksQ0FBQztxQkFDakQ7b0JBRUQsTUFBTSxXQUFXLEdBQUcsQ0FBQyxTQUFpQixFQUFFLElBQVUsRUFBRSxFQUFFO3dCQUNsRCxlQUFlLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksK0NBQUksQ0FBQzs0QkFDeEMsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFROzRCQUN2QixNQUFNLEVBQUUsQ0FBQyxDQUFFLFFBQVE7eUJBQ3RCLENBQUMsQ0FBQztvQkFDUCxDQUFDO29CQUVELE1BQU0sQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLFNBQVMsRUFBRSxhQUFhLEVBQUUsU0FBUyxDQUFDLENBQUM7b0JBQy9ELElBQUksV0FBVyxHQUE4QixFQUFFLENBQUM7b0JBRWhELDJCQUEyQjtvQkFDM0IsSUFBSSxTQUFTLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFO3dCQUM5QixXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO3FCQUN0Qjt5QkFBTSxJQUFJLFNBQVMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEVBQUU7d0JBQ3RDLFdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7cUJBQ3RCO3lCQUFNLElBQUksU0FBUyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsRUFBRTt3QkFDdkMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztxQkFDdEI7eUJBQU0sSUFBSSxTQUFTLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFO3dCQUN0QyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO3FCQUN0QjtvQkFFRCwrQkFBK0I7b0JBQy9CLElBQUksZUFBZSxHQUFhLEVBQUUsQ0FBQztvQkFDbkMsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7d0JBQ3pCLElBQUksU0FBUyxJQUFJLE1BQU0sRUFBRTs0QkFDckIsZUFBZSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFFLGtCQUFrQjt5QkFDbkQ7NkJBQU0sSUFBSSxTQUFTLElBQUksWUFBWSxFQUFFOzRCQUNsQyw2QkFBNkI7NEJBQzdCLGVBQWUsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBRSxrQkFBa0I7eUJBQ25EOzZCQUFNLElBQUksU0FBUyxJQUFJLGFBQWEsRUFBRTs0QkFDbkMsZUFBZSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFFLG1CQUFtQjt5QkFDcEQ7NkJBQU0sSUFBSSxTQUFTLElBQUksYUFBYSxFQUFFOzRCQUNuQyxlQUFlLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUUsbUJBQW1CO3lCQUNwRDs2QkFBTSxJQUFJLFNBQVMsSUFBSSxRQUFRLEVBQUU7NEJBQzlCLDhCQUE4Qjs0QkFDOUIsZUFBZSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFFLGtCQUFrQjt5QkFDbkQ7cUJBQ0o7eUJBQU0sSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7d0JBQ2hDLGVBQWUsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztxQkFDbkU7b0JBRUQsSUFBSSxTQUFTLEVBQUU7d0JBQ1gsSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFOzRCQUNyQix1Q0FBdUM7NEJBQ3ZDLFNBQVM7eUJBQ1o7d0JBQ0QsSUFBSSxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7NEJBQ2pELGtDQUFrQzs0QkFDbEMsU0FBUzt5QkFDWjt3QkFDRCxlQUFlLEdBQUcsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzt3QkFDdEQsMkNBQTJDO3dCQUMzQyxJQUFJLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTs0QkFDakQsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzt5QkFDM0I7NkJBQU07NEJBQ0gsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzt5QkFDM0I7cUJBQ0o7b0JBRUQsNkVBQTZFO29CQUM3RSxJQUFJLGdCQUFnQixLQUFLLENBQUMsRUFBRTt3QkFDeEIsb0JBQW9CO3dCQUNwQixXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNwQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNwQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUN2Qzt5QkFBTSxJQUFJLGdCQUFnQixLQUFLLENBQUMsRUFBRTt3QkFDL0IscUJBQXFCO3dCQUNyQixXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNwQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNwQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUN2Qzt5QkFBTSxJQUFJLGdCQUFnQixLQUFLLENBQUMsRUFBRTt3QkFDL0Isb0JBQW9CO3dCQUNwQixXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNwQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNwQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUN2Qzt5QkFBTSxJQUFJLGdCQUFnQixLQUFLLENBQUMsRUFBRTt3QkFDL0IscUJBQXFCO3dCQUNyQixXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNwQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNwQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUN2Qzt5QkFBTSxJQUFJLGdCQUFnQixLQUFLLENBQUMsRUFBRTt3QkFDL0Isb0JBQW9CO3dCQUNwQixXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNwQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUNwQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUN2Qzt5QkFBTSxJQUFJLGdCQUFnQixLQUFLLENBQUMsRUFBRTt3QkFDL0Isb0JBQW9CO3dCQUNwQixXQUFX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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFD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QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZCQUE2QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFD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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQ0FBa0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLEdBQUc7O0FBRUgsQ0FBQzs7Ozs7Ozs7Ozs7QUM3VUQ7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxxQ0FBcUM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFD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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNERBQTRELEtBQUssV0FBVyxVQUFVO0FBQ3RGO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNERBQTRELEtBQUssV0FBVyxVQUFVO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsSUFBSTtBQUM1RDtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxVQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7Ozs7Ozs7Ozs7O0FDcGVEO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsMkRBQVc7O0FBRTdDLHlCQUF5Qixt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ZW9yeWpzL2Rpc3QvbXVzaWN0aGVvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2F2YWlsYWJsZXNjYWxlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2hvcmRzLnRzIiwid2VicGFjazovLy8uL3NyYy9oYWxmbm90ZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ludmVyc2lvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL211c2ljeG1sZ2VuLnRzIiwid2VicGFjazovLy8uL3NyYy9teWxvZ2dlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmFuZG9tY2hvcmRzLnRzIiwid2VicGFjazovLy8uL3NyYy90ZW5zaW9uLnRzIiwid2VicGFjazovLy8uL3NyYy90b3BtZWxvZHkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9Eb2N1bWVudFBvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9Ob2RlVHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvVXRpbGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvV3JpdGVyU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTEF0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MQ0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTENoYXJhY3RlckRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTENvbW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERPTUNvbmZpZ3VyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERPTUVycm9ySGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRE9NSW1wbGVtZW50YXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERPTVN0cmluZ0xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERUREF0dExpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERUREVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERUREVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRFRETm90YXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERlY2xhcmF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxEb2NUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxEb2N1bWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRG9jdW1lbnRDQi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRHVtbXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTE5hbWVkTm9kZU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MTm9kZUxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MUmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxTdHJlYW1Xcml0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFN0cmluZ1dyaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MU3RyaW5naWZpZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFdyaXRlckJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly8vLi93b3JrZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5NdXNpY1RoZW9yeSA9IHt9KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAvKipcclxuICAgICogTm90ZXMgc3RhcnRpbmcgYXQgQzAgLSB6ZXJvIGluZGV4IC0gMTIgdG90YWxcclxuICAgICogTWFwcyBub3RlIG5hbWVzIHRvIHNlbWl0b25lIHZhbHVlcyBzdGFydGluZyBhdCBDPTBcclxuICAgICogQGVudW1cclxuICAgICovXHJcbiAgIHZhciBTZW1pdG9uZTtcclxuICAgKGZ1bmN0aW9uIChTZW1pdG9uZSkge1xyXG4gICAgICAgU2VtaXRvbmVbU2VtaXRvbmVbXCJBXCJdID0gOV0gPSBcIkFcIjtcclxuICAgICAgIFNlbWl0b25lW1NlbWl0b25lW1wiQXNcIl0gPSAxMF0gPSBcIkFzXCI7XHJcbiAgICAgICBTZW1pdG9uZVtTZW1pdG9uZVtcIkJiXCJdID0gMTBdID0gXCJCYlwiO1xyXG4gICAgICAgU2VtaXRvbmVbU2VtaXRvbmVbXCJCXCJdID0gMTFdID0gXCJCXCI7XHJcbiAgICAgICBTZW1pdG9uZVtTZW1pdG9uZVtcIkJzXCJdID0gMF0gPSBcIkJzXCI7XHJcbiAgICAgICBTZW1pdG9uZVtTZW1pdG9uZVtcIkNiXCJdID0gMTFdID0gXCJDYlwiO1xyXG4gICAgICAgU2VtaXRvbmVbU2VtaXRvbmVbXCJDXCJdID0gMF0gPSBcIkNcIjtcclxuICAgICAgIFNlbWl0b25lW1NlbWl0b25lW1wiQ3NcIl0gPSAxXSA9IFwiQ3NcIjtcclxuICAgICAgIFNlbWl0b25lW1NlbWl0b25lW1wiRGJcIl0gPSAxXSA9IFwiRGJcIjtcclxuICAgICAgIFNlbWl0b25lW1NlbWl0b25lW1wiRFwiXSA9IDJdID0gXCJEXCI7XHJcbiAgICAgICBTZW1pdG9uZVtTZW1pdG9uZVtcIkRzXCJdID0gM10gPSBcIkRzXCI7XHJcbiAgICAgICBTZW1pdG9uZVtTZW1pdG9uZVtcIkViXCJdID0gM10gPSBcIkViXCI7XHJcbiAgICAgICBTZW1pdG9uZVtTZW1pdG9uZVtcIkVcIl0gPSA0XSA9IFwiRVwiO1xyXG4gICAgICAgU2VtaXRvbmVbU2VtaXRvbmVbXCJFc1wiXSA9IDVdID0gXCJFc1wiO1xyXG4gICAgICAgU2VtaXRvbmVbU2VtaXRvbmVbXCJGYlwiXSA9IDRdID0gXCJGYlwiO1xyXG4gICAgICAgU2VtaXRvbmVbU2VtaXRvbmVbXCJGXCJdID0gNV0gPSBcIkZcIjtcclxuICAgICAgIFNlbWl0b25lW1NlbWl0b25lW1wiRnNcIl0gPSA2XSA9IFwiRnNcIjtcclxuICAgICAgIFNlbWl0b25lW1NlbWl0b25lW1wiR2JcIl0gPSA2XSA9IFwiR2JcIjtcclxuICAgICAgIFNlbWl0b25lW1NlbWl0b25lW1wiR1wiXSA9IDddID0gXCJHXCI7XHJcbiAgICAgICBTZW1pdG9uZVtTZW1pdG9uZVtcIkdzXCJdID0gOF0gPSBcIkdzXCI7XHJcbiAgICAgICBTZW1pdG9uZVtTZW1pdG9uZVtcIkFiXCJdID0gOF0gPSBcIkFiXCI7XHJcbiAgIH0pKFNlbWl0b25lIHx8IChTZW1pdG9uZSA9IHt9KSk7XHJcbiAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIHRoZSB3aG9sZSBub3RlIG5hbWUgKGUuZy4gQywgRCwgRSwgRiwgRywgQSwgQikgZm9yXHJcbiAgICAqIHRoZSBnaXZlbiBzdHJpbmdcclxuICAgICogQGludGVybmFsXHJcbiAgICAqL1xyXG4gICBjb25zdCBnZXRXaG9sZVRvbmVGcm9tTmFtZSA9IChuYW1lKSA9PiB7XHJcbiAgICAgICBpZiAoIW5hbWUgfHwgbmFtZS5sZW5ndGggPT09IDAgfHwgbmFtZS5sZW5ndGggPiAxKVxyXG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbmFtZVwiKTtcclxuICAgICAgIGNvbnN0IGtleSA9IG5hbWVbMF0udG9VcHBlckNhc2UoKTtcclxuICAgICAgIHJldHVybiBTZW1pdG9uZVtrZXldO1xyXG4gICB9O1xyXG4gICB2YXIgU2VtaXRvbmUkMSA9IFNlbWl0b25lO1xuXG4gICAvKipcclxuICAgICogV3JhcHMgYSBudW1iZXIgYmV0d2VlbiBhIG1pbiBhbmQgbWF4IHZhbHVlLlxyXG4gICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgbnVtYmVyIHRvIHdyYXBcclxuICAgICogQHBhcmFtIGxvd2VyICAtIHRoZSBsb3dlciBib3VuZFxyXG4gICAgKiBAcGFyYW0gdXBwZXIgLSB0aGUgdXBwZXIgYm91bmRcclxuICAgICogQHJldHVybnMgd3JhcHBlZE51bWJlciAtIHRoZSB3cmFwcGVkIG51bWJlclxyXG4gICAgKiBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgIGNvbnN0IHdyYXAgPSAodmFsdWUsIGxvd2VyLCB1cHBlcikgPT4ge1xyXG4gICAgICAgLy8gY29waWVzXHJcbiAgICAgICBsZXQgdmFsID0gdmFsdWU7XHJcbiAgICAgICBsZXQgbGJvdW5kID0gbG93ZXI7XHJcbiAgICAgICBsZXQgdWJvdW5kID0gdXBwZXI7XHJcbiAgICAgICAvLyBpZiB0aGUgYm91bmRzIGFyZSBpbnZlcnRlZCwgc3dhcCB0aGVtIGhlcmVcclxuICAgICAgIGlmICh1cHBlciA8IGxvd2VyKSB7XHJcbiAgICAgICAgICAgbGJvdW5kID0gdXBwZXI7XHJcbiAgICAgICAgICAgdWJvdW5kID0gbG93ZXI7XHJcbiAgICAgICB9XHJcbiAgICAgICAvLyB0aGUgYW1vdW50IG5lZWRlZCB0byBtb3ZlIHRoZSByYW5nZSBhbmQgdmFsdWUgdG8gemVyb1xyXG4gICAgICAgY29uc3QgemVyb09mZnNldCA9IDAgLSBsYm91bmQ7XHJcbiAgICAgICAvLyBvZmZzZXQgdGhlIHZhbHVlcyBzbyB0aGF0IHRoZSBsb3dlciBib3VuZCBpcyB6ZXJvXHJcbiAgICAgICBsYm91bmQgKz0gemVyb09mZnNldDtcclxuICAgICAgIHVib3VuZCArPSB6ZXJvT2Zmc2V0O1xyXG4gICAgICAgdmFsICs9IHplcm9PZmZzZXQ7XHJcbiAgICAgICAvLyBjb21wdXRlIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIHZhbHVlIHdpbGwgd3JhcFxyXG4gICAgICAgbGV0IHdyYXBzID0gTWF0aC50cnVuYyh2YWwgLyB1Ym91bmQpO1xyXG4gICAgICAgLy8gY2FzZTogLTEgLyB1Ym91bmQoPjApIHdpbGwgZXF1YWwgMCBhbHRob3VnaCBpdCB3cmFwcyBvbmNlXHJcbiAgICAgICBpZiAod3JhcHMgPT09IDAgJiYgdmFsIDwgbGJvdW5kKVxyXG4gICAgICAgICAgIHdyYXBzID0gLTE7XHJcbiAgICAgICAvLyBjYXNlOiB1Ym91bmQgYW5kIHZhbHVlIGFyZSB0aGUgc2FtZSB2YWwvdWJvdW5kID0gMSBidXQgYWN0dWFsbHkgZG9lc250IHdyYXBcclxuICAgICAgIGlmICh3cmFwcyA9PT0gMSAmJiB2YWwgPT09IHVib3VuZClcclxuICAgICAgICAgICB3cmFwcyA9IDA7XHJcbiAgICAgICAvLyBuZWVkZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBudW0gb2Ygd3JhcHMgaXMgMCBvciAxIG9yIC0xXHJcbiAgICAgICBsZXQgdmFsT2Zmc2V0ID0gMDtcclxuICAgICAgIGxldCB3cmFwT2Zmc2V0ID0gMDtcclxuICAgICAgIGlmICh3cmFwcyA+PSAtMSAmJiB3cmFwcyA8PSAxKVxyXG4gICAgICAgICAgIHdyYXBPZmZzZXQgPSAxO1xyXG4gICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIGJlbG93IHRoZSByYW5nZVxyXG4gICAgICAgaWYgKHZhbCA8IGxib3VuZCkge1xyXG4gICAgICAgICAgIHZhbE9mZnNldCA9ICh2YWwgJSB1Ym91bmQpICsgd3JhcE9mZnNldDtcclxuICAgICAgICAgICB2YWwgPSB1Ym91bmQgKyB2YWxPZmZzZXQ7XHJcbiAgICAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIGFib3ZlIHRoZSByYW5nZVxyXG4gICAgICAgfVxyXG4gICAgICAgZWxzZSBpZiAodmFsID4gdWJvdW5kKSB7XHJcbiAgICAgICAgICAgdmFsT2Zmc2V0ID0gKHZhbCAlIHVib3VuZCkgLSB3cmFwT2Zmc2V0O1xyXG4gICAgICAgICAgIHZhbCA9IGxib3VuZCArIHZhbE9mZnNldDtcclxuICAgICAgIH1cclxuICAgICAgIC8vIGFkZCB0aGUgb2Zmc2V0IGZyb20gemVybyBiYWNrIHRvIHRoZSB2YWx1ZVxyXG4gICAgICAgdmFsIC09IHplcm9PZmZzZXQ7XHJcbiAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgIHZhbHVlOiB2YWwsXHJcbiAgICAgICAgICAgbnVtV3JhcHM6IHdyYXBzLFxyXG4gICAgICAgfTtcclxuICAgfTtcblxuICAgLyoqXHJcbiAgICAqIFNpbXBsZSB1dGlsIHRvIGNsYW1wIGEgbnVtYmVyIHRvIGEgcmFuZ2VcclxuICAgICogQHBhcmFtIHBOdW0gLSB0aGUgbnVtYmVyIHRvIGNsYW1wXHJcbiAgICAqIEBwYXJhbSBwTG93ZXIgLSB0aGUgbG93ZXIgYm91bmRcclxuICAgICogQHBhcmFtIHBVcHBlciAtIHRoZSB1cHBlciBib3VuZFxyXG4gICAgKiBAcmV0dXJucyBOdW1iZXIgLSB0aGUgY2xhbXBlZCBudW1iZXJcclxuICAgICpcclxuICAgICogQGludGVybmFsXHJcbiAgICAqL1xyXG4gICBjb25zdCBjbGFtcCA9IChwTnVtLCBwTG93ZXIsIHBVcHBlcikgPT4gTWF0aC5tYXgoTWF0aC5taW4ocE51bSwgTWF0aC5tYXgocExvd2VyLCBwVXBwZXIpKSwgTWF0aC5taW4ocExvd2VyLCBwVXBwZXIpKTtcblxuICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgIC8vIENvbnN0YW50c1xyXG4gICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgY29uc3QgTU9ESUZJRURfU0VNSVRPTkVTID0gWzEsIDMsIDQsIDYsIDgsIDEwXTtcclxuICAgY29uc3QgVE9ORVNfTUFYID0gMTE7XHJcbiAgIGNvbnN0IFRPTkVTX01JTiA9IDA7XHJcbiAgIGNvbnN0IE9DVEFWRV9NQVggPSA5O1xyXG4gICBjb25zdCBPQ1RBVkVfTUlOID0gMDtcclxuICAgY29uc3QgREVGQVVMVF9PQ1RBVkUgPSA0O1xyXG4gICBjb25zdCBERUZBVUxUX1NFTUlUT05FID0gMDtcblxuICAgLyoqXHJcbiAgICAqIE1hcHMgbm90ZSBhbHRlcmF0aW9ucyB0byAgdGhlaXIgcmVsYXRpdmUgbWF0aG1hdGljYWwgdmFsdWVcclxuICAgICpAZW51bVxyXG4gICAgKi9cclxuICAgdmFyIE1vZGlmaWVyO1xyXG4gICAoZnVuY3Rpb24gKE1vZGlmaWVyKSB7XHJcbiAgICAgICBNb2RpZmllcltNb2RpZmllcltcIkZMQVRcIl0gPSAtMV0gPSBcIkZMQVRcIjtcclxuICAgICAgIE1vZGlmaWVyW01vZGlmaWVyW1wiTkFUVVJBTFwiXSA9IDBdID0gXCJOQVRVUkFMXCI7XHJcbiAgICAgICBNb2RpZmllcltNb2RpZmllcltcIlNIQVJQXCJdID0gMV0gPSBcIlNIQVJQXCI7XHJcbiAgIH0pKE1vZGlmaWVyIHx8IChNb2RpZmllciA9IHt9KSk7XHJcbiAgIC8qKlxyXG4gICAgKiBQYXJzZXMgbW9kaWZpZXIgZnJvbSBzdHJpbmcgYW5kIHJldHVybnMgdGhlIGVudW0gdmFsdWVcclxuICAgICogQGludGVybmFsXHJcbiAgICAqL1xyXG4gICBjb25zdCBwYXJzZU1vZGlmaWVyID0gKG1vZGlmaWVyKSA9PiB7XHJcbiAgICAgICBzd2l0Y2ggKG1vZGlmaWVyKSB7XHJcbiAgICAgICAgICAgY2FzZSBcImJcIjpcclxuICAgICAgICAgICBjYXNlIFwiZmxhdFwiOlxyXG4gICAgICAgICAgICAgICByZXR1cm4gTW9kaWZpZXIuRkxBVDtcclxuICAgICAgICAgICBjYXNlIFwiI1wiOlxyXG4gICAgICAgICAgIGNhc2UgXCJzXCI6XHJcbiAgICAgICAgICAgY2FzZSBcInNoYXJwXCI6XHJcbiAgICAgICAgICAgICAgIHJldHVybiBNb2RpZmllci5TSEFSUDtcclxuICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICByZXR1cm4gTW9kaWZpZXIuTkFUVVJBTDtcclxuICAgICAgIH1cclxuICAgfTtcclxuICAgdmFyIE1vZGlmaWVyJDEgPSBNb2RpZmllcjtcblxuICAgLy8gaW1wb3J0IHsgcmVnaXN0ZXJJbml0aWFsaXplciB9IGZyb20gXCIuLi9Jbml0aWFsaXplci9Jbml0aWFsaXplclwiO1xyXG4gICAvLyBpbXBvcnQgdGFibGUgZnJvbSBcIi4vbm90ZUxvb2t1cC5qc29uXCI7XHJcbiAgIC8vIGltcG9ydCBmcyBmcm9tIFwiZnNcIjtcclxuICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgIC8qKlxyXG4gICAgKiBSZWdleCBmb3IgbWF0Y2hpbmcgbm90ZSBuYW1lLCBtb2RpZmllciwgYW5kIG9jdGF2ZVxyXG4gICAgKi9cclxuICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgIGNvbnN0IG5hbWVSZWdleCQyID0gLyhbQS1HXSkvZztcclxuICAgY29uc3QgbW9kaWZpZXJSZWdleCQyID0gLygjfHN8YikvZztcclxuICAgY29uc3Qgb2N0YXZlUmVnZXgkMiA9IC8oWzAtOV0rKS9nO1xyXG4gICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgLyoqXHJcbiAgICAqIGF0dGVtcHRzIHRvIHBhcnNlIGEgbm90ZSBmcm9tIGEgc3RyaW5nXHJcbiAgICAqL1xyXG4gICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgY29uc3QgcGFyc2VOb3RlID0gKG5vdGUsIHN1cHJlc3NXYXJuaW5nID0gZmFsc2UpID0+IHtcclxuICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbm90ZUxvb2t1cChub3RlKTtcclxuICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmICghc3VwcmVzc1dhcm5pbmcpXHJcbiAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW5lZmZlY2llbnQgbm90ZSBzdHJpbmcgZm9ybWF0dGluZyAtICR7bm90ZX0uIEdldCBhIHBlcmZvcm1hbmNlIGluY3JlYXNlIGJ5IHVzaW5nIHRoZSBmb3JtYXQgW0EtR11bI3xzfGJdWzAtOV0gYW5kIHVzaW5nIGJ1aWxkVGFibGVzIG1ldGhvZChzZWUgZG9jdW1lbnRhdGlvbilgKTtcclxuICAgICAgIH1cclxuICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICBpZiAoIXN1cHJlc3NXYXJuaW5nKVxyXG4gICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEluZWZmZWNpZW50IG5vdGUgc3RyaW5nIGZvcm1hdHRpbmcgLSAke25vdGV9LiBHZXQgYSBwZXJmb3JtYW5jZSBpbmNyZWFzZSBieSB1c2luZyB0aGUgZm9ybWF0IFtBLUddWyN8c3xiXVswLTldIGFuZCB1c2luZyBidWlsZFRhYmxlcyBtZXRob2Qoc2VlIGRvY3VtZW50YXRpb24pYCk7XHJcbiAgICAgICB9XHJcbiAgICAgICBsZXQgbm90ZUlkZW5pZmllciA9IFwiXCI7XHJcbiAgICAgICBsZXQgbm90ZU1vZGlmaWVyID0gMDtcclxuICAgICAgIGxldCBub3RlT2N0YXZlID0gXCJcIjtcclxuICAgICAgIGNvbnN0IG5hbWVNYXRjaCA9IG5vdGUubWF0Y2gobmFtZVJlZ2V4JDIpPy5qb2luKFwiXCIpLnNwbGl0KFwiXCIpO1xyXG4gICAgICAgY29uc3QgbW9kaWZpZXJNYXRjaCA9IG5vdGUubWF0Y2gobW9kaWZpZXJSZWdleCQyKT8uam9pbihcIlwiKS5zcGxpdChcIlwiKTtcclxuICAgICAgIGNvbnN0IG9jdGF2ZU1hdGNoID0gbm90ZS5tYXRjaChvY3RhdmVSZWdleCQyKT8uam9pbihcIlwiKS5zcGxpdChcIlwiKTtcclxuICAgICAgIC8vIGNvbWJpbmUgYWxsIG1vZGlmaWVyc1xyXG4gICAgICAgaWYgKG1vZGlmaWVyTWF0Y2gpIHtcclxuICAgICAgICAgICBpZiAobW9kaWZpZXJNYXRjaC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgIC8vIGNvbWJpbmUgYWxsIG1vZGlmaWVycyBpbnRvIGFuIG9mZmVzZXQgdmFsdWUgdG8gYmUgYWRkZWQgdG8gdGhlIHNlbWl0b25lXHJcbiAgICAgICAgICAgICAgIG5vdGVNb2RpZmllciA9IG1vZGlmaWVyTWF0Y2hcclxuICAgICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IHBhcnNlTW9kaWZpZXIoaXRlbSkpXHJcbiAgICAgICAgICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBhICsgYik7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICBub3RlTW9kaWZpZXIgPSBwYXJzZU1vZGlmaWVyKG1vZGlmaWVyTWF0Y2hbMF0pO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH1cclxuICAgICAgIGlmIChvY3RhdmVNYXRjaCkge1xyXG4gICAgICAgICAgIGNvbnN0IFtvY3RhdmVdID0gb2N0YXZlTWF0Y2g7XHJcbiAgICAgICAgICAgbm90ZU9jdGF2ZSA9IG9jdGF2ZTtcclxuICAgICAgIH1cclxuICAgICAgIGlmIChuYW1lTWF0Y2gpIHtcclxuICAgICAgICAgICBjb25zdCBbbm90ZU5hbWVdID0gbmFtZU1hdGNoO1xyXG4gICAgICAgICAgIG5vdGVJZGVuaWZpZXIgPSBub3RlTmFtZTtcclxuICAgICAgICAgICBsZXQgbW9kaWZpZXIgPSAwO1xyXG4gICAgICAgICAgIGlmIChub3RlTW9kaWZpZXIpXHJcbiAgICAgICAgICAgICAgIG1vZGlmaWVyID0gbm90ZU1vZGlmaWVyO1xyXG4gICAgICAgICAgIGNvbnN0IHdyYXBwZWRUb25lID0gd3JhcChnZXRXaG9sZVRvbmVGcm9tTmFtZShub3RlSWRlbmlmaWVyKSArIG1vZGlmaWVyLCBUT05FU19NSU4sIFRPTkVTX01BWCk7XHJcbiAgICAgICAgICAgY29uc3Qgc2VtaXRvbmUgPSB3cmFwcGVkVG9uZS52YWx1ZTtcclxuICAgICAgICAgICBsZXQgb2N0YXZlID0gNDtcclxuICAgICAgICAgICBpZiAobm90ZU9jdGF2ZSlcclxuICAgICAgICAgICAgICAgb2N0YXZlID0gY2xhbXAocGFyc2VJbnQobm90ZU9jdGF2ZSwgMTApLCBPQ1RBVkVfTUlOLCBPQ1RBVkVfTUFYKTtcclxuICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICBzZW1pdG9uZTogc2VtaXRvbmUsXHJcbiAgICAgICAgICAgICAgIG9jdGF2ZTogb2N0YXZlLFxyXG4gICAgICAgICAgIH07XHJcbiAgICAgICB9XHJcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbm90ZTogJHtub3RlfWApO1xyXG4gICB9O1xyXG4gICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgLyoqXHJcbiAgICAqIGNyZWF0ZXMgYSBsb29rdXAgdGFibGUgZm9yIGFsbCBub3RlcyBmb3JtYXR0ZWQgYXMgW0EtR11bI3xifHNdWzAtOV1cclxuICAgICovXHJcbiAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICBjb25zdCBjcmVhdGVUYWJsZSQ0ID0gKCkgPT4ge1xyXG4gICAgICAgY29uc3Qgbm90ZVRhYmxlID0ge307XHJcbiAgICAgICBjb25zdCBub3RlTGV0dGVycyA9IFtcIkFcIiwgXCJCXCIsIFwiQ1wiLCBcIkRcIiwgXCJFXCIsIFwiRlwiLCBcIkdcIl07XHJcbiAgICAgICBjb25zdCBub3RlTW9kaWZpZXJzID0gW1wiYlwiLCBcIiNcIiwgXCJzXCJdO1xyXG4gICAgICAgZm9yIChjb25zdCBub3RlTGFiZWwgb2Ygbm90ZUxldHRlcnMpIHtcclxuICAgICAgICAgICBub3RlVGFibGVbbm90ZUxhYmVsXSA9IHBhcnNlTm90ZShub3RlTGFiZWwsIHRydWUpOyAvLyAnQycgZm9yIGV4YW1wbGVcclxuICAgICAgICAgICBmb3IgKGxldCBpTW9kaWZpZXJPdXRlciA9IDA7IGlNb2RpZmllck91dGVyIDwgbm90ZU1vZGlmaWVycy5sZW5ndGg7ICsraU1vZGlmaWVyT3V0ZXIpIHtcclxuICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7bm90ZUxhYmVsfSR7bm90ZU1vZGlmaWVyc1tpTW9kaWZpZXJPdXRlcl19YDtcclxuICAgICAgICAgICAgICAgbm90ZVRhYmxlW2tleV0gPSBwYXJzZU5vdGUoa2V5LCB0cnVlKTsgLy8gJ0MjJyBmb3IgZXhhbXBsZVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBmb3IgKGxldCBpT2N0YXZlID0gT0NUQVZFX01JTjsgaU9jdGF2ZSA8IE9DVEFWRV9NQVg7ICsraU9jdGF2ZSkge1xyXG4gICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtub3RlTGFiZWx9JHtpT2N0YXZlfWA7XHJcbiAgICAgICAgICAgICAgIG5vdGVUYWJsZVtrZXldID0gcGFyc2VOb3RlKGtleSwgdHJ1ZSk7IC8vICdDNCcgZm9yIGV4YW1wbGVcclxuICAgICAgICAgICAgICAgZm9yIChsZXQgaU1vZGlmaWVyID0gMDsgaU1vZGlmaWVyIDwgbm90ZU1vZGlmaWVycy5sZW5ndGg7ICsraU1vZGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtub3RlTGFiZWx9JHtub3RlTW9kaWZpZXJzW2lNb2RpZmllcl19JHtpT2N0YXZlfWA7XHJcbiAgICAgICAgICAgICAgICAgICBub3RlVGFibGVba2V5XSA9IHBhcnNlTm90ZShrZXksIHRydWUpOyAvLyAnQyM0JyBmb3IgZXhhbXBsZVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfVxyXG4gICAgICAgcmV0dXJuIG5vdGVUYWJsZTtcclxuICAgfTtcclxuICAgLyoqXHJcbiAgICAqIFRoZSBsb29rdXAgdGFibGVcclxuICAgICovXHJcbiAgIGxldCBfbm90ZUxvb2t1cCA9IHt9O1xyXG4gICBjb25zdCBub3RlTG9va3VwID0gKGtleSkgPT4ge1xyXG4gICAgICAgLy8gYnVpbGROb3RlVGFibGUoKTtcclxuICAgICAgIHJldHVybiBfbm90ZUxvb2t1cFtrZXldO1xyXG4gICB9O1xyXG4gICAvLyByZWdpc3RlckluaXRpYWxpemVyKCgpID0+IHtcclxuICAgLy8gICAgX25vdGVMb29rdXAgPSBjcmVhdGVUYWJsZSgpO1xyXG4gICAvLyB9KTtcclxuICAgLy8gaWYgKHRhYmxlICYmIE9iamVjdC5rZXlzKHRhYmxlKS5sZW5ndGggPiAwKSB7XHJcbiAgIC8vICAgIF9ub3RlTG9va3VwID0gdGFibGU7XHJcbiAgIC8vIH0gZWxzZSB7XHJcbiAgIC8vICAgIF9ub3RlTG9va3VwID0gY3JlYXRlVGFibGUoKTtcclxuICAgLy8gfVxyXG4gICBjb25zdCBidWlsZE5vdGVUYWJsZSA9ICgpID0+IHtcclxuICAgICAgIF9ub3RlTG9va3VwID0gY3JlYXRlVGFibGUkNCgpO1xyXG4gICAgICAgT2JqZWN0LmZyZWV6ZShfbm90ZUxvb2t1cCk7XHJcbiAgICAgICBjb25zb2xlLmxvZyhcImJ1aWx0IG5vdGUgdGFibGVcIik7XHJcbiAgICAgICByZXR1cm4gX25vdGVMb29rdXA7XHJcbiAgIH07XG5cbiAgIC8vIGltcG9ydCB7IHJlZ2lzdGVySW5pdGlhbGl6ZXIgfSBmcm9tIFwiLi4vSW5pdGlhbGl6ZXIvSW5pdGlhbGl6ZXJcIjtcclxuICAgLy8gaW1wb3J0IHRhYmxlIGZyb20gXCIuL25vdGVTdHJpbmdMb29rdXAuanNvblwiO1xyXG4gICBjb25zdCBVTktOT1dOX01PRElGSUVSX05PVEVfU1RSSU5HUyA9IFtcclxuICAgICAgIFwiQ1wiLFxyXG4gICAgICAgXCJDIy9EYlwiLFxyXG4gICAgICAgXCJEXCIsXHJcbiAgICAgICBcIkQjL0ViXCIsXHJcbiAgICAgICBcIkVcIixcclxuICAgICAgIFwiRlwiLFxyXG4gICAgICAgXCJGIy9HYlwiLFxyXG4gICAgICAgXCJHXCIsXHJcbiAgICAgICBcIkcjL0FiXCIsXHJcbiAgICAgICBcIkFcIixcclxuICAgICAgIFwiQSMvQmJcIixcclxuICAgICAgIFwiQlwiLFxyXG4gICBdO1xyXG4gICBjb25zdCBTSEFSUF9OT1RFX1NUUklOR1MgPSBbXHJcbiAgICAgICBcIkNcIixcclxuICAgICAgIFwiQyNcIixcclxuICAgICAgIFwiRFwiLFxyXG4gICAgICAgXCJEI1wiLFxyXG4gICAgICAgXCJFXCIsXHJcbiAgICAgICBcIkZcIixcclxuICAgICAgIFwiRiNcIixcclxuICAgICAgIFwiR1wiLFxyXG4gICAgICAgXCJHI1wiLFxyXG4gICAgICAgXCJBXCIsXHJcbiAgICAgICBcIkEjXCIsXHJcbiAgICAgICBcIkJcIixcclxuICAgXTtcclxuICAgY29uc3QgRkxBVF9NT0RJRklFUl9OT1RFX1NUUklOR1MgPSBbXHJcbiAgICAgICBcIkNcIixcclxuICAgICAgIFwiRGJcIixcclxuICAgICAgIFwiRFwiLFxyXG4gICAgICAgXCJFYlwiLFxyXG4gICAgICAgXCJFXCIsXHJcbiAgICAgICBcIkZcIixcclxuICAgICAgIFwiR2JcIixcclxuICAgICAgIFwiR1wiLFxyXG4gICAgICAgXCJBYlwiLFxyXG4gICAgICAgXCJBXCIsXHJcbiAgICAgICBcIkJiXCIsXHJcbiAgICAgICBcIkJcIixcclxuICAgXTtcclxuICAgY29uc3QgY3JlYXRlVGFibGUkMyA9ICgpID0+IHtcclxuICAgICAgIGNvbnN0IHRhYmxlID0ge307XHJcbiAgICAgICBmb3IgKGxldCBpVG9uZSA9IFRPTkVTX01JTjsgaVRvbmUgPD0gVE9ORVNfTUFYOyArK2lUb25lKSB7XHJcbiAgICAgICAgICAgZm9yIChsZXQgaVByZXYgPSBUT05FU19NSU47IGlQcmV2IDw9IFRPTkVTX01BWDsgKytpUHJldikge1xyXG4gICAgICAgICAgICAgICAvLyBmb3IgKGxldCBpT2N0YXZlID0gT0NUQVZFX01JTjsgaU9jdGF2ZSA8PSBPQ1RBVkVfTUFYOyBpT2N0YXZlKyspIHtcclxuICAgICAgICAgICAgICAgbGV0IG1vZGlmaWVyID0gXCJcIjtcclxuICAgICAgICAgICAgICAgaWYgKE1PRElGSUVEX1NFTUlUT05FUy5pbmNsdWRlcyhpVG9uZSkpIHtcclxuICAgICAgICAgICAgICAgICAgIG1vZGlmaWVyID0gXCItXCI7IC8vIGhhcyBhbiB1bmtub3duIG1vZGlmaWVyXHJcbiAgICAgICAgICAgICAgICAgICAvLyBpZiBpcyBmbGF0XHJcbiAgICAgICAgICAgICAgICAgICBpZiAod3JhcChpVG9uZSArIDEsIFRPTkVTX01JTiwgVE9ORVNfTUFYKS52YWx1ZSA9PT0gaVByZXYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXIgPSBcImJcIjtcclxuICAgICAgICAgICAgICAgICAgIC8vIGlzIHNoYXJwXHJcbiAgICAgICAgICAgICAgICAgICBpZiAod3JhcChpVG9uZSAtIDEsIFRPTkVTX01JTiwgVE9ORVNfTUFYKS52YWx1ZSA9PT0gaVByZXYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXIgPSBcIiNcIjtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAvLyBnZXQgbm90ZSBuYW1lIGZyb20gdGFibGVcclxuICAgICAgICAgICAgICAgdGFibGVbYCR7aVRvbmV9LSR7aVByZXZ9YF0gPSBnZXROb3RlTGFiZWwoaVRvbmUsIG1vZGlmaWVyKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgLy8gfVxyXG4gICAgICAgfVxyXG4gICAgICAgcmV0dXJuIHRhYmxlO1xyXG4gICB9O1xyXG4gICBjb25zdCBnZXROb3RlTGFiZWwgPSAodG9uZSwgbW9kaWZpZXIpID0+IHtcclxuICAgICAgIHN3aXRjaCAobW9kaWZpZXIpIHtcclxuICAgICAgICAgICBjYXNlIFwiI1wiOlxyXG4gICAgICAgICAgICAgICByZXR1cm4gU0hBUlBfTk9URV9TVFJJTkdTW3RvbmVdO1xyXG4gICAgICAgICAgIGNhc2UgXCJiXCI6XHJcbiAgICAgICAgICAgICAgIHJldHVybiBGTEFUX01PRElGSUVSX05PVEVfU1RSSU5HU1t0b25lXTtcclxuICAgICAgICAgICBjYXNlIFwiLVwiOlxyXG4gICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgIHJldHVybiBVTktOT1dOX01PRElGSUVSX05PVEVfU1RSSU5HU1t0b25lXTtcclxuICAgICAgIH1cclxuICAgfTtcclxuICAgbGV0IF9ub3RlU3RyaW5nTG9va3VwID0ge307XHJcbiAgIGNvbnN0IG5vdGVTdHJpbmdMb29rdXAgPSAoa2V5KSA9PiB7XHJcbiAgICAgICAvLyBidWlsZE5vdGVTdHJpbmdUYWJsZSgpO1xyXG4gICAgICAgaWYgKE9iamVjdC5rZXlzKF9ub3RlU3RyaW5nTG9va3VwKS5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgYnVpbGROb3RlU3RyaW5nVGFibGUoKTtcclxuICAgICAgIHJldHVybiBfbm90ZVN0cmluZ0xvb2t1cFtrZXldO1xyXG4gICB9O1xyXG4gICAvLyByZWdpc3RlckluaXRpYWxpemVyKCgpID0+IHtcclxuICAgLy8gICAgX25vdGVTdHJpbmdMb29rdXAgPSBjcmVhdGVUYWJsZSgpO1xyXG4gICAvLyB9KTtcclxuICAgLy8gaWYgKHRhYmxlICYmIE9iamVjdC5rZXlzKHRhYmxlKS5sZW5ndGggPiAwKSB7XHJcbiAgIC8vICAgIF9ub3RlU3RyaW5nTG9va3VwID0gdGFibGU7XHJcbiAgIC8vIH0gZWxzZSB7XHJcbiAgIC8vICAgIF9ub3RlU3RyaW5nTG9va3VwID0gY3JlYXRlVGFibGUoKTtcclxuICAgLy8gfVxyXG4gICBjb25zdCBidWlsZE5vdGVTdHJpbmdUYWJsZSA9ICgpID0+IHtcclxuICAgICAgIC8vIGlmIChPYmplY3Qua2V5cyhfbm90ZVN0cmluZ0xvb2t1cCkubGVuZ3RoID4gMCkgcmV0dXJuIF9ub3RlU3RyaW5nTG9va3VwO1xyXG4gICAgICAgX25vdGVTdHJpbmdMb29rdXAgPSBjcmVhdGVUYWJsZSQzKCk7XHJcbiAgICAgICBPYmplY3QuZnJlZXplKF9ub3RlU3RyaW5nTG9va3VwKTtcclxuICAgICAgIGNvbnNvbGUubG9nKFwiTm90ZSBzdHJpbmcgdGFibGUgYnVpbHQuXCIpO1xyXG4gICAgICAgcmV0dXJuIF9ub3RlU3RyaW5nTG9va3VwO1xyXG4gICB9O1xuXG4gICB2YXIgSURYPTI1NiwgSEVYPVtdLCBTSVpFPTI1NiwgQlVGRkVSO1xuICAgd2hpbGUgKElEWC0tKSBIRVhbSURYXSA9IChJRFggKyAyNTYpLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG5cbiAgIGZ1bmN0aW9uIHVpZChsZW4pIHtcbiAgIFx0dmFyIGk9MCwgdG1wPShsZW4gfHwgMTEpO1xuICAgXHRpZiAoIUJVRkZFUiB8fCAoKElEWCArIHRtcCkgPiBTSVpFKjIpKSB7XG4gICBcdFx0Zm9yIChCVUZGRVI9JycsSURYPTA7IGkgPCBTSVpFOyBpKyspIHtcbiAgIFx0XHRcdEJVRkZFUiArPSBIRVhbTWF0aC5yYW5kb20oKSAqIDI1NiB8IDBdO1xuICAgXHRcdH1cbiAgIFx0fVxuXG4gICBcdHJldHVybiBCVUZGRVIuc3Vic3RyaW5nKElEWCwgSURYKysgKyB0bXApO1xuICAgfVxuXG4gICAvLyBpbXBvcnQgSWRlbnRpZmlhYmxlIGZyb20gXCIuLi9jb21wb3NhYmxlcy9JZGVudGlmaWFibGVcIjtcclxuICAgLyoqXHJcbiAgICAqIEEgbm90ZSBjb25zaXN0IG9mIGEgc2VtaXRvbmUgYW5kIGFuIG9jdGF2ZS48YnI+XHJcbiAgICAqXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICogaW1wb3J0IHsgTm90ZSB9IGZyb20gXCJtdXNpY3RoZW9yeWpzXCI7XHJcbiAgICAqIGltcG9ydCB7IE5vdGVJbml0aWFsaXplciB9IGZyb20gXCJtdXNpY3RoZW9yeWpzXCI7IC8vIHR5cGVzY3JpcHQgb25seSBpZiBuZWVkZWRcclxuICAgICogYGBgXHJcbiAgICAqL1xyXG4gICBjbGFzcyBOb3RlIHtcclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGltcG9ydCB7IE5vdGUgfSBmcm9tIFwibXVzaWN0aGVvcnlqc1wiO1xyXG4gICAgICAgICpcclxuICAgICAgICAqIC8vIGNyZWF0ZXMgYSBuZXcgbm90ZSB3aXRoIGRlZmF1bHQgdmFsdWVzIHNlbWl0b25lIDAoQykgYW5kIG9jdGF2ZSA0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gbmV3IE5vdGUoKTtcclxuICAgICAgICAqXHJcbiAgICAgICAgKiAvLyBjcmVhdGVzIGEgbmV3IG5vdGUgdXNpbmcgYW4gaW5pdGlhbGl6ZXIgb2JqZWN0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gbmV3IE5vdGUoe3NlbWl0b25lOiA0LCBvY3RhdmU6IDV9KTtcclxuICAgICAgICAqXHJcbiAgICAgICAgKiAvLyBTdHJpbmcgcGFyc2luZyBzaG91bGQgZm9sbG93IHRoZSBmb3JtYXQ6IG5vdGUtbmFtZVttb2RpZmllcl1bb2N0YXZlXVxyXG4gICAgICAgICogLy8gY3JlYXRlcyBhIG5ldyBub3RlIHVzaW5nIGEgc3RyaW5nXHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gbmV3IE5vdGUoXCJDNVwiKTtcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcclxuICAgICAgICAgICBpZiAoIXZhbHVlcykge1xyXG4gICAgICAgICAgICAgICB0aGlzLm9jdGF2ZSA9IERFRkFVTFRfT0NUQVZFO1xyXG4gICAgICAgICAgICAgICB0aGlzLnNlbWl0b25lID0gREVGQVVMVF9TRU1JVE9ORTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlcyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICB2YWx1ZXMgPSBwYXJzZU5vdGUodmFsdWVzKTtcclxuICAgICAgICAgICAgICAgdGhpcy5vY3RhdmUgPSB2YWx1ZXM/Lm9jdGF2ZSA/PyBERUZBVUxUX09DVEFWRTtcclxuICAgICAgICAgICAgICAgdGhpcy5zZW1pdG9uZSA9IHZhbHVlcz8uc2VtaXRvbmUgPz8gREVGQVVMVF9TRU1JVE9ORTtcclxuICAgICAgICAgICAgICAgdGhpcy5fcHJldlNlbWl0b25lID0gdGhpcy5fdG9uZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgIC8vIGltcG9ydGFudCB0aGF0IG9jdGF2ZSBpcyBzZXQgZmlyc3Qgc28gdGhhdFxyXG4gICAgICAgICAgICAgICAvLyBzZXR0aW5nIHRoZSBzZW1pdG9uZSBjYW4gY2hhbmdlIHRoZSBvY3RhdmVcclxuICAgICAgICAgICAgICAgdGhpcy5vY3RhdmUgPSB2YWx1ZXM/Lm9jdGF2ZSA/PyBERUZBVUxUX09DVEFWRTtcclxuICAgICAgICAgICAgICAgdGhpcy5zZW1pdG9uZSA9IHZhbHVlcz8uc2VtaXRvbmUgPz8gREVGQVVMVF9TRU1JVE9ORTtcclxuICAgICAgICAgICAgICAgdGhpcy5fcHJldlNlbWl0b25lID0gdGhpcy5fdG9uZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqICB1bmlxdWUgaWQgZm9yIHRoaXMgbm90ZShhdXRvIGdlbmVyYXRlZClcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gbmV3IE5vdGUoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKG5vdGUuaWQpOyAvLyBzMjg5OHNubG9qXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgaWQgPSB1aWQoKTtcclxuICAgICAgIC8qKlxyXG4gICAgICAgICogc2VtaXRvbmVcclxuICAgICAgICAqL1xyXG4gICAgICAgX3RvbmUgPSBERUZBVUxUX1NFTUlUT05FO1xyXG4gICAgICAgX3ByZXZTZW1pdG9uZSA9IERFRkFVTFRfU0VNSVRPTkU7XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gbmV3IE5vdGUoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKG5vdGUuc2VtaXRvbmUpOyAvLyAwXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgZ2V0IHNlbWl0b25lKCkge1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzLl90b25lO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBzZXR0aW5nIHRoZSBzZW1pdG9uZSB3aXRoIGEgbnVtYmVyIG91dHNpZGUgdGhlXHJcbiAgICAgICAgKiByYW5nZSBvZiAwLTExIHdpbGwgd3JhcCB0aGUgdmFsdWUgYXJvdW5kIGFuZFxyXG4gICAgICAgICogY2hhbmdlIHRoZSBvY3RhdmUgYWNjb3JkaW5nbHlcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gbmV3IE5vdGUoKTtcclxuICAgICAgICAqIG5vdGUuc2VtaXRvbmUgPSA0Oy8vIEVcclxuICAgICAgICAqIGNvbnNvbGUubG9nKG5vdGUuc2VtaXRvbmUpOyAvLyA0KEUpXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgc2V0IHNlbWl0b25lKHNlbWl0b25lKSB7XHJcbiAgICAgICAgICAgY29uc3Qgd3JhcHBlZCA9IHdyYXAoc2VtaXRvbmUsIFRPTkVTX01JTiwgVE9ORVNfTUFYKTtcclxuICAgICAgICAgICB0aGlzLl9wcmV2U2VtaXRvbmUgPSB0aGlzLl90b25lO1xyXG4gICAgICAgICAgIHRoaXMuX3RvbmUgPSB3cmFwcGVkLnZhbHVlO1xyXG4gICAgICAgICAgIHRoaXMuX29jdGF2ZSA9IHRoaXMuX29jdGF2ZSArIHdyYXBwZWQubnVtV3JhcHM7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIG9jdGF2ZVxyXG4gICAgICAgICovXHJcbiAgICAgICBfb2N0YXZlID0gREVGQVVMVF9PQ1RBVkU7XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gbmV3IE5vdGUoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKG5vdGUub2N0YXZlKTsgLy8gNFxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGdldCBvY3RhdmUoKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX29jdGF2ZTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIG9jdGF2ZSBpcyBjbGFtcGVkIHRvIHRoZSByYW5nZSBbMCwgOV0uXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3Qgbm90ZSA9IG5ldyBOb3RlKCk7XHJcbiAgICAgICAgKiBub3RlLm9jdGF2ZSA9IDEwO1xyXG4gICAgICAgICogY29uc29sZS5sb2cobm90ZS5vY3RhdmUpOyAvLyA5KGJlY2F1c2Ugb2YgY2xhbXBpbmcpXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgc2V0IG9jdGF2ZShvY3RhdmUpIHtcclxuICAgICAgICAgICB0aGlzLl9vY3RhdmUgPSBjbGFtcChvY3RhdmUsIE9DVEFWRV9NSU4sIE9DVEFWRV9NQVgpO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAY2hhaW5hYmxlXHJcbiAgICAgICAgKiBAcmV0dXJucyBhIG5ldyBub3RlIHRoYXQgaXMgYSBzaGFycGVuZWQgdmVyc2lvbiBvZiB0aGlzIG5vdGUuXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3Qgbm90ZSA9IG5ldyBOb3RlKCk7IC8vIGRlZmF1bHQgc2VtaXRvbmUgaXMgMChDKVxyXG4gICAgICAgICogY29uc3Qgbm90ZTIgPSBub3RlLnNoYXJwKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhub3RlMi5zZW1pdG9uZSk7IC8vIDEoQyMpXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgc2hhcnAoKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIG5ldyBOb3RlKHtcclxuICAgICAgICAgICAgICAgc2VtaXRvbmU6IHRoaXMuc2VtaXRvbmUsXHJcbiAgICAgICAgICAgICAgIG9jdGF2ZTogdGhpcy5vY3RhdmUsXHJcbiAgICAgICAgICAgfSkuc2hhcnBlbigpO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBTaGFycGVucyB0aGUgbm90ZSBpbiBwbGFjZS5cclxuICAgICAgICAqIEBjaGFpbmFibGVcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gbmV3IE5vdGUoKTsgLy8gZGVmYXVsdCBzZW1pdG9uZSBpcyAwKEMpXHJcbiAgICAgICAgKiBub3RlLnNoYXJwZW4oKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKG5vdGUuc2VtaXRvbmUpOyAvLyAxKEMjKVxyXG4gICAgICAgICovXHJcbiAgICAgICBzaGFycGVuKCkge1xyXG4gICAgICAgICAgIHRoaXMuc2VtaXRvbmUgPSB0aGlzLnNlbWl0b25lICsgMTtcclxuICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogIGF0dGVtcHRzIHRvIGRldGVybWluZSBpZiB0aGUgbm90ZSBpcyBzaGFycFxyXG4gICAgICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm90ZSBpcyBzaGFycFxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IG5vdGUgPSBuZXcgTm90ZSgpOyAvLyBkZWZhdWx0IHNlbWl0b25lIGlzIDAoQylcclxuICAgICAgICAqIGNvbnNvbGUubG9nKG5vdGUuaXNTaGFycCgpKTsgLy8gZmFsc2VcclxuICAgICAgICAqIG5vdGUuc2hhcnBlbigpO1xyXG4gICAgICAgICogY29uc29sZS5sb2cobm90ZS5pc1NoYXJwKCkpOyAvLyB0cnVlXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgaXNTaGFycCgpIHtcclxuICAgICAgICAgICAvLyBpZiBub3RlIGlzIHdob2xlLCBpdCBjYW4ndCBiZSBzaGFycFxyXG4gICAgICAgICAgIGNvbnN0IG1vZGlmaWVkID0gTU9ESUZJRURfU0VNSVRPTkVTLmluY2x1ZGVzKHRoaXMuc2VtaXRvbmUpO1xyXG4gICAgICAgICAgIGlmICghbW9kaWZpZWQpXHJcbiAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAvLyBpZiBub3RlIGlzIGZsYXQsIGl0IGNhbid0IGJlIHNoYXJwXHJcbiAgICAgICAgICAgaWYgKHdyYXAodGhpcy5zZW1pdG9uZSArIDEsIFRPTkVTX01JTiwgVE9ORVNfTUFYKS52YWx1ZSA9PT1cclxuICAgICAgICAgICAgICAgdGhpcy5fcHJldlNlbWl0b25lKVxyXG4gICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vaXMgZmxhdFxyXG4gICAgICAgICAgIC8vIERvZXNuJ3QgbmVjY2VjYXJpbHkgbWVhbiBpdCdzIHNoYXJwLCBidXQgaXQncyBhIGdvb2QgZ3Vlc3MgYXQgdGhpcyBwb2ludFxyXG4gICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBSZXR1cm5zIGEgbmV3IG5vdGUgdGhhdCBpcyBhIGZsYXR0ZW5lZCB2ZXJzaW9uIG9mIHRoaXMgbm90ZS5cclxuICAgICAgICAqIEBjaGFpbmFibGVcclxuICAgICAgICAqIEByZXR1cm5zIGEgbmV3IG5vdGUgdGhhdCBpcyBhIGZsYXR0ZW5lZCB2ZXJzaW9uIG9mIHRoaXMgbm90ZS5cclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gbmV3IE5vdGUoKTsgLy8gZGVmYXVsdCBzZW1pdG9uZSBpcyAwKEMpXHJcbiAgICAgICAgKiBjb25zdCBub3RlMiA9IG5vdGUuZmxhdCgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2cobm90ZTIuc2VtaXRvbmUpOyAvLyAzKEViKVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZsYXQoKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIG5ldyBOb3RlKHtcclxuICAgICAgICAgICAgICAgc2VtaXRvbmU6IHRoaXMuc2VtaXRvbmUsXHJcbiAgICAgICAgICAgICAgIG9jdGF2ZTogdGhpcy5vY3RhdmUsXHJcbiAgICAgICAgICAgfSkuZmxhdHRlbigpO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBGbGF0dGVucyB0aGUgbm90ZSBpbiBwbGFjZS5cclxuICAgICAgICAqIEBjaGFpbmFibGVcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gbmV3IE5vdGUoe3NlbWl0b25lOiA0fSk7IC8vICBzZW1pdG9uZSBpcyA0KEUpXHJcbiAgICAgICAgKiBub3RlLmZsYXR0ZW4oKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKG5vdGUuc2VtaXRvbmUpOyAvLyAzKEViKVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGZsYXR0ZW4oKSB7XHJcbiAgICAgICAgICAgdGhpcy5zZW1pdG9uZSA9IHRoaXMuc2VtaXRvbmUgLSAxO1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiAgYXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBub3RlIGlzIGZsYXRcclxuICAgICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vdGUgaXMgZmxhdFxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IG5vdGUgPSBuZXcgTm90ZSgpOyAvLyBkZWZhdWx0IHNlbWl0b25lIGlzIDAoQylcclxuICAgICAgICAqIGNvbnNvbGUubG9nKG5vdGUuaXNGbGF0KCkpOyAvLyBmYWxzZVxyXG4gICAgICAgICogbm90ZS5mbGF0dGVuKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhub3RlLmlzRmxhdCgpKTsgLy8gdHJ1ZVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGlzRmxhdCgpIHtcclxuICAgICAgICAgICAvLyBpZiBub3RlIGlzIHdob2xlLCBpdCBjYW4ndCBiZSBzaGFycFxyXG4gICAgICAgICAgIGNvbnN0IG1vZGlmaWVkID0gTU9ESUZJRURfU0VNSVRPTkVTLmluY2x1ZGVzKHRoaXMuc2VtaXRvbmUpO1xyXG4gICAgICAgICAgIGlmICghbW9kaWZpZWQpXHJcbiAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAvLyBpZiBub3RlIGlzIHNoYXJwLCBpdCBjYW4ndCBiZSBmbGF0XHJcbiAgICAgICAgICAgaWYgKHdyYXAodGhpcy5zZW1pdG9uZSAtIDEsIFRPTkVTX01JTiwgVE9ORVNfTUFYKS52YWx1ZSA9PT1cclxuICAgICAgICAgICAgICAgdGhpcy5fcHJldlNlbWl0b25lKVxyXG4gICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vaXMgc2hhcnBcclxuICAgICAgICAgICAvLyBEb2Vzbid0IG5lY2NlY2FyaWx5IG1lYW4gaXQncyBmbGF0LCBidXQgaXQncyBhIGdvb2QgZ3Vlc3MgYXQgdGhpcyBwb2ludFxyXG4gICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgbm90ZSBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gbm90ZVxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IG5vdGUgPSBuZXcgTm90ZSgpO1xyXG4gICAgICAgICogY29uc3Qgbm90ZTIgPSBuZXcgTm90ZSgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2cobm90ZS5lcXVhbHMobm90ZTIpKTsgLy8gdHJ1ZVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGVxdWFscyhub3RlKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VtaXRvbmUgPT09IG5vdGUuc2VtaXRvbmUgJiYgdGhpcy5vY3RhdmUgPT09IG5vdGUub2N0YXZlO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcmV0dXJucyBhIGNvcHkgb2YgdGhpcyBub3RlXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3Qgbm90ZSA9IG5ldyBOb3RlKCk7IC8vIGRlZmF1bHQgc2VtaXRvbmUgaXMgMChDKVxyXG4gICAgICAgICogY29uc3Qgbm90ZTIgPSBub3RlLmNvcHkoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKG5vdGUuZXF1YWxzKG5vdGUyKSk7IC8vIHRydWVcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBjb3B5KCkge1xyXG4gICAgICAgICAgIHJldHVybiBuZXcgTm90ZSh7XHJcbiAgICAgICAgICAgICAgIHNlbWl0b25lOiB0aGlzLnNlbWl0b25lLFxyXG4gICAgICAgICAgICAgICBvY3RhdmU6IHRoaXMub2N0YXZlLFxyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHZlcnNpb24gb2YgdGhpcyBub3RlXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3Qgbm90ZSA9IG5ldyBOb3RlKCk7IC8vIGRlZmF1bHQgc2VtaXRvbmUgaXMgMChDKVxyXG4gICAgICAgICogY29uc29sZS5sb2cobm90ZS50b1N0cmluZygpKTsgLy8gQzRcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICpcclxuICAgICAgICAqL1xyXG4gICAgICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgICAgLy8gY29uc29sZS5sb2cobm90ZVN0cmluZ0xvb2t1cCk7XHJcbiAgICAgICAgICAgcmV0dXJuIChub3RlU3RyaW5nTG9va3VwKGAke3RoaXMuX3RvbmV9LSR7dGhpcy5fcHJldlNlbWl0b25lfWApICtcclxuICAgICAgICAgICAgICAgYCR7dGhpcy5fb2N0YXZlfWApO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBTdGF0aWMgbWV0aG9kcyB0byBjcmVhdGUgd2hvbGUgbm90ZXMgZWFzaWx5LlxyXG4gICAgICAgICogdGhlIGRlZmF1bHQgb2N0YXZlIGlzIDRcclxuICAgICAgICAqL1xyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgKiBAcGFyYW0gb2N0YXZlXHJcbiAgICAgICAgKiBAcmV0dXJucyBub3RlIHNldCB0byBBW29jdGF2ZV1cclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gTm90ZS5BKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhub3RlLnRvU3RyaW5nKCkpOyAvLyBBNFxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHN0YXRpYyBBKG9jdGF2ZSA9IDQpIHtcclxuICAgICAgICAgICByZXR1cm4gbmV3IE5vdGUoe1xyXG4gICAgICAgICAgICAgICBzZW1pdG9uZTogU2VtaXRvbmUkMS5BLFxyXG4gICAgICAgICAgICAgICBvY3RhdmUsXHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqXHJcbiAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgKiBAcGFyYW0gb2N0YXZlXHJcbiAgICAgICAgKiBAcmV0dXJucyBub3RlIHNldCB0byBCW29jdGF2ZV1cclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gTm90ZS5CKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhub3RlLnRvU3RyaW5nKCkpOyAvLyBCNFxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHN0YXRpYyBCKG9jdGF2ZSA9IDQpIHtcclxuICAgICAgICAgICByZXR1cm4gbmV3IE5vdGUoe1xyXG4gICAgICAgICAgICAgICBzZW1pdG9uZTogU2VtaXRvbmUkMS5CLFxyXG4gICAgICAgICAgICAgICBvY3RhdmUsXHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqXHJcbiAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgKiBAcGFyYW0gb2N0YXZlXHJcbiAgICAgICAgKiBAcmV0dXJucyBub3RlIHNldCB0byBDW29jdGF2ZV1cclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gTm90ZS5DKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhub3RlLnRvU3RyaW5nKCkpOyAvLyBDNFxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHN0YXRpYyBDKG9jdGF2ZSA9IDQpIHtcclxuICAgICAgICAgICByZXR1cm4gbmV3IE5vdGUoe1xyXG4gICAgICAgICAgICAgICBzZW1pdG9uZTogU2VtaXRvbmUkMS5DLFxyXG4gICAgICAgICAgICAgICBvY3RhdmUsXHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqXHJcbiAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgKiBAcGFyYW0gb2N0YXZlXHJcbiAgICAgICAgKiBAcmV0dXJucyBub3RlIHNldCB0byBEW29jdGF2ZV1cclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gTm90ZS5EKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhub3RlLnRvU3RyaW5nKCkpOyAvLyBENFxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHN0YXRpYyBEKG9jdGF2ZSA9IDQpIHtcclxuICAgICAgICAgICByZXR1cm4gbmV3IE5vdGUoe1xyXG4gICAgICAgICAgICAgICBzZW1pdG9uZTogU2VtaXRvbmUkMS5ELFxyXG4gICAgICAgICAgICAgICBvY3RhdmUsXHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqXHJcbiAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgKiBAcGFyYW0gb2N0YXZlXHJcbiAgICAgICAgKiBAcmV0dXJucyBub3RlIHNldCB0byBFW29jdGF2ZV1cclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gTm90ZS5FKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhub3RlLnRvU3RyaW5nKCkpOyAvLyBFNFxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHN0YXRpYyBFKG9jdGF2ZSA9IDQpIHtcclxuICAgICAgICAgICByZXR1cm4gbmV3IE5vdGUoe1xyXG4gICAgICAgICAgICAgICBzZW1pdG9uZTogU2VtaXRvbmUkMS5FLFxyXG4gICAgICAgICAgICAgICBvY3RhdmUsXHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqXHJcbiAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgKiBAcGFyYW0gb2N0YXZlXHJcbiAgICAgICAgKiBAcmV0dXJucyBub3RlIHNldCB0byBGW29jdGF2ZV1cclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gTm90ZS5GKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhub3RlLnRvU3RyaW5nKCkpOyAvLyBGNFxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHN0YXRpYyBGKG9jdGF2ZSA9IDQpIHtcclxuICAgICAgICAgICByZXR1cm4gbmV3IE5vdGUoe1xyXG4gICAgICAgICAgICAgICBzZW1pdG9uZTogU2VtaXRvbmUkMS5GLFxyXG4gICAgICAgICAgICAgICBvY3RhdmUsXHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqXHJcbiAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgKiBAcGFyYW0gb2N0YXZlXHJcbiAgICAgICAgKiBAcmV0dXJucyBub3RlIHNldCB0byBHW29jdGF2ZV1cclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBub3RlID0gTm90ZS5HKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhub3RlLnRvU3RyaW5nKCkpOyAvLyBHNFxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHN0YXRpYyBHKG9jdGF2ZSA9IDQpIHtcclxuICAgICAgICAgICByZXR1cm4gbmV3IE5vdGUoe1xyXG4gICAgICAgICAgICAgICBzZW1pdG9uZTogU2VtaXRvbmUkMS5HLFxyXG4gICAgICAgICAgICAgICBvY3RhdmUsXHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICB9XHJcbiAgIH1cblxuICAgLyoqXHJcbiAgICAqIENvbnN0YW50c1xyXG4gICAgKi9cclxuICAgY29uc3QgTUlESUtFWV9TVEFSVCA9IDEyO1xyXG4gICBjb25zdCBOVU1fT0NUQVZFUyA9IDEwO1xyXG4gICBjb25zdCBOVU1fU0VNSVRPTkVTID0gMTI7XHJcbiAgIC8qKlxyXG4gICAgKiBDYWxjdWxhdGVzIHRoZSBtaWRpIGtleSBmb3IgYSBnaXZlbiBvY3RhdmUgYW5kIHNlbWl0b25lLlxyXG4gICAgKi9cclxuICAgY29uc3QgY2FsY01pZGlLZXkgPSAob2N0YXZlLCBzZW1pdG9uZSkgPT4gTUlESUtFWV9TVEFSVCArIG9jdGF2ZSAqIE5VTV9TRU1JVE9ORVMgKyBzZW1pdG9uZTtcclxuICAgLyoqXHJcbiAgICAqIENhbGN1bGF0ZXMgdGhlIGZyZXF1ZW5jeSBmb3IgYSBnaXZlbiBvY3RhdmUgYW5kIHNlbWl0b25lIGdpdmVuXHJcbiAgICAqIGEgdHVuaW5nIGZvciBhNC5cclxuICAgICovXHJcbiAgIGNvbnN0IGNhbGNGcmVxdWVuY3kgPSAobWlkaUtleSwgYTRUdW5pbmcpID0+IDIgKiogKChtaWRpS2V5IC0gNjkpIC8gMTIpICogYTRUdW5pbmc7XHJcbiAgIC8qKlxyXG4gICAgKiBDcmVhdGVzIGFuZCByZXR1cm4gbG9va3VwIHRhYmxlcyBmb3IgbWlkaWtleSBhbmQgZnJlcXVlbmN5LlxyXG4gICAgKi9cclxuICAgY29uc3QgY3JlYXRlVGFibGVzID0gKGE0VHVuaW5nID0gNDQwKSA9PiB7XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIE1hcHMgb2N0YXZlIGFuZCBzZW1pdG9uZSB0byBub3RlIGZyZXF1ZW5jeShoZXJ0eikuXHJcbiAgICAgICAgKiByZXF1aXJlcyBhIGtleSBpbiB0aGUgZm9ybSBvZiBgPG9jdGF2ZT4tPHNlbWl0b25lPmBcclxuICAgICAgICAqL1xyXG4gICAgICAgY29uc3QgZnJlcVRhYmxlID0ge307XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIE1hcHMgb2N0YXZlIGFuZCBzZW1pdG9uZSB0byBtaWRpIGtleS5cclxuICAgICAgICAqIHJlcXVpcmVzIGEga2V5IGluIHRoZSBmb3JtIG9mIGA8b2N0YXZlPi08c2VtaXRvbmU+YFxyXG4gICAgICAgICovXHJcbiAgICAgICBjb25zdCBtaWRpVGFibGUgPSB7fTtcclxuICAgICAgIGxldCBpT2N0YXZlID0gMDtcclxuICAgICAgIGxldCBpU2VtaXRvbmUgPSAwO1xyXG4gICAgICAgZm9yIChpT2N0YXZlID0gMDsgaU9jdGF2ZSA8IE5VTV9PQ1RBVkVTOyArK2lPY3RhdmUpIHtcclxuICAgICAgICAgICBmb3IgKGlTZW1pdG9uZSA9IDA7IGlTZW1pdG9uZSA8IE5VTV9TRU1JVE9ORVM7ICsraVNlbWl0b25lKSB7XHJcbiAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2lPY3RhdmV9LSR7aVNlbWl0b25lfWA7XHJcbiAgICAgICAgICAgICAgIGNvbnN0IG1rZXkgPSBjYWxjTWlkaUtleShpT2N0YXZlLCBpU2VtaXRvbmUpO1xyXG4gICAgICAgICAgICAgICBjb25zdCBmcmVxID0gY2FsY0ZyZXF1ZW5jeShta2V5LCBhNFR1bmluZyk7XHJcbiAgICAgICAgICAgICAgIG1pZGlUYWJsZVtrZXldID0gbWtleTtcclxuICAgICAgICAgICAgICAgZnJlcVRhYmxlW2tleV0gPSBmcmVxO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH1cclxuICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgZnJlcUxvb2t1cDogZnJlcVRhYmxlLFxyXG4gICAgICAgICAgIG1pZGlMb29rdXA6IG1pZGlUYWJsZSxcclxuICAgICAgIH07XHJcbiAgIH07XG5cbiAgIC8qKlxyXG4gICAgKiBUdW5pbmcgY29tcG9uZW50IHVzZWQgYnkgSW5zdHJ1bWVudCBjbGFzczxicj5cclxuICAgICogY29udGFpbmVzIHRoZSBhNCB0dW5pbmcgLSBkZWZhdWx0IGlzIDQ0MEh6PGJyPlxyXG4gICAgKiBidWlsZHMgbG9va3VwIHRhYmxlcyBmb3IgbWlkaSBrZXkgYW5kIGZyZXF1ZW5jeTxicj5cclxuICAgICogYmFzZWQgb24gdGhlIHR1bmluZ1xyXG4gICAgKiBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgIGNsYXNzIFR1bmluZyB7XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIENyZWF0ZXMgdGhlIG9iamVjdCBhbmQgYnVpbGRzIHRoZSBsb29rdXAgdGFibGVzLlxyXG4gICAgICAgICovXHJcbiAgICAgICBjb25zdHJ1Y3RvcihhNEZyZXEgPSA0NDApIHtcclxuICAgICAgICAgICB0aGlzLl9hNCA9IGE0RnJlcTtcclxuICAgICAgICAgICB0aGlzLmJ1aWxkVGFibGVzKCk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIHVuaXF1ZSBpZCBmb3IgdGhpcyBpbnN0YW5jZVxyXG4gICAgICAgICovXHJcbiAgICAgICBpZCA9IHVpZCgpO1xyXG4gICAgICAgY29weSgpIHtcclxuICAgICAgICAgICByZXR1cm4gbmV3IFR1bmluZyh0aGlzLl9hNCk7XHJcbiAgICAgICB9XHJcbiAgICAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICAgICByZXR1cm4gdGhpcy5fYTQgPT09IG90aGVyLl9hNDtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogYTQgVHVuaW5nXHJcbiAgICAgICAgKi9cclxuICAgICAgIF9hNCA9IDQ0MDtcclxuICAgICAgIGdldCBhNCgpIHtcclxuICAgICAgICAgICByZXR1cm4gdGhpcy5fYTQ7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIHNldHRpbmcgdGhlIHR1bmluZyB3aWxsIHJlYnVpbGQgdGhlIGxvb2t1cCB0YWJsZXNcclxuICAgICAgICAqL1xyXG4gICAgICAgc2V0IGE0KHZhbHVlKSB7XHJcbiAgICAgICAgICAgdGhpcy5fYTQgPSB2YWx1ZTtcclxuICAgICAgICAgICB0aGlzLmJ1aWxkVGFibGVzKCk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIGxvb2t1cCB0YWJsZSBmb3IgbWlkaSBrZXlcclxuICAgICAgICAqL1xyXG4gICAgICAgX21pZGlLZXlUYWJsZSA9IHt9O1xyXG4gICAgICAgbWlkaUtleUxvb2t1cChvY3RhdmUsIHNlbWl0b25lKSB7XHJcbiAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7b2N0YXZlfS0ke3NlbWl0b25lfWA7XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX21pZGlLZXlUYWJsZVtrZXldO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBsb29rdXAgdGFibGUgZm9yIGZyZXF1ZW5jeVxyXG4gICAgICAgICovXHJcbiAgICAgICBfZnJlcVRhYmxlID0ge307XHJcbiAgICAgICBmcmVxTG9va3VwKG9jdGF2ZSwgc2VtaXRvbmUpIHtcclxuICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtvY3RhdmV9LSR7c2VtaXRvbmV9YDtcclxuICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJlcVRhYmxlW2tleV07XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEJ1aWxkcyB0aGUgbG9va3VwIHRhYmxlcyBmb3IgbWlkaSBrZXkgYW5kIGZyZXF1ZW5jeVxyXG4gICAgICAgICovXHJcbiAgICAgICBidWlsZFRhYmxlcygpIHtcclxuICAgICAgICAgICBjb25zdCB0YWJsZXMgPSBjcmVhdGVUYWJsZXModGhpcy5fYTQpO1xyXG4gICAgICAgICAgIHRoaXMuX21pZGlLZXlUYWJsZSA9IHRhYmxlcy5taWRpTG9va3VwO1xyXG4gICAgICAgICAgIHRoaXMuX2ZyZXFUYWJsZSA9IHRhYmxlcy5mcmVxTG9va3VwO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiByZXR1cm5zIHRoZSB0dW5pbmcgYXMgYSBzdHJpbmdcclxuICAgICAgICAqL1xyXG4gICAgICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIGBUdW5pbmcoJHt0aGlzLl9hNH0pYDtcclxuICAgICAgIH1cclxuICAgfVxuXG4gICAvKipcclxuICAgICogSW5zdHJ1bWVudCBhcmUgdXNlZCB0byBlbmNhcHN1bGF0ZSB0aGUgdHVuaW5nIGFuZCByZXRyaWV2aW5nIG9mIG1pZGkga2V5c1xyXG4gICAgKiBhbmQgZnJlcXVlbmNpZXMgZm9yIG5vdGVzXHJcbiAgICAqXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICogaW1wb3J0IHsgSW5zdHJ1bWVudCB9IGZyb20gXCJtdXNpY3RoZW9yeWpzXCI7XHJcbiAgICAqL1xyXG4gICBjbGFzcyBJbnN0cnVtZW50IHtcclxuICAgICAgIHR1bmluZztcclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHBhcmFtIHR1bmluZyBBNCBmcmVxdWVuY3kgLSBkZWZhdWx0cyB0byA0NDBcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBpbnN0cnVtZW50ID0gbmV3IEluc3RydW1lbnQoKTsgLy8gZGVmYXVsdCA0NDAgdHVuaW5nXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgY29uc3RydWN0b3IoYTRGcmVxID0gNDQwKSB7XHJcbiAgICAgICAgICAgdGhpcy50dW5pbmcgPSBuZXcgVHVuaW5nKGE0RnJlcSk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEByZXR1cm5zIGEgdW5pcXVlIGlkIGZvciB0aGlzIGluc3RhbmNlXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3QgaW5zdHJ1bWVudCA9IG5ldyBJbnN0cnVtZW50KCk7XHJcbiAgICAgICAgKiBpbnN0cnVtZW50LmlkOyAvLyByZXR1cm5zIGEgdW5pcXVlIGlkXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgaWQgPSB1aWQoKTtcclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoaXMgaW5zdGFuY2VcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBpbnN0cnVtZW50ID0gbmV3IEluc3RydW1lbnQoKTtcclxuICAgICAgICAqIGNvbnN0IGNvcHkgPSBpbnN0cnVtZW50LmNvcHkoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKGluc3RydW1lbnQuZXF1YWxzKGNvcHkpKTsgLy8gdHJ1ZVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGNvcHkoKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIG5ldyBJbnN0cnVtZW50KHRoaXMudHVuaW5nLmE0KTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHBhcmFtIG90aGVyIHRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZVxyXG4gICAgICAgICogQHJldHVybnMgIHRydWUgaWYgdGhlIG90aGVyIG9iamVjdCBpcyBlcXVhbCB0byB0aGlzIG9uZVxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGluc3RydW1lbnQgPSBuZXcgSW5zdHJ1bWVudCgpO1xyXG4gICAgICAgICogY29uc3QgY29weSA9IGluc3RydW1lbnQuY29weSgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coaW5zdHJ1bWVudC5lcXVhbHMoY29weSkpOyAvLyB0cnVlXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXMudHVuaW5nLmVxdWFscyhvdGhlci50dW5pbmcpO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcmV0dXJucyB0aGUgZnJlcXVlbmN5IG9mIHRoZSBnaXZlbiBub3RlXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3QgaW5zdHJ1bWVudCA9IG5ldyBJbnN0cnVtZW50KCk7XHJcbiAgICAgICAgKiBpbnN0cnVtZW50LmdldEZyZXF1ZW5jeShuZXcgTm90ZShcIkM0XCIpKTsgLy8gcmV0dXJucyAyNjEuNjI1NTY1MzAwNTk4NlxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGdldEZyZXF1ZW5jeShub3RlKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXMudHVuaW5nLmZyZXFMb29rdXAobm90ZS5vY3RhdmUsIG5vdGUuc2VtaXRvbmUpO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcmV0dXJucyB0aGUgbWlkaSBrZXkgb2YgdGhlIGdpdmVuIG5vdGVcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBpbnN0cnVtZW50ID0gbmV3IEluc3RydW1lbnQoKTtcclxuICAgICAgICAqIGluc3RydW1lbnQuZ2V0TWlkaUtleShuZXcgTm90ZShcIkM0XCIpKTsgLy8gcmV0dXJucyA2MFxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGdldE1pZGlLZXkobm90ZSkge1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzLnR1bmluZy5taWRpS2V5TG9va3VwKG5vdGUub2N0YXZlLCBub3RlLnNlbWl0b25lKTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQHJldHVybnMgdGhlIHR1bmluZyBhcyBhIHN0cmluZ1xyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGluc3RydW1lbnQgPSBuZXcgSW5zdHJ1bWVudCgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coaW5zdHJ1bWVudC50b1N0cmluZygpKTsgLy8gcmV0dXJucyBcIkluc3RydW1lbnQgVHVuaW5nKDQ0MClcIlxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgICAgIHJldHVybiBgSW5zdHJ1bWVudCBUdW5pbmcoJHt0aGlzLnR1bmluZy5hNH0pYDtcclxuICAgICAgIH1cclxuICAgfVxuXG4gICBjb25zdCBERUZBVUxUX1NDQUxFX1RFTVBMQVRFID0gWzAsIDIsIDIsIDEsIDIsIDIsIDJdOyAvLyBtYWpvclxyXG4gICBPYmplY3QuZnJlZXplKERFRkFVTFRfU0NBTEVfVEVNUExBVEUpO1xuXG4gICAvKipcclxuICAgICogTWFwcyBwcmVkZWZpbmVkIHNjYWxlcyB0byB0aGVpciBuYW1lcy5cclxuICAgICovXHJcbiAgIGNvbnN0IFNjYWxlVGVtcGxhdGVzID0ge1xyXG4gICAgICAgd2hvbGVUb25lOiBbMCwgMiwgMiwgMiwgMiwgMiwgMl0sXHJcbiAgICAgICAvLyBtYWpvclxyXG4gICAgICAgbWFqb3I6IFswLCAyLCAyLCAxLCAyLCAyLCAyXSxcclxuICAgICAgIG1ham9yN3M0czU6IFswLCAyLCAyLCAyLCAyLCAxLCAyXSxcclxuICAgICAgIC8vIG1vZGVzXHJcbiAgICAgICAvLyBpb25pYW46IFtdLCAvLyBzZXQgYmVsb3cgLSBzYW1lIGFzIG1ham9yXHJcbiAgICAgICAvLyBhZW9saWFuOiBbXSwgLy8gc2V0IGJlbG93IC0gc2FtZSBhcyBtaW5vclxyXG4gICAgICAgZG9yaWFuOiBbMCwgMiwgMSwgMiwgMiwgMiwgMV0sXHJcbiAgICAgICBwaHJ5Z2lhbjogWzAsIDEsIDIsIDIsIDIsIDEsIDJdLFxyXG4gICAgICAgbHlkaWFuOiBbMCwgMiwgMiwgMiwgMSwgMiwgMl0sXHJcbiAgICAgICBseWRpYW5Eb21pbmFudDogWzAsIDIsIDIsIDIsIDEsIDIsIDFdLFxyXG4gICAgICAgLy8gYWNvdXN0aWM6IFtdLCAvLyBzZXQgYmVsb3cgLSBzYW1lIGFzIGx5ZGlhbkRvbWluYW50XHJcbiAgICAgICBtaXhvbHlkaWFuOiBbMCwgMiwgMiwgMSwgMiwgMiwgMV0sXHJcbiAgICAgICBtaXhvbHlkaWFuRmxhdDY6IFswLCAyLCAyLCAxLCAyLCAxLCAyXSxcclxuICAgICAgIGxvY3JpYW46IFswLCAxLCAyLCAyLCAxLCAyLCAyXSxcclxuICAgICAgIHN1cGVyTG9jcmlhbjogWzAsIDEsIDIsIDEsIDIsIDIsIDJdLFxyXG4gICAgICAgLy8gbWlub3JcclxuICAgICAgIG1pbm9yOiBbMCwgMiwgMSwgMiwgMiwgMSwgMl0sXHJcbiAgICAgICBtaW5vcjdiOTogWzAsIDEsIDIsIDIsIDIsIDIsIDFdLFxyXG4gICAgICAgbWlub3I3YjU6IFswLCAyLCAxLCAyLCAxLCAyLCAyXSxcclxuICAgICAgIC8vIGhhbGZEaW1pbmlzaGVkOiBbXSwgLy8gc2V0IGJlbG93IC0gc2FtZSBhcyBtaW5vcjdiNVxyXG4gICAgICAgLy8gaGFybW9uaWNcclxuICAgICAgIGhhcm1vbmljTWFqb3I6IFswLCAyLCAyLCAxLCAyLCAxLCAzXSxcclxuICAgICAgIGhhcm1vbmljTWlub3I6IFswLCAyLCAxLCAyLCAyLCAxLCAzXSxcclxuICAgICAgIGRvdWJsZUhhcm1vbmljOiBbMCwgMSwgMywgMSwgMiwgMSwgM10sXHJcbiAgICAgICAvLyBieXphbnRpbmU6IFtdLCAvLyBzZXQgYmVsb3cgLSBzYW1lIGFzIGRvdWJsZUhhcm1vbmljXHJcbiAgICAgICAvLyBtZWxvZGljXHJcbiAgICAgICBtZWxvZGljTWlub3JBc2NlbmRpbmc6IFswLCAyLCAxLCAyLCAyLCAyLCAyXSxcclxuICAgICAgIG1lbG9kaWNNaW5vckRlc2NlbmRpbmc6IFswLCAyLCAyLCAxLCAyLCAyLCAxXSxcclxuICAgICAgIC8vIHBlbnRhdG9uaWNcclxuICAgICAgIG1ham9yUGVudGF0b25pYzogWzAsIDIsIDIsIDMsIDJdLFxyXG4gICAgICAgbWFqb3JQZW50YXRvbmljQmx1ZXM6IFswLCAyLCAxLCAxLCAzLCAyXSxcclxuICAgICAgIG1pbm9yUGVudGF0b25pYzogWzAsIDMsIDIsIDIsIDNdLFxyXG4gICAgICAgbWlub3JQZW50YXRvbmljQmx1ZXM6IFswLCAzLCAyLCAxLCAxLCAzXSxcclxuICAgICAgIGI1UGVudGF0b25pYzogWzAsIDMsIDIsIDEsIDQsIDJdLFxyXG4gICAgICAgbWlub3I2UGVudGF0b25pYzogWzAsIDMsIDIsIDIsIDIsIDNdLFxyXG4gICAgICAgLy8gZW5pZ21hdGljXHJcbiAgICAgICBlbmlnbWF0aWNNYWpvcjogWzAsIDEsIDMsIDIsIDIsIDIsIDFdLFxyXG4gICAgICAgZW5pZ21hdGljTWlub3I6IFswLCAxLCAyLCAzLCAxLCAzLCAxXSxcclxuICAgICAgIC8vIDhUb25lXHJcbiAgICAgICBkaW04VG9uZTogWzAsIDIsIDEsIDIsIDEsIDIsIDEsIDJdLFxyXG4gICAgICAgZG9tOFRvbmU6IFswLCAxLCAyLCAxLCAyLCAxLCAyLCAxXSxcclxuICAgICAgIC8vIG5lYXBvbGl0YW5cclxuICAgICAgIG5lYXBvbGl0YW5NYWpvcjogWzAsIDEsIDIsIDIsIDIsIDIsIDJdLFxyXG4gICAgICAgbmVhcG9saXRhbk1pbm9yOiBbMCwgMSwgMiwgMiwgMiwgMSwgM10sXHJcbiAgICAgICAvLyBodW5nYXJpYW5cclxuICAgICAgIGh1bmdhcmlhbk1ham9yOiBbMCwgMywgMSwgMiwgMSwgMiwgMV0sXHJcbiAgICAgICBodW5nYXJpYW5NaW5vcjogWzAsIDIsIDEsIDMsIDEsIDEsIDNdLFxyXG4gICAgICAgaHVuZ2FyaWFuR3lwc3k6IFswLCAxLCAzLCAxLCAyLCAxLCAzXSxcclxuICAgICAgIC8vIHNwYW5pc2hcclxuICAgICAgIHNwYW5pc2g6IFswLCAxLCAyLCAxLCAyLCAyLCAyXSxcclxuICAgICAgIHNwYW5pc2g4VG9uZTogWzAsIDEsIDIsIDEsIDEsIDEsIDIsIDJdLFxyXG4gICAgICAgLy8gamV3aXNoOiBbXSwgLy8gc2V0IGJlbG93IC0gc2FtZSBhcyBzcGFuaXNoOFRvbmVcclxuICAgICAgIHNwYW5pc2hHeXBzeTogWzAsIDEsIDMsIDEsIDIsIDEsIDJdLFxyXG4gICAgICAgLy8gYXVnIGRvbVxyXG4gICAgICAgYXVnbWVudGVkOiBbMCwgMywgMSwgMywgMSwgMywgMV0sXHJcbiAgICAgICBkb21pbmFudFN1c3BlbmRlZDogWzAsIDIsIDMsIDIsIDIsIDEsIDJdLFxyXG4gICAgICAgLy8gYmVib3BcclxuICAgICAgIGJlYm9wTWFqb3I6IFswLCAyLCAyLCAxLCAyLCAxLCAxLCAyXSxcclxuICAgICAgIGJlYm9wRG9taW5hbnQ6IFswLCAyLCAyLCAxLCAyLCAyLCAxLCAxXSxcclxuICAgICAgIG15c3RpYzogWzAsIDIsIDIsIDIsIDMsIDJdLFxyXG4gICAgICAgb3ZlcnRvbmU6IFswLCAyLCAyLCAyLCAxLCAxLCAyXSxcclxuICAgICAgIGxlYWRpbmdUb25lOiBbMCwgMiwgMiwgMiwgMiwgMiwgMV0sXHJcbiAgICAgICAvLyBqYXBhbmVzZVxyXG4gICAgICAgaGlyb2pvc2hpOiBbMCwgMiwgMSwgNCwgMV0sXHJcbiAgICAgICBqYXBhbmVzZUE6IFswLCAxLCA0LCAxLCAzXSxcclxuICAgICAgIGphcGFuZXNlQjogWzAsIDIsIDMsIDEsIDNdLFxyXG4gICAgICAgLy8gY3VsdHVyZXNcclxuICAgICAgIG9yaWVudGFsOiBbMCwgMSwgMywgMSwgMSwgMywgMV0sXHJcbiAgICAgICBwZXJzaWFuOiBbMCwgMSwgNCwgMSwgMiwgM10sXHJcbiAgICAgICBhcmFiaWFuOiBbMCwgMiwgMiwgMSwgMSwgMiwgMl0sXHJcbiAgICAgICBiYWxpbmVzZTogWzAsIDEsIDIsIDQsIDFdLFxyXG4gICAgICAga3Vtb2k6IFswLCAyLCAxLCA0LCAyLCAyXSxcclxuICAgICAgIHBlbG9nOiBbMCwgMSwgMiwgMywgMSwgMV0sXHJcbiAgICAgICBhbGdlcmlhbjogWzAsIDIsIDEsIDIsIDEsIDEsIDEsIDNdLFxyXG4gICAgICAgY2hpbmVzZTogWzAsIDQsIDIsIDEsIDRdLFxyXG4gICAgICAgbW9uZ29saWFuOiBbMCwgMiwgMiwgMywgMl0sXHJcbiAgICAgICBlZ3lwdGlhbjogWzAsIDIsIDMsIDIsIDNdLFxyXG4gICAgICAgcm9tYWluaWFuOiBbMCwgMiwgMSwgMywgMSwgMiwgMV0sXHJcbiAgICAgICBoaW5kdTogWzAsIDIsIDIsIDEsIDIsIDEsIDJdLFxyXG4gICAgICAgaW5zZW46IFswLCAxLCA0LCAyLCAzXSxcclxuICAgICAgIGl3YXRvOiBbMCwgMSwgNCwgMSwgNF0sXHJcbiAgICAgICBzY290dGlzaDogWzAsIDIsIDMsIDIsIDJdLFxyXG4gICAgICAgeW86IFswLCAzLCAyLCAyLCAzXSxcclxuICAgICAgIGlzdHJpYW46IFswLCAxLCAyLCAyLCAyLCAxLCAyXSxcclxuICAgICAgIHVrcmFuaWFuRG9yaWFuOiBbMCwgMiwgMSwgMywgMSwgMiwgMV0sXHJcbiAgICAgICBwZXRydXNoa2E6IFswLCAxLCAzLCAyLCAxLCAzXSxcclxuICAgICAgIGFoYXZhcmFiYTogWzAsIDEsIDMsIDEsIDIsIDEsIDJdLFxyXG4gICB9O1xyXG4gICAvLyBkdXBsaWNhdGVzIHdpdGggYWxpYXNlc1xyXG4gICBTY2FsZVRlbXBsYXRlcy5oYWxmRGltaW5pc2hlZCA9IFNjYWxlVGVtcGxhdGVzLm1pbm9yN2I1O1xyXG4gICBTY2FsZVRlbXBsYXRlcy5qZXdpc2ggPSBTY2FsZVRlbXBsYXRlcy5zcGFuaXNoOFRvbmU7XHJcbiAgIFNjYWxlVGVtcGxhdGVzLmJ5emFudGluZSA9IFNjYWxlVGVtcGxhdGVzLmRvdWJsZUhhcm1vbmljO1xyXG4gICBTY2FsZVRlbXBsYXRlcy5hY291c3RpYyA9IFNjYWxlVGVtcGxhdGVzLmx5ZGlhbkRvbWluYW50O1xyXG4gICBTY2FsZVRlbXBsYXRlcy5hZW9saWFuID0gU2NhbGVUZW1wbGF0ZXMubWlub3I7XHJcbiAgIFNjYWxlVGVtcGxhdGVzLmlvbmlhbiA9IFNjYWxlVGVtcGxhdGVzLm1ham9yO1xyXG4gICBPYmplY3Qua2V5cyhTY2FsZVRlbXBsYXRlcykuZm9yRWFjaCgoZWxlbWVudCkgPT4gT2JqZWN0LmZyZWV6ZShTY2FsZVRlbXBsYXRlc1tlbGVtZW50XSkpO1xuXG4gICAvKipcclxuICAgICogUmVnZXggZm9yIG1hdGNoaW5nIG5vdGUgbmFtZSwgbW9kaWZpZXIsIGFuZCBvY3RhdmVcclxuICAgICovXHJcbiAgIGNvbnN0IG5hbWVSZWdleCQxID0gLyhbQS1HXSkoPyFbXihdKlxcKSkvZztcclxuICAgY29uc3QgbW9kaWZpZXJSZWdleCQxID0gLygjfHN8YikoPyFbXihdKlxcKSkvZztcclxuICAgY29uc3Qgb2N0YXZlUmVnZXgkMSA9IC8oWzAtOV0rKSg/IVteKF0qXFwpKS9nO1xyXG4gICBjb25zdCBzY2FsZU5hbWVSZWdleCA9IC8oXFwoW2EtekEtWl17Mix9XFwpKS9nO1xyXG4gICAvKipcclxuICAgICogYXR0ZW1wdHMgdG8gcGFyc2UgYSBub3RlIGZyb20gYSBzdHJpbmdcclxuICAgICogQHBhcmFtIHNjYWxlIC0gdGhlIHN0cmluZyB0byBwYXJzZVxyXG4gICAgKiBAcGFyYW0gc3VwcmVzc1dhcm5pbmcgLSBzdXByZXNzIHRoZSB3YXJuaW5nIGZvciBpbmVmZmVjaWVuY3kgaWYgdHJ1ZVxyXG4gICAgKiBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgIGNvbnN0IHBhcnNlU2NhbGUgPSAoc2NhbGUsIHN1cHJlc3NXYXJuaW5nID0gZmFsc2UpID0+IHtcclxuICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc2NhbGVMb29rdXAoc2NhbGUpO1xyXG4gICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgaWYgKCFzdXByZXNzV2FybmluZylcclxuICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbmVmZmVjaWVudCBzY2FsZSBzdHJpbmcgZm9ybWF0dGluZyAtICR7c2NhbGV9LiBHZXQgYSBwZXJmb3JtYW5jIGluY3JlYXNlIGJ5IHVzaW5nIGEgdmFsaWQgZm9ybWF0YCk7XHJcbiAgICAgICB9XHJcbiAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgaWYgKCFzdXByZXNzV2FybmluZylcclxuICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbmVmZmVjaWVudCBzY2FsZSBzdHJpbmcgZm9ybWF0dGluZyAtICR7c2NhbGV9LiBHZXQgYSBwZXJmb3JtYW5jIGluY3JlYXNlIGJ5IHVzaW5nIGEgdmFsaWQgZm9ybWF0YCk7XHJcbiAgICAgICB9XHJcbiAgICAgICBsZXQgbm90ZUlkZW5pZmllciA9IFwiXCI7XHJcbiAgICAgICBsZXQgbm90ZU1vZGlmaWVyID0gMDtcclxuICAgICAgIGxldCBub3RlT2N0YXZlID0gXCJcIjtcclxuICAgICAgIGxldCBzY2FsZU5hbWUgPSBcIlwiO1xyXG4gICAgICAgY29uc3QgbmFtZU1hdGNoID0gc2NhbGUubWF0Y2gobmFtZVJlZ2V4JDEpPy5qb2luKFwiXCIpLnNwbGl0KFwiXCIpO1xyXG4gICAgICAgY29uc3QgbW9kaWZpZXJNYXRjaCA9IHNjYWxlLm1hdGNoKG1vZGlmaWVyUmVnZXgkMSk/LmpvaW4oXCJcIikuc3BsaXQoXCJcIik7XHJcbiAgICAgICBjb25zdCBvY3RhdmVNYXRjaCA9IHNjYWxlLm1hdGNoKG9jdGF2ZVJlZ2V4JDEpPy5qb2luKFwiXCIpLnNwbGl0KFwiXCIpO1xyXG4gICAgICAgY29uc3Qgc2NhbGVOYW1lTWF0Y2ggPSBzY2FsZS5tYXRjaChzY2FsZU5hbWVSZWdleCk/LmpvaW4oXCJcIikuc3BsaXQoXCJcIik7XHJcbiAgICAgICAvLyBjb21iaW5lIGFsbCBtb2RpZmllcnNcclxuICAgICAgIGlmIChtb2RpZmllck1hdGNoKSB7XHJcbiAgICAgICAgICAgaWYgKG1vZGlmaWVyTWF0Y2gubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAvLyBjb21iaW5lIGFsbCBtb2RpZmllcnMgaW50byBhbiBvZmZlc2V0IHZhbHVlIHRvIGJlIGFkZGVkIHRvIHRoZSBzZW1pdG9uZVxyXG4gICAgICAgICAgICAgICBub3RlTW9kaWZpZXIgPSBtb2RpZmllck1hdGNoXHJcbiAgICAgICAgICAgICAgICAgICAubWFwKChpdGVtKSA9PiBwYXJzZU1vZGlmaWVyKGl0ZW0pKVxyXG4gICAgICAgICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgbm90ZU1vZGlmaWVyID0gcGFyc2VNb2RpZmllcihtb2RpZmllck1hdGNoWzBdKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9XHJcbiAgICAgICBpZiAob2N0YXZlTWF0Y2gpIHtcclxuICAgICAgICAgICBjb25zdCBbb2N0YXZlXSA9IG9jdGF2ZU1hdGNoO1xyXG4gICAgICAgICAgIG5vdGVPY3RhdmUgPSBvY3RhdmU7XHJcbiAgICAgICB9XHJcbiAgICAgICBpZiAoc2NhbGVOYW1lTWF0Y2gpIHtcclxuICAgICAgICAgICBjb25zdCBzTmFtZSA9IHNjYWxlTmFtZU1hdGNoLmpvaW4oXCJcIik7XHJcbiAgICAgICAgICAgLy8gY29uc29sZS5sb2coc05hbWUpO1xyXG4gICAgICAgICAgIHNjYWxlTmFtZSA9IHNOYW1lO1xyXG4gICAgICAgfVxyXG4gICAgICAgaWYgKG5hbWVNYXRjaCkge1xyXG4gICAgICAgICAgIGNvbnN0IFtub3RlTmFtZV0gPSBuYW1lTWF0Y2g7XHJcbiAgICAgICAgICAgbm90ZUlkZW5pZmllciA9IG5vdGVOYW1lO1xyXG4gICAgICAgICAgIGxldCBtb2RpZmllciA9IDA7XHJcbiAgICAgICAgICAgaWYgKG5vdGVNb2RpZmllcilcclxuICAgICAgICAgICAgICAgbW9kaWZpZXIgPSBub3RlTW9kaWZpZXI7XHJcbiAgICAgICAgICAgY29uc3Qgd3JhcHBlZFRvbmUgPSB3cmFwKGdldFdob2xlVG9uZUZyb21OYW1lKG5vdGVJZGVuaWZpZXIpICsgbW9kaWZpZXIsIFRPTkVTX01JTiwgVE9ORVNfTUFYKTtcclxuICAgICAgICAgICBjb25zdCBzZW1pdG9uZSA9IHdyYXBwZWRUb25lLnZhbHVlO1xyXG4gICAgICAgICAgIGxldCBvY3RhdmUgPSA0O1xyXG4gICAgICAgICAgIGlmIChub3RlT2N0YXZlKVxyXG4gICAgICAgICAgICAgICBvY3RhdmUgPSBjbGFtcChwYXJzZUludChub3RlT2N0YXZlLCAxMCksIE9DVEFWRV9NSU4sIE9DVEFWRV9NQVgpO1xyXG4gICAgICAgICAgIGxldCB0ZW1wbGF0ZUluZGV4ID0gMTsgLy8gZGVmYXVsdCBtYWpvciBzY2FsZVxyXG4gICAgICAgICAgIGlmIChzY2FsZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgdGVtcGxhdGVJbmRleCA9IE9iamVjdC5rZXlzKFNjYWxlVGVtcGxhdGVzKS5maW5kSW5kZXgoKHRlbXBsYXRlKSA9PiB0ZW1wbGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAgICAgICAgICAgIC5pbmNsdWRlcyhzY2FsZU5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXCh8XFwpL2csIFwiXCIpKSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIC8vIGNvbnNvbGUubG9nKE9iamVjdC5rZXlzKFNjYWxlVGVtcGxhdGVzKVt0ZW1wbGF0ZUluZGV4XSk7XHJcbiAgICAgICAgICAgaWYgKHRlbXBsYXRlSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVU5LTk9XTiBURU1QTEFURVwiLCBzY2FsZU5hbWUpO1xyXG4gICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIHRlbXBsYXRlIGZvciBzY2FsZSAke3NjYWxlTmFtZX1gKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBTY2FsZVRlbXBsYXRlc1tPYmplY3Qua2V5cyhTY2FsZVRlbXBsYXRlcylbdGVtcGxhdGVJbmRleF1dO1xyXG4gICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgIGtleTogc2VtaXRvbmUsXHJcbiAgICAgICAgICAgICAgIG9jdGF2ZTogb2N0YXZlLFxyXG4gICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAgICAgICAgfTtcclxuICAgICAgIH1cclxuICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBTY2FsZTogJHtzY2FsZX1gKTtcclxuICAgfTtcclxuICAgLyoqXHJcbiAgICAqIGNyZWF0ZXMgYSBsb29rdXAgdGFibGUgZm9yIGFsbCBub3RlcyBmb3JtYXR0ZWQgYXMgW0EtR11bI3xifHNdWzAtOV1cclxuICAgICogQGludGVybmFsXHJcbiAgICAqL1xyXG4gICBjb25zdCBjcmVhdGVUYWJsZSQyID0gKCkgPT4ge1xyXG4gICAgICAgY29uc3Qgc2NhbGVUYWJsZSA9IHt9O1xyXG4gICAgICAgY29uc3Qgbm90ZUxldHRlcnMgPSBbXCJBXCIsIFwiQlwiLCBcIkNcIiwgXCJEXCIsIFwiRVwiLCBcIkZcIiwgXCJHXCJdO1xyXG4gICAgICAgY29uc3Qgbm90ZU1vZGlmaWVycyA9IFtcImJcIiwgXCIjXCIsIFwic1wiXTtcclxuICAgICAgIGNvbnN0IHRlbXBsYXRlcyA9IE9iamVjdC5rZXlzKFNjYWxlVGVtcGxhdGVzKTtcclxuICAgICAgIGZvciAoY29uc3QgdGVtcGxhdGUgb2YgdGVtcGxhdGVzKSB7XHJcbiAgICAgICAgICAgZm9yIChjb25zdCBub3RlTGFiZWwgb2Ygbm90ZUxldHRlcnMpIHtcclxuICAgICAgICAgICAgICAgLy9leCBBKG1pbm9yKVxyXG4gICAgICAgICAgICAgICBzY2FsZVRhYmxlW2Ake25vdGVMYWJlbH0oJHt0ZW1wbGF0ZX0pYF0gPSBwYXJzZVNjYWxlKG5vdGVMYWJlbCwgdHJ1ZSk7IC8vICdDJyBmb3IgZXhhbXBsZVxyXG4gICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1vZCBvZiBub3RlTW9kaWZpZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtub3RlTGFiZWx9JHttb2R9KCR7dGVtcGxhdGV9KWA7XHJcbiAgICAgICAgICAgICAgICAgICAvLyBleCBBIyhtaW5vcilcclxuICAgICAgICAgICAgICAgICAgIHNjYWxlVGFibGVba2V5XSA9IHBhcnNlU2NhbGUoa2V5LCB0cnVlKTsgLy8gJ0MjJyBmb3IgZXhhbXBsZVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGZvciAobGV0IGlPY3RhdmUgPSBPQ1RBVkVfTUlOOyBpT2N0YXZlIDwgT0NUQVZFX01BWDsgKytpT2N0YXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtub3RlTGFiZWx9JHtpT2N0YXZlfSgke3RlbXBsYXRlfSlgO1xyXG4gICAgICAgICAgICAgICAgICAgLy8gZXggQTQobWlub3IpXHJcbiAgICAgICAgICAgICAgICAgICBzY2FsZVRhYmxlW2tleV0gPSBwYXJzZVNjYWxlKGtleSwgdHJ1ZSk7IC8vICdDNCcgZm9yIGV4YW1wbGVcclxuICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbW9kIG9mIG5vdGVNb2RpZmllcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtub3RlTGFiZWx9JHttb2R9JHtpT2N0YXZlfSgke3RlbXBsYXRlfSlgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIGV4IEEjNChtaW5vcilcclxuICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVRhYmxlW2tleV0gPSBwYXJzZVNjYWxlKGtleSwgdHJ1ZSk7IC8vICdDIzQnIGZvciBleGFtcGxlXHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcbiAgICAgICB9XHJcbiAgICAgICByZXR1cm4gc2NhbGVUYWJsZTtcclxuICAgfTtcclxuICAgLyoqXHJcbiAgICAqIGNyZWF0ZXMgdGhlIGxvb2t1cCB0YWJsZSBhcyBzb29uIGFzIHRoZSBtb2R1bGUgaXMgbG9hZGVkXHJcbiAgICAqIEBpbnRlcm5hbFxyXG4gICAgKi9cclxuICAgbGV0IF9zY2FsZUxvb2t1cCA9IHt9O1xyXG4gICBjb25zdCBzY2FsZUxvb2t1cCA9IChrZXkpID0+IHtcclxuICAgICAgIC8vIGJ1aWxkU2NhbGVUYWJsZSgpO1xyXG4gICAgICAgcmV0dXJuIF9zY2FsZUxvb2t1cFtrZXldO1xyXG4gICB9O1xyXG4gICAvLyBpZiAodGFibGUgJiYgT2JqZWN0LmtleXModGFibGUpLmxlbmd0aCA+IDApIHtcclxuICAgLy8gICAgX3NjYWxlTG9va3VwID0gdGFibGUgYXMgeyBba2V5OiBzdHJpbmddOiBTY2FsZUluaXRpYWxpemVyIH07XHJcbiAgIC8vIH0gZWxzZSB7XHJcbiAgIC8vICAgIF9zY2FsZUxvb2t1cCA9IGNyZWF0ZVRhYmxlKCk7XHJcbiAgIC8vIH1cclxuICAgY29uc3QgYnVpbGRTY2FsZVRhYmxlID0gKCkgPT4ge1xyXG4gICAgICAgLy8gaWYgKE9iamVjdC5lbnRyaWVzKF9zY2FsZUxvb2t1cCkubGVuZ3RoID4gMCkgcmV0dXJuIF9zY2FsZUxvb2t1cDtcclxuICAgICAgIF9zY2FsZUxvb2t1cCA9IGNyZWF0ZVRhYmxlJDIoKTtcclxuICAgICAgIC8vIE9iamVjdC5mcmVlemUoX3NjYWxlTG9va3VwKTtcclxuICAgICAgIGNvbnNvbGUubG9nKFwiU2NhbGUgVGFibGUgQnVpbHRcIik7XHJcbiAgICAgICByZXR1cm4gX3NjYWxlTG9va3VwO1xyXG4gICB9O1xuXG4gICAvKipcclxuICAgICogc2hpZnRzIGFuIGFycmF5IGJ5IGEgZ2l2ZW4gZGlzdGFuY2VcclxuICAgICogQHBhcmFtIGFyciB0aGUgYXJyYXkgdG8gc2hpZnRcclxuICAgICogQHBhcmFtIGRpc3RhbmNlIHRoZSBkaXN0YW5jZSB0byBzaGlmdFxyXG4gICAgKiBAcmV0dXJucyB0aGUgc2hpZnRlZCBhcnJheVxyXG4gICAgKiBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgIGNvbnN0IHNoaWZ0ID0gKGFyciwgZGlzdCA9IDEpID0+IHtcclxuICAgICAgIGFyciA9IFsuLi5hcnJdOyAvLyBjb3B5XHJcbiAgICAgICBpZiAoZGlzdCA+IGFyci5sZW5ndGggfHwgZGlzdCA8IDAgLSBhcnIubGVuZ3RoKVxyXG4gICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNoaWZ0OiBkaXN0YW5jZSBpcyBncmVhdGVyIHRoYW4gYXJyYXkgbGVuZ3RoXCIpO1xyXG4gICAgICAgaWYgKGRpc3QgPiAwKSB7XHJcbiAgICAgICAgICAgY29uc3QgdGVtcCA9IGFyci5zcGxpY2UoYXJyLmxlbmd0aCAtIGRpc3QsIEluZmluaXR5KTtcclxuICAgICAgICAgICBhcnIudW5zaGlmdCguLi50ZW1wKTtcclxuICAgICAgIH1cclxuICAgICAgIGlmIChkaXN0IDwgMCkge1xyXG4gICAgICAgICAgIGNvbnN0IHRlbXAgPSBhcnIuc3BsaWNlKDAsIGRpc3QpO1xyXG4gICAgICAgICAgIGFyci5wdXNoKC4uLnRlbXApO1xyXG4gICAgICAgfVxyXG4gICAgICAgcmV0dXJuIGFycjtcclxuICAgfTtcblxuICAgLyoqXHJcbiAgICAqICBTaW1wbGUgdXRpbCB0byBsYXp5IGNsb25lIGFuIG9iamVjdFxyXG4gICAgKiBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgIGNvbnN0IGNsb25lID0gKG9iaikgPT4ge1xyXG4gICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XHJcbiAgIH07XG5cbiAgIC8qKlxyXG4gICAgKiBzaW1wbGUgdXRpbCB0byBsYXp5IGNoZWNrIGVxdWFsaXR5IG9mIG9iamVjdHMgYW5kIGFycmF5c1xyXG4gICAgKiBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgIGNvbnN0IGlzRXF1YWwgPSAoYSwgYikgPT4ge1xyXG4gICAgICAgY29uc3Qgc3RyaW5nQSA9IEpTT04uc3RyaW5naWZ5KGEpO1xyXG4gICAgICAgY29uc3Qgc3RyaW5nQiA9IEpTT04uc3RyaW5naWZ5KGIpO1xyXG4gICAgICAgcmV0dXJuIHN0cmluZ0EgPT09IHN0cmluZ0I7XHJcbiAgIH07XG5cbiAgIC8vIGltcG9ydCB0YWJsZSBmcm9tIFwiLi9ub3RlU3RyaW5nTG9va3VwLmpzb25cIjtcclxuICAgLyoqXHJcbiAgICAqIFdpbGwgbG9va3VwIGEgc2NhbGUgbmFtZSBiYXNlZCBvbiB0aGUgdGVtcGxhdGUuXHJcbiAgICAqIEBwYXJhbSB0ZW1wbGF0ZSAtIHRoZSB0ZW1wbGF0ZSB0byBsb29rdXBcclxuICAgICogQHBhcmFtIHN1cHJlc3NXYXJuaW5nIC0gc3VwcmVzcyB0aGUgd2FybmluZyBmb3IgaW5lZmZlY2llbmN5IGlmIHRydWVcclxuICAgICogQHJldHVybnMgdGhlIHNjYWxlIG5hbWVcclxuICAgICogQGludGVybmFsXHJcbiAgICAqL1xyXG4gICBjb25zdCBzY2FsZU5hbWVMb29rdXAgPSAodGVtcGxhdGUsIHN1cHJlc3NXYXJuaW5nID0gZmFsc2UpID0+IHtcclxuICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmFtZVRhYmxlKEpTT04uc3RyaW5naWZ5KHRlbXBsYXRlKSk7XHJcbiAgICAgICAgICAgaWYgKHJlc3VsdClcclxuICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgIH1cclxuICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgaWYgKCFzdXByZXNzV2FybmluZylcclxuICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGUpO1xyXG4gICAgICAgfVxyXG4gICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKFNjYWxlVGVtcGxhdGVzKTtcclxuICAgICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoU2NhbGVUZW1wbGF0ZXMpO1xyXG4gICAgICAgY29uc3Qgc2NhbGVOYW1lcyA9IFtdO1xyXG4gICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgaWYgKGlzRXF1YWwodmFsdWVzW2ldLCB0ZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgc2NhbGVOYW1lcy5wdXNoKGtleXNbaV0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXlzW2ldLnNsaWNlKDEpKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICB9XHJcbiAgICAgICBjb25zdCBzY2FsZU5hbWVzU3RyaW5nID0gc2NhbGVOYW1lcy5qb2luKFwiIEFLQSBcIik7XHJcbiAgICAgICByZXR1cm4gc2NhbGVOYW1lc1N0cmluZztcclxuICAgfTtcclxuICAgY29uc3QgY3JlYXRlVGFibGUkMSA9ICgpID0+IHtcclxuICAgICAgIGNvbnN0IHRhYmxlID0ge307XHJcbiAgICAgICBmb3IgKGNvbnN0IHRlbXBsYXRlIG9mIE9iamVjdC52YWx1ZXMoU2NhbGVUZW1wbGF0ZXMpKSB7XHJcbiAgICAgICAgICAgdGFibGVbSlNPTi5zdHJpbmdpZnkodGVtcGxhdGUpXSA9IHNjYWxlTmFtZUxvb2t1cCh0ZW1wbGF0ZSwgdHJ1ZSk7XHJcbiAgICAgICB9XHJcbiAgICAgICByZXR1cm4gdGFibGU7XHJcbiAgIH07XHJcbiAgIGxldCBfbmFtZVRhYmxlID0ge307XHJcbiAgIGNvbnN0IG5hbWVUYWJsZSA9IChrZXkpID0+IHtcclxuICAgICAgIC8vIGJ1aWxkU2NhbGVOYW1lVGFibGUoKTtcclxuICAgICAgIHJldHVybiBfbmFtZVRhYmxlW2tleV07XHJcbiAgIH07XHJcbiAgIC8vIGlmICh0YWJsZSAmJiBPYmplY3Qua2V5cyh0YWJsZSkubGVuZ3RoID4gMCkge1xyXG4gICAvLyAgICBfbmFtZVRhYmxlID0gdGFibGU7XHJcbiAgIC8vIH0gZWxzZSB7XHJcbiAgIC8vICAgIF9uYW1lVGFibGUgPSBjcmVhdGVUYWJsZSgpO1xyXG4gICAvLyB9XHJcbiAgIGNvbnN0IGJ1aWxkU2NhbGVOYW1lVGFibGUgPSAoKSA9PiB7XHJcbiAgICAgICAvLyBpZiAoT2JqZWN0LmVudHJpZXMoX25hbWVUYWJsZSkubGVuZ3RoID4gMCkgcmV0dXJuIF9uYW1lVGFibGU7XHJcbiAgICAgICBfbmFtZVRhYmxlID0gY3JlYXRlVGFibGUkMSgpO1xyXG4gICAgICAgT2JqZWN0LmZyZWV6ZShfbmFtZVRhYmxlKTtcclxuICAgICAgIGNvbnNvbGUubG9nKFwiU2NhbGUgbmFtZSB0YWJsZSBidWlsdFwiKTtcclxuICAgICAgIHJldHVybiBfbmFtZVRhYmxlO1xyXG4gICB9O1xuXG4gICAvKipcclxuICAgICogU2NhbGVzIGNvbnNpc3Qgb2YgYSBrZXkodG9uaWMgb3Igcm9vdCkgYW5kIGEgdGVtcGxhdGUoYXJyYXkgb2YgaW50ZWdlcnMpIHRoYXRcclxuICAgICogPGJyPiByZXByZXNlbnRzIHRoZSBpbnRlcnZhbCBvZiBzdGVwcyBiZXR3ZWVuIGVhY2ggbm90ZS5cclxuICAgICogPGJyPjxicj5TY2FsZSBpbnRlcnZhbHMgYXJlIHJlcHJlc2VudGVkIGJ5IGFuIGludGVnZXJcclxuICAgICogPGJyPnRoYXQgaXMgdGhlIG51bWJlciBvZiBzZW1pdG9uZXMgYmV0d2VlbiBlYWNoIG5vdGUuXHJcbiAgICAqIDxicj4wID0ga2V5IC0gd2lsbCBhbHdheXMgcmVwcmVzZW50IHRoZSB0b25pY1xyXG4gICAgKiA8YnI+MSA9IGhhbGYgc3RlcFxyXG4gICAgKiA8YnI+MiA9IHdob2xlIHN0ZXBcclxuICAgICogPGJyPjMgPSBvbmUgYW5kIG9uZSBoYWxmIHN0ZXBzXHJcbiAgICAqIDxicj40ID0gZG91YmxlIHN0ZXBcclxuICAgICogPGJyPlswLCAyLCAyLCAxLCAyLCAyLCAyXSByZXByZXNlbnRzIHRoZSBtYWpvciBzY2FsZVxyXG4gICAgKiA8YnI+PGJyPiBTY2FsZSB0ZW1wbGF0ZXMgbWF5IGhhdmUgYXJiaXRyYXkgbGVuZ3Roc1xyXG4gICAgKlxyXG4gICAgKiBUaGUgZm9sbG93aW5nIFByZS1kZWZpbmVkIHRlbXBsYXRlcyBhcmUgYXZhaWxhYmxlOlxyXG4gICAgKiA8dGFibGU+XHJcbiAgICAqIDx0cj5cclxuICAgICogPHRkPm1ham9yPC90ZD5cclxuICAgICogPHRkPm1pbm9yPC90ZD5cclxuICAgICogPHRkPmlvbmlhbjwvdGQ+XHJcbiAgICAqIDx0ZD5kb3JpYW48L3RkPlxyXG4gICAgKiA8L3RyPjx0cj5cclxuICAgICogPHRkPnBocnlnaWFuPC90ZD5cclxuICAgICogPHRkPmx5ZGlhbjwvdGQ+XHJcbiAgICAqIDx0ZD5taXhvbHlkaWFuPC90ZD5cclxuICAgICogPHRkPmFlb2xpYW48L3RkPlxyXG4gICAgKiA8L3RyPjx0cj5cclxuICAgICogPHRkPmxvY3JpYW48L3RkPlxyXG4gICAgKiA8dGQ+ZW5pZ21hdGljTWFqb3I8L3RkPlxyXG4gICAgKiA8dGQ+ZW5pZ21hdGljTWlub3I8L3RkPlxyXG4gICAgKiA8dGQ+bWlub3I3YjU8L3RkPlxyXG4gICAgKiA8L3RyPjx0cj5cclxuICAgICogPHRkPm1ham9yN3M0czU8L3RkPlxyXG4gICAgKiA8dGQ+aGFybW9uaWNNYWpvcjwvdGQ+XHJcbiAgICAqIDx0ZD5oYXJtb25pY01pbm9yPC90ZD5cclxuICAgICogPHRkPmRvdWJsZUhhcm1vbmljPC90ZD5cclxuICAgICogPC90cj48dHI+XHJcbiAgICAqIDx0ZD5tZWxvZGljTWlub3JBc2NlbmRpbmc8L3RkPlxyXG4gICAgKiA8dGQ+bWVsb2RpY01pbm9yRGVzY2VuZGluZzwvdGQ+XHJcbiAgICAqIDx0ZD5tYWpvclBlbnRhdG9uaWM8L3RkPlxyXG4gICAgKiA8dGQ+bWFqb3JQZW50YXRvbmljQmx1ZXM8L3RkPlxyXG4gICAgKiA8L3RyPjx0cj5cclxuICAgICogPHRkPm1pbm9yUGVudGF0b25pYzwvdGQ+XHJcbiAgICAqIDx0ZD5taW5vclBlbnRhdG9uaWNCbHVlczwvdGQ+XHJcbiAgICAqIDx0ZD5iNVBlbnRhdG9uaWM8L3RkPlxyXG4gICAgKiA8dGQ+bWlub3I2UGVudGF0b25pYzwvdGQ+XHJcbiAgICAqIDwvdHI+PHRyPlxyXG4gICAgKiA8dGQ+ZGltOFRvbmU8L3RkPlxyXG4gICAgKiA8dGQ+ZG9tOFRvbmU8L3RkPlxyXG4gICAgKiA8dGQ+bmVvcG9saXRhbk1ham9yPC90ZD5cclxuICAgICogPHRkPm5lb3BvbGl0YW5NaW5vcjwvdGQ+XHJcbiAgICAqIDwvdHI+PHRyPlxyXG4gICAgKiA8dGQ+aHVuZ2FyaWFuTWFqb3I8L3RkPlxyXG4gICAgKiA8dGQ+aHVuZ2FyaWFuTWlub3I8L3RkPlxyXG4gICAgKiA8dGQ+aHVuZ2FyaWFuR3lwc3k8L3RkPlxyXG4gICAgKiA8dGQ+c3BhbmlzaDwvdGQ+XHJcbiAgICAqIDwvdHI+PHRyPlxyXG4gICAgKiA8dGQ+c3BhbmlzaDhUb25lPC90ZD5cclxuICAgICogPHRkPnNwYW5pc2hHeXBzeTwvdGQ+XHJcbiAgICAqIDx0ZD5hdWdtZW50ZWQ8L3RkPlxyXG4gICAgKiA8dGQ+ZG9taW5hbnRTdXNwZW5kZWQ8L3RkPlxyXG4gICAgKiA8L3RyPjx0cj5cclxuICAgICogPHRkPmJlYm9wTWFqb3I8L3RkPlxyXG4gICAgKiA8dGQ+YmVib3BEb21pbmFudDwvdGQ+XHJcbiAgICAqIDx0ZD5teXN0aWM8L3RkPlxyXG4gICAgKiA8dGQ+b3ZlcnRvbmU8L3RkPlxyXG4gICAgKiA8L3RyPjx0cj5cclxuICAgICogPHRkPmxlYWRpbmdUb25lPC90ZD5cclxuICAgICogPHRkPmhpcm9qb3NoaTwvdGQ+XHJcbiAgICAqIDx0ZD5qYXBhbmVzZUE8L3RkPlxyXG4gICAgKiA8dGQ+amFwYW5lc2VCPC90ZD5cclxuICAgICogPC90cj48dHI+XHJcbiAgICAqIDx0ZD5vcmllbnRhbDwvdGQ+XHJcbiAgICAqIDx0ZD5hcmFiaWFuPC90ZD5cclxuICAgICogPHRkPnBlcnNpYW48L3RkPlxyXG4gICAgKiA8dGQ+YmFsaW5lc2U8L3RkPlxyXG4gICAgKiA8L3RyPjx0cj5cclxuICAgICogPHRkPmt1bW9pPC90ZD5cclxuICAgICogPHRkPnBlbG9nPC90ZD5cclxuICAgICogPHRkPmFsZ2VyaWFuPC90ZD5cclxuICAgICogPHRkPmNoaW5lc2U8L3RkPlxyXG4gICAgKiA8L3RyPjx0cj5cclxuICAgICogPHRkPm1vbmdvbGlhbjwvdGQ+XHJcbiAgICAqIDx0ZD5lZ3lwdGlhbjwvdGQ+XHJcbiAgICAqIDx0ZD5oaW5kdTwvdGQ+XHJcbiAgICAqIDx0ZD5yb21hbmlhbjwvdGQ+XHJcbiAgICAqIDwvdHI+PHRyPlxyXG4gICAgKiA8dGQ+aGluZHU8L3RkPlxyXG4gICAgKiA8dGQ+aW5zZW48L3RkPlxyXG4gICAgKiA8dGQ+aXdhdG88L3RkPlxyXG4gICAgKiA8dGQ+c2NvdHRpc2g8L3RkPlxyXG4gICAgKiA8L3RyPjx0cj5cclxuICAgICogPHRkPnlvPC90ZD5cclxuICAgICogPHRkPmlzdHJpYW48L3RkPlxyXG4gICAgKiA8dGQ+dWtyYW5pYW5Eb3JpYW48L3RkPlxyXG4gICAgKiA8dGQ+cGV0cnVzaGthPC90ZD5cclxuICAgICogPC90cj48dHI+XHJcbiAgICAqIDx0ZD5haGF2YXJhYmE8L3RkPlxyXG4gICAgKiA8dGQ+aGFsZkRpbWluaXNoZWQ8L3RkPlxyXG4gICAgKiA8dGQ+amV3aXNoPC90ZD5cclxuICAgICogPHRkPmJ5emFudGluZTwvdGQ+XHJcbiAgICAqIDwvdHI+PHRyPlxyXG4gICAgKiA8dGQ+YWNvdXN0aWM8L3RkPlxyXG4gICAgKiA8L3RhYmxlPlxyXG4gICAgKlxyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAqIGltcG9ydCB7U2NhbGV9IGZyb20gJ211c2ljdGhlb3J5anMnO1xyXG4gICAgKiBpbXBvcnQge1NjYWxlVGVtcGxhdGVzfSBmcm9tICdtdXNpY3RoZW9yeWpzJztcclxuICAgICogaW1wb3J0IHtTY2FsZUluaXRpYWxpemVyfSBmcm9tICdtdXNpY3RoZW9yeWpzJzsgLy8gVHlwZVNjcmlwdCBvbmx5IGlmIG5lZWRlZFxyXG4gICAgKiBgYGBcclxuICAgICovXHJcbiAgIGNsYXNzIFNjYWxlIHtcclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGltcG9ydCB7U2NhbGUsIFNjYWxlVGVtcGxhdGVzfSBmcm9tICdtdXNpY3RoZW9yeWpzJztcclxuICAgICAgICAqXHJcbiAgICAgICAgKiAvLyBjcmVhdGVzIGEgc2NhbGUgd2l0aCB0aGUgZGVmYXVsdCB0ZW1wbGF0ZSwga2V5IDBmIDAoQykgYW5kIGFuIG9jdGF2ZSBvZiA0XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSgpO1xyXG4gICAgICAgICpcclxuICAgICAgICAqIC8vIGNyZWF0ZXMgYSBzY2FsZSB3aXRoIHRoZSB0ZW1wbGF0ZSBbMCwgMiwgMiwgMSwgMiwgMiwgMl0gYW5kIGtleSA0KEUpIGFuZCBvY3RhdmUgNVxyXG4gICAgICAgICogY29uc3Qgc2NhbGUyID0gbmV3IFNjYWxlKHtrZXk6IDQsIG9jdGF2ZTogNSwgdGVtcGxhdGU6IFNjYWxlVGVtcGxhdGVzLm1ham9yfSk7XHJcbiAgICAgICAgKlxyXG4gICAgICAgICpcclxuICAgICAgICAqIC8vIFN0cmluZyBwYXJzaW5nIHNob3VsZCBmb2xsb3cgdGhlIGZvcm1hdDogbm90ZS1uYW1lW2FsdGVyYXRpb25dW29jdGF2ZV1bKHNjYWxlLW5hbWUpXVxyXG4gICAgICAgICogLy8gY3JlYXRlcyBhIHNjYWxlIHdpdGggdGhlIG1pbm9yIHRlbXBsYXRlLCBrZXkgR2IgYW5kIGFuIG9jdGF2ZSBvZiA3XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZTMgPSBuZXcgU2NhbGUoJ0diNyhtaW5vciknKTtcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcclxuICAgICAgICAgICBpZiAoIXZhbHVlcykge1xyXG4gICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlID0gREVGQVVMVF9TQ0FMRV9URU1QTEFURTtcclxuICAgICAgICAgICAgICAgdGhpcy5rZXkgPSBERUZBVUxUX1NFTUlUT05FO1xyXG4gICAgICAgICAgICAgICB0aGlzLm9jdGF2ZSA9IERFRkFVTFRfT0NUQVZFO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWVzID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgIHZhbHVlcyA9IHBhcnNlU2NhbGUodmFsdWVzKTtcclxuICAgICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IFsuLi4odmFsdWVzPy50ZW1wbGF0ZSA/PyBERUZBVUxUX1NDQUxFX1RFTVBMQVRFKV07XHJcbiAgICAgICAgICAgICAgIHRoaXMua2V5ID0gdmFsdWVzLmtleSB8fCBERUZBVUxUX1NFTUlUT05FO1xyXG4gICAgICAgICAgICAgICB0aGlzLm9jdGF2ZSA9IHZhbHVlcy5vY3RhdmUgfHwgREVGQVVMVF9PQ1RBVkU7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAvLyBpbXBvcnRhbnQgdGhhdCBvY3RhdmUgaXMgc2V0IGZpcnN0IHNvIHRoYXRcclxuICAgICAgICAgICAgICAgLy8gc2V0dGluZyB0aGUgc2VtaXRvbmUgY2FuIGNoYW5nZSB0aGUgb2N0YXZlXHJcbiAgICAgICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSBbLi4uKHZhbHVlcz8udGVtcGxhdGUgPz8gREVGQVVMVF9TQ0FMRV9URU1QTEFURSldO1xyXG4gICAgICAgICAgICAgICB0aGlzLmtleSA9IHZhbHVlcy5rZXkgfHwgREVGQVVMVF9TRU1JVE9ORTtcclxuICAgICAgICAgICAgICAgdGhpcy5vY3RhdmUgPSB2YWx1ZXMub2N0YXZlIHx8IERFRkFVTFRfT0NUQVZFO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICB0aGlzLl9ub3Rlc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogIHVuaXF1ZSBpZCBmb3IgdGhpcyBzY2FsZShhdXRvIGdlbmVyYXRlZClcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coc2NhbGUuaWQpOyAvLyBkaGxrajVqMzIyXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgaWQgPSB1aWQoKTtcclxuICAgICAgIC8qKlxyXG4gICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgc2NhbGUgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIHNjYWxlXHJcbiAgICAgICAgKiBAcGFyYW0gc2NhbGUgLSB0aGUgc2NhbGUgdG8gY29tcGFyZSB0b1xyXG4gICAgICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc2NhbGVzIGFyZSBlcXVhbFxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IHNjYWxlID0gbmV3IFNjYWxlKCk7XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZTIgPSBuZXcgU2NhbGUoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKHNjYWxlLmVxdWFscyhzY2FsZTIpKTsgLy8gdHJ1ZVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGVxdWFscyhzY2FsZSkge1xyXG4gICAgICAgICAgIHJldHVybiAodGhpcy5fa2V5ID09PSBzY2FsZS5fa2V5ICYmXHJcbiAgICAgICAgICAgICAgIHRoaXMuX29jdGF2ZSA9PT0gc2NhbGUuX29jdGF2ZSAmJlxyXG4gICAgICAgICAgICAgICBpc0VxdWFsKHRoaXMuX3RlbXBsYXRlLCBzY2FsZS5fdGVtcGxhdGUpKTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBTY2FsZVxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoaXMgU2NhbGVcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSgpO1xyXG4gICAgICAgICogY29uc3Qgc2NhbGUyID0gc2NhbGUuY29weSgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coc2NhbGUuZXF1YWxzKHNjYWxlMikpOyAvLyB0cnVlXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgY29weSgpIHtcclxuICAgICAgICAgICBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSh7XHJcbiAgICAgICAgICAgICAgIGtleTogdGhpcy5rZXksXHJcbiAgICAgICAgICAgICAgIG9jdGF2ZTogdGhpcy5vY3RhdmUsXHJcbiAgICAgICAgICAgICAgIHRlbXBsYXRlOiBjbG9uZSh0aGlzLnRlbXBsYXRlKSxcclxuICAgICAgICAgICB9KTtcclxuICAgICAgICAgICBpZiAodGhpcy5fc2hpZnRlZEludGVydmFsICE9PSAwKVxyXG4gICAgICAgICAgICAgICBzY2FsZS5zaGlmdCh0aGlzLl9zaGlmdGVkSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgIHJldHVybiBzY2FsZTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICoga2V5XHJcbiAgICAgICAgKi9cclxuICAgICAgIF9rZXkgPSAwO1xyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3Qgc2NhbGUgPSBuZXcgU2NhbGUoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKHNjYWxlLmtleSk7IC8vIDAoc2VtaXRvbmUpXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgZ2V0IGtleSgpIHtcclxuICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5O1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBTZXR0aW5nIHRoZSBzZW1pdG9uZSB0byBhIHZhbHVlIG91dHNpZGUgb2YgdGhlIHJhbmdlIFswLCAxMV0oc2VtaXRvbmUpIHdpbGw8YnIvPlxyXG4gICAgICAgICogd3JhcCB0aGUgc2VtaXRvbmUgdG8gdGhlIHJhbmdlIFswLCAxMV0gYW5kIGNoYW5nZSB0aGUgb2N0YXZlIGRlcGVuZGluZzxici8+XHJcbiAgICAgICAgKiBvbiBob3cgbWFueSB0aW1lcyB0aGUgc2VtaXRvbmUgaGFzIGJlZW4gd3JhcHBlZC5cclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSgpO1xyXG4gICAgICAgICogc2NhbGUua2V5ID0gNDtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKHNjYWxlLmtleSk7IC8vIDRcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBzZXQga2V5KHZhbHVlKSB7XHJcbiAgICAgICAgICAgY29uc3Qgd3JhcHBlZCA9IHdyYXAodmFsdWUsIFRPTkVTX01JTiwgVE9ORVNfTUFYKTtcclxuICAgICAgICAgICB0aGlzLm9jdGF2ZSA9IHRoaXMub2N0YXZlICsgd3JhcHBlZC5udW1XcmFwcztcclxuICAgICAgICAgICB0aGlzLl9rZXkgPSB3cmFwcGVkLnZhbHVlO1xyXG4gICAgICAgICAgIHRoaXMuX25vdGVzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBvY3RhdmVcclxuICAgICAgICAqL1xyXG4gICAgICAgX29jdGF2ZSA9IERFRkFVTFRfT0NUQVZFO1xyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBUaGUgb2N0YXZlIGlzIGNsYW1wZWQgdG8gdGhlIHJhbmdlIFswLCA5XS5cclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coc2NhbGUub2N0YXZlKTsgLy8gNFxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGdldCBvY3RhdmUoKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX29jdGF2ZTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IHNjYWxlID0gbmV3IFNjYWxlKCk7XHJcbiAgICAgICAgKiBzY2FsZS5vY3RhdmUgPSA1O1xyXG4gICAgICAgICogY29uc29sZS5sb2coc2NhbGUub2N0YXZlKTsgLy8gNVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHNldCBvY3RhdmUodmFsdWUpIHtcclxuICAgICAgICAgICB0aGlzLl9vY3RhdmUgPSBjbGFtcCh2YWx1ZSwgT0NUQVZFX01JTiwgT0NUQVZFX01BWCk7XHJcbiAgICAgICAgICAgdGhpcy5fbm90ZXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIHRlbXBsYXRlXHJcbiAgICAgICAgKi9cclxuICAgICAgIF90ZW1wbGF0ZSA9IFtdO1xyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3Qgc2NhbGUgPSBuZXcgU2NhbGUoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKHNjYWxlLnRlbXBsYXRlKTsgLy8gWzAsIDIsIDIsIDEsIDIsIDIsIDJdXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgZ2V0IHRlbXBsYXRlKCkge1xyXG4gICAgICAgICAgIHJldHVybiBjbG9uZSh0aGlzLl90ZW1wbGF0ZSk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIFRoZSBmb2xsb3dpbmcgUHJlLWRlZmluZWQgdGVtcGxhdGVzIGFyZSBhdmFpbGFibGU6XHJcbiAgICAgICAgKiA8dGFibGU+XHJcbiAgICAgICAgKiA8dHI+XHJcbiAgICAgICAgKiA8dGQ+bWFqb3I8L3RkPlxyXG4gICAgICAgICogPHRkPm1pbm9yPC90ZD5cclxuICAgICAgICAqIDx0ZD5pb25pYW48L3RkPlxyXG4gICAgICAgICogPHRkPmRvcmlhbjwvdGQ+XHJcbiAgICAgICAgKiA8L3RyPjx0cj5cclxuICAgICAgICAqIDx0ZD5waHJ5Z2lhbjwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+bHlkaWFuPC90ZD5cclxuICAgICAgICAqIDx0ZD5taXhvbHlkaWFuPC90ZD5cclxuICAgICAgICAqIDx0ZD5hZW9saWFuPC90ZD5cclxuICAgICAgICAqIDwvdHI+PHRyPlxyXG4gICAgICAgICogPHRkPmxvY3JpYW48L3RkPlxyXG4gICAgICAgICogPHRkPmVuaWdtYXRpY01ham9yPC90ZD5cclxuICAgICAgICAqIDx0ZD5lbmlnbWF0aWNNaW5vcjwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+bWlub3I3YjU8L3RkPlxyXG4gICAgICAgICogPC90cj48dHI+XHJcbiAgICAgICAgKiA8dGQ+bWFqb3I3czRzNTwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+aGFybW9uaWNNYWpvcjwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+aGFybW9uaWNNaW5vcjwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+ZG91YmxlSGFybW9uaWM8L3RkPlxyXG4gICAgICAgICogPC90cj48dHI+XHJcbiAgICAgICAgKiA8dGQ+bWVsb2RpY01pbm9yQXNjZW5kaW5nPC90ZD5cclxuICAgICAgICAqIDx0ZD5tZWxvZGljTWlub3JEZXNjZW5kaW5nPC90ZD5cclxuICAgICAgICAqIDx0ZD5tYWpvclBlbnRhdG9uaWM8L3RkPlxyXG4gICAgICAgICogPHRkPm1ham9yUGVudGF0b25pY0JsdWVzPC90ZD5cclxuICAgICAgICAqIDwvdHI+PHRyPlxyXG4gICAgICAgICogPHRkPm1pbm9yUGVudGF0b25pYzwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+bWlub3JQZW50YXRvbmljQmx1ZXM8L3RkPlxyXG4gICAgICAgICogPHRkPmI1UGVudGF0b25pYzwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+bWlub3I2UGVudGF0b25pYzwvdGQ+XHJcbiAgICAgICAgKiA8L3RyPjx0cj5cclxuICAgICAgICAqIDx0ZD5kaW04VG9uZTwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+ZG9tOFRvbmU8L3RkPlxyXG4gICAgICAgICogPHRkPm5lb3BvbGl0YW5NYWpvcjwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+bmVvcG9saXRhbk1pbm9yPC90ZD5cclxuICAgICAgICAqIDwvdHI+PHRyPlxyXG4gICAgICAgICogPHRkPmh1bmdhcmlhbk1ham9yPC90ZD5cclxuICAgICAgICAqIDx0ZD5odW5nYXJpYW5NaW5vcjwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+aHVuZ2FyaWFuR3lwc3k8L3RkPlxyXG4gICAgICAgICogPHRkPnNwYW5pc2g8L3RkPlxyXG4gICAgICAgICogPC90cj48dHI+XHJcbiAgICAgICAgKiA8dGQ+c3BhbmlzaDhUb25lPC90ZD5cclxuICAgICAgICAqIDx0ZD5zcGFuaXNoR3lwc3k8L3RkPlxyXG4gICAgICAgICogPHRkPmF1Z21lbnRlZDwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+ZG9taW5hbnRTdXNwZW5kZWQ8L3RkPlxyXG4gICAgICAgICogPC90cj48dHI+XHJcbiAgICAgICAgKiA8dGQ+YmVib3BNYWpvcjwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+YmVib3BEb21pbmFudDwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+bXlzdGljPC90ZD5cclxuICAgICAgICAqIDx0ZD5vdmVydG9uZTwvdGQ+XHJcbiAgICAgICAgKiA8L3RyPjx0cj5cclxuICAgICAgICAqIDx0ZD5sZWFkaW5nVG9uZTwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+aGlyb2pvc2hpPC90ZD5cclxuICAgICAgICAqIDx0ZD5qYXBhbmVzZUE8L3RkPlxyXG4gICAgICAgICogPHRkPmphcGFuZXNlQjwvdGQ+XHJcbiAgICAgICAgKiA8L3RyPjx0cj5cclxuICAgICAgICAqIDx0ZD5vcmllbnRhbDwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+YXJhYmlhbjwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+cGVyc2lhbjwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+YmFsaW5lc2U8L3RkPlxyXG4gICAgICAgICogPC90cj48dHI+XHJcbiAgICAgICAgKiA8dGQ+a3Vtb2k8L3RkPlxyXG4gICAgICAgICogPHRkPnBlbG9nPC90ZD5cclxuICAgICAgICAqIDx0ZD5hbGdlcmlhbjwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+Y2hpbmVzZTwvdGQ+XHJcbiAgICAgICAgKiA8L3RyPjx0cj5cclxuICAgICAgICAqIDx0ZD5tb25nb2xpYW48L3RkPlxyXG4gICAgICAgICogPHRkPmVneXB0aWFuPC90ZD5cclxuICAgICAgICAqIDx0ZD5oaW5kdTwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+cm9tYW5pYW48L3RkPlxyXG4gICAgICAgICogPC90cj48dHI+XHJcbiAgICAgICAgKiA8dGQ+aGluZHU8L3RkPlxyXG4gICAgICAgICogPHRkPmluc2VuPC90ZD5cclxuICAgICAgICAqIDx0ZD5pd2F0bzwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+c2NvdHRpc2g8L3RkPlxyXG4gICAgICAgICogPC90cj48dHI+XHJcbiAgICAgICAgKiA8dGQ+eW88L3RkPlxyXG4gICAgICAgICogPHRkPmlzdHJpYW48L3RkPlxyXG4gICAgICAgICogPHRkPnVrcmFuaWFuRG9yaWFuPC90ZD5cclxuICAgICAgICAqIDx0ZD5wZXRydXNoa2E8L3RkPlxyXG4gICAgICAgICogPC90cj48dHI+XHJcbiAgICAgICAgKiA8dGQ+YWhhdmFyYWJhPC90ZD5cclxuICAgICAgICAqIDx0ZD5oYWxmRGltaW5pc2hlZDwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+amV3aXNoPC90ZD5cclxuICAgICAgICAqIDx0ZD5ieXphbnRpbmU8L3RkPlxyXG4gICAgICAgICogPC90cj48dHI+XHJcbiAgICAgICAgKiA8dGQ+YWNvdXN0aWM8L3RkPlxyXG4gICAgICAgICogPC90YWJsZT5cclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSgpO1xyXG4gICAgICAgICogc2NhbGUudGVtcGxhdGUgPSBbMCwgMiwgMiwgMSwgMiwgMiwgMl07XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhzY2FsZS50ZW1wbGF0ZSk7IC8vIFswLCAyLCAyLCAxLCAyLCAyLCAyXVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHNldCB0ZW1wbGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgICAgIHRoaXMuX3RlbXBsYXRlID0gY2xvbmUodmFsdWUpO1xyXG4gICAgICAgICAgIHRoaXMuX3NoaWZ0ZWRJbnRlcnZhbCA9IDA7XHJcbiAgICAgICAgICAgdGhpcy5fbm90ZXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIG5vdGVzXHJcbiAgICAgICAgKiBub3RlcyBhcmUgZ2VuZXJhdGVkIGFuZCBjYWNoZWQgYXMgbmVlZGVkXHJcbiAgICAgICAgKi9cclxuICAgICAgIF9ub3RlcyA9IFtdO1xyXG4gICAgICAgX25vdGVzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiB3aWxsIGdlbmVyYXRlIHRoZSBub3RlcyBpZiBuZWVkZWQgb3IgcmV0dXJuIHRoZSBjYWNoZWQgbm90ZXNcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coc2NhbGUubm90ZXMpOyAvLyBMaXN0IG9mIG5vdGVzXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgZ2V0IG5vdGVzKCkge1xyXG4gICAgICAgICAgIGlmICh0aGlzLl9ub3Rlc0RpcnR5KSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVOb3RlcygpO1xyXG4gICAgICAgICAgICAgICB0aGlzLl9ub3Rlc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHJldHVybiB0aGlzLl9ub3RlcztcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogZ2VuZXJhdGUgbm90ZXMoaW50ZXJuYWwpXHJcbiAgICAgICAgKiBnZW5lcmF0ZXMgdGhlIG5vdGVzIGZvciB0aGlzIHNjYWxlXHJcbiAgICAgICAgKi9cclxuICAgICAgIGdlbmVyYXRlTm90ZXMoKSB7XHJcbiAgICAgICAgICAgLy8gdXNlIHRoZSB0ZW1wbGF0ZSB1bnNoaWZ0ZWQgZm9yIHNpbXBsaWNpdHlcclxuICAgICAgICAgICBjb25zdCB1bnNoaWZ0ZWRUZW1wbGF0ZSA9IHNoaWZ0KHRoaXMuX3RlbXBsYXRlLCAtdGhpcy5fc2hpZnRlZEludGVydmFsKTtcclxuICAgICAgICAgICAvLyBpZiBhbGxvd2luZyB0aGlzIHRvIGNoYW5nZSB0aGUgb2N0YXZlIGlzIHVuZGVzaXJhYmxlXHJcbiAgICAgICAgICAgLy8gdGhlbiBtYXkgbmVlZCB0byBwcmUgd3JhcCB0aGUgdG9uZSBhbmQgdXNlXHJcbiAgICAgICAgICAgLy8gdGhlIGZpbmFsIHZhbHVlXHJcbiAgICAgICAgICAgY29uc3Qgbm90ZXMgPSBbXTtcclxuICAgICAgICAgICBsZXQgYWNjdW11bGF0b3IgPSB0aGlzLmtleTtcclxuICAgICAgICAgICBmb3IgKGNvbnN0IGludGVydmFsIG9mIHVuc2hpZnRlZFRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgIGNvbnN0IHRvbmUgPSBpbnRlcnZhbCA9PT0gMFxyXG4gICAgICAgICAgICAgICAgICAgPyAoYWNjdW11bGF0b3IgPSB0aGlzLmtleSlcclxuICAgICAgICAgICAgICAgICAgIDogKGFjY3VtdWxhdG9yICs9IGludGVydmFsKTtcclxuICAgICAgICAgICAgICAgY29uc3Qgbm90ZSA9IG5ldyBOb3RlKHtcclxuICAgICAgICAgICAgICAgICAgIHNlbWl0b25lOiB0b25lLFxyXG4gICAgICAgICAgICAgICAgICAgb2N0YXZlOiB0aGlzLm9jdGF2ZSxcclxuICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgIG5vdGVzLnB1c2gobm90ZSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIC8vIHNoaWZ0IG5vdGVzIGJhY2sgdG8gb3JpZ2luYWwgcG9zaXRpb25cclxuICAgICAgICAgICBpZiAodGhpcy5fc2hpZnRlZEludGVydmFsID4gMCkge1xyXG4gICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gbm90ZXMuc3BsaWNlKG5vdGVzLmxlbmd0aCAtICh0aGlzLl9zaGlmdGVkSW50ZXJ2YWwgKyAxKSwgSW5maW5pdHkpO1xyXG4gICAgICAgICAgICAgICBub3Rlcy51bnNoaWZ0KC4uLnRlbXApO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBpZiAodGhpcy5fc2hpZnRlZEludGVydmFsIDwgMCkge1xyXG4gICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gbm90ZXMuc3BsaWNlKDAsIHRoaXMuX3NoaWZ0ZWRJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgIG5vdGVzLnB1c2goLi4udGVtcCk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHRoaXMuX25vdGVzID0gbm90ZXM7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIHJldHVybnMgdGhlIG5hbWVzIG9mIHRoZSBub3RlcyBpbiB0aGUgc2NhbGVcclxuICAgICAgICAqIEBwYXJhbSBwcmVmZXJTaGFycEtleXMgLSBpZiB0cnVlIHRoZW4gc2hhcnBzIHdpbGwgYmUgcHJlZmVycmVkIG92ZXIgZmxhdHMgd2hlbiBzZW1pdG9uZXMgY291bGQgYmUgZWl0aGVyIC0gZXg6IEJiL0EjXHJcbiAgICAgICAgKiBAcmV0dXJucyB0aGUgbmFtZXMgb2YgdGhlIG5vdGVzIGluIHRoZSBzY2FsZVxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IHNjYWxlID0gbmV3IFNjYWxlKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhzY2FsZS5uYW1lcyk7IC8vIFsnQzQnLCAnRDQnLCAnRTQnLCAnRjQnLCAnRzQnLCAnQTQnLCAnQjQnXVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGdldE5vdGVOYW1lcyhwcmVmZXJTaGFycEtleSA9IHRydWUpIHtcclxuICAgICAgICAgICBjb25zdCBuYW1lcyA9IHNjYWxlTm90ZU5hbWVMb29rdXAodGhpcywgcHJlZmVyU2hhcnBLZXkpO1xyXG4gICAgICAgICAgIHJldHVybiBuYW1lcztcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogZGVncmVlXHJcbiAgICAgICAgKiByZXR1cm5zIGEgbm90ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGdpdmVuIGRlZ3JlZVxyXG4gICAgICAgICogQHBhcmFtIGRlZ3JlZSAtIHRoZSBkZWdyZWUgdG8gcmV0dXJuXHJcbiAgICAgICAgKiBAcmV0dXJucyBhIG5vdGUgdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiBkZWdyZWVcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coc2NhbGUuZGVncmVlKDApKTsgLy8gQzQoTm90ZSlcclxuICAgICAgICAqIGNvbnNvbGUubG9nKHNjYWxlLmRlZ3JlZSgxKSk7IC8vIEQ0KE5vdGUpIGV0Y1xyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGRlZ3JlZShkZWdyZWUpIHtcclxuICAgICAgICAgICBjb25zdCB3cmFwcGVkID0gd3JhcChkZWdyZWUgLSAxIC8qemVybyBpbmRleCAqLywgMCwgdGhpcy5ub3Rlcy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICBjb25zdCBub3RlID0gdGhpcy5ub3Rlc1t3cmFwcGVkLnZhbHVlXS5jb3B5KCk7XHJcbiAgICAgICAgICAgbm90ZS5vY3RhdmUgPSB0aGlzLm9jdGF2ZSArIHdyYXBwZWQubnVtV3JhcHM7XHJcbiAgICAgICAgICAgcmV0dXJuIG5vdGU7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIHJlbGF0aXZlIG1ham9yXHJcbiAgICAgICAgKiByZXR1cm5zIGEgbmV3IHNjYWxlIHRoYXQgaXMgdGhlIHJlbGF0aXZlIG1ham9yIG9mIHRoaXMgc2NhbGUgLSB0YWtlcyB0aGUgM3JkIGRlZ3JlZSBhcyBpdCdzIGtleVxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgYSBuZXcgc2NhbGUgdGhhdCBpcyB0aGUgcmVsYXRpdmUgbWFqb3Igb2YgdGhpcyBzY2FsZVxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IHNjYWxlID0gbmV3IFNjYWxlKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhzY2FsZS5yZWxhdGl2ZU1ham9yKCkpOyAvLyBTY2FsZVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHJlbGF0aXZlTWFqb3IoKSB7XHJcbiAgICAgICAgICAgY29uc3QgbWFqb3IgPSBuZXcgU2NhbGUoe1xyXG4gICAgICAgICAgICAgICB0ZW1wbGF0ZTogU2NhbGVUZW1wbGF0ZXMubWFqb3IsXHJcbiAgICAgICAgICAgICAgIGtleTogdGhpcy5kZWdyZWUoMykuc2VtaXRvbmUsXHJcbiAgICAgICAgICAgICAgIG9jdGF2ZTogdGhpcy5vY3RhdmUsXHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgcmV0dXJuIG1ham9yO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiByZWxhdGl2ZSBtaW5vclxyXG4gICAgICAgICogcmV0dXJucyBhIG5ldyBzY2FsZSB0aGF0IGlzIHRoZSByZWxhdGl2ZSBtaW5vciBvZiB0aGlzIHNjYWxlIC0gdGFrZXMgdGhlIDZ0aCBkZWdyZWUgYXMgaXQncyBrZXlcclxuICAgICAgICAqIEBjaGFpbmFibGVcclxuICAgICAgICAqIEByZXR1cm5zIGEgbmV3IHNjYWxlIHRoYXQgaXMgdGhlIHJlbGF0aXZlIG1pbm9yIG9mIHRoaXMgc2NhbGVcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coc2NhbGUucmVsYXRpdmVNaW5vcigpKTsgLy8gU2NhbGVcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICByZWxhdGl2ZU1pbm9yKCkge1xyXG4gICAgICAgICAgIGNvbnN0IG1pbm9yID0gbmV3IFNjYWxlKHtcclxuICAgICAgICAgICAgICAgdGVtcGxhdGU6IFNjYWxlVGVtcGxhdGVzLm1pbm9yLFxyXG4gICAgICAgICAgICAgICBrZXk6IHRoaXMuZGVncmVlKDYpLnNlbWl0b25lLFxyXG4gICAgICAgICAgICAgICBvY3RhdmU6IHRoaXMub2N0YXZlLFxyXG4gICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgIHJldHVybiBtaW5vcjtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogc2hpZnRcclxuICAgICAgICAqL1xyXG4gICAgICAgX3NoaWZ0ZWRJbnRlcnZhbCA9IDA7XHJcbiAgICAgICBfb3JpZ2luYWxUZW1wbGF0ZSA9IFtdO1xyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBzaGlmdFxyXG4gICAgICAgICogc2hpZnRzIHRoZSBzY2FsZSBieSB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGRlZ3JlZXNcclxuICAgICAgICAqIEBjaGFpbmFibGVcclxuICAgICAgICAqIEBwYXJhbSBzaGlmdCAtIHRoZSBudW1iZXIgb2YgZGVncmVlcyB0byBzaGlmdCB0aGUgc2NhbGVcclxuICAgICAgICAqIEByZXR1cm5zIGEgbmV3IHNjYWxlIHRoYXQgaXMgdGhlIHNoaWZ0ZWQgc2NhbGVcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coc2NhbGUuc2hpZnQoMSkpOyAvLyBTY2FsZVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHNoaWZ0KGRlZ3JlZXMgPSAxKSB7XHJcbiAgICAgICAgICAgaWYgKHRoaXMuX3NoaWZ0ZWRJbnRlcnZhbCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbFRlbXBsYXRlID0gY2xvbmUodGhpcy5fdGVtcGxhdGUpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IHNoaWZ0KHRoaXMuX3RlbXBsYXRlLCBkZWdyZWVzKTtcclxuICAgICAgICAgICB0aGlzLl9zaGlmdGVkSW50ZXJ2YWwgKz0gZGVncmVlcztcclxuICAgICAgICAgICB0aGlzLl9ub3Rlc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogc2hpZnRlZFxyXG4gICAgICAgICogcmV0dXJucyBhIGNvcHkgb2YgdGhpcyBzY2FsZSBzaGlmdGVkIGJ5IHRoZSBnaXZlbiBudW1iZXIgb2YgZGVncmVlc1xyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHBhcmFtIGRlZ3JlZXMgLSB0aGUgbnVtYmVyIG9mIGRlZ3JlZXMgdG8gc2hpZnQgdGhlIHNjYWxlXHJcbiAgICAgICAgKiBAcmV0dXJucyBhIGNvcHkgb2YgdGhpcyBzY2FsZSBzaGlmdGVkIGJ5IHRoZSBnaXZlbiBudW1iZXIgb2YgZGVncmVlc1xyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IHNjYWxlID0gbmV3IFNjYWxlKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhzY2FsZS5zaGlmdGVkKDEpKTsgLy8gU2NhbGUoY29weSlcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBzaGlmdGVkKGRlZ3JlZXMgPSAxKSB7XHJcbiAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLmNvcHkoKTtcclxuICAgICAgICAgICBzY2FsZS5zaGlmdChkZWdyZWVzKTtcclxuICAgICAgICAgICByZXR1cm4gc2NhbGU7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIHVuc2hpZnRcclxuICAgICAgICAqIHNoaWZ0cyB0aGUgb3JpZ2luYWwgcm9vdCBiYWNrIHRvIHRoZSByb290IHBvc2l0aW9uXHJcbiAgICAgICAgKiBAY2hhaW5hYmxlXHJcbiAgICAgICAgKiBAcmV0dXJucyB0aGlzIHNjYWxlIGFmdGVyIHVuc2hpZnRpbmcgaXQgYmFjayB0byB0aGUgb3JpZ2luYWwgcm9vdCBwb3NpdGlvblxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IHNjYWxlID0gbmV3IFNjYWxlKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhzY2FsZS5zaGlmdCgxKSk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhzY2FsZS51bnNoaWZ0KCkpO1xyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHVuc2hpZnQoKSB7XHJcbiAgICAgICAgICAgaWYgKHRoaXMuX3NoaWZ0ZWRJbnRlcnZhbCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICBpZiAodGhpcy5fb3JpZ2luYWxUZW1wbGF0ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IHRoaXMuX29yaWdpbmFsVGVtcGxhdGU7XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgLy8gdGhpcy5zaGlmdCh0aGlzLl9zaGlmdGVkSW50ZXJ2YWwgKiAtMSk7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3NoaWZ0ZWRJbnRlcnZhbCA9IDA7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsVGVtcGxhdGUgPSBbXTtcclxuICAgICAgICAgICAgICAgdGhpcy5fbm90ZXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiB1bnNoaWZ0ZWRcclxuICAgICAgICAqIHJldHVybnMgYSBjb3B5IG9mIHRoaXMgc2NhbGUgd2l0aCB0aGUgdG9uaWMgc2hpZnRlZCBiYWNrXHJcbiAgICAgICAgKiB0byB0aGUgcm9vdCBwb3NpdGlvblxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoaXMgc2NhbGUgd2l0aCB0aGUgdG9uaWMgc2hpZnRlZCBiYWNrXHJcbiAgICAgICAgKiB0byB0aGUgcm9vdCBwb3NpdGlvblxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IHNjYWxlID0gbmV3IFNjYWxlKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhzY2FsZS5zaGlmdCgxKSk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhzY2FsZS51bnNoaWZ0ZWQoKSk7IC8vIFNjYWxlKGNvcHkpXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgdW5zaGlmdGVkKCkge1xyXG4gICAgICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5jb3B5KCk7XHJcbiAgICAgICAgICAgaWYgKHRoaXMuX29yaWdpbmFsVGVtcGxhdGUubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICBzY2FsZS50ZW1wbGF0ZSA9IHRoaXMuX29yaWdpbmFsVGVtcGxhdGU7XHJcbiAgICAgICAgICAgc2NhbGUudW5zaGlmdCgpO1xyXG4gICAgICAgICAgIHJldHVybiBzY2FsZTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogcmV0dXJucyB0aGUgYW1vdW50IHRoYXQgdGhlIHNjYWxlIGhhcyBzaGlmdGVkXHJcbiAgICAgICAgKiAoMCBpZiBub3Qgc2hpZnRlZClcclxuICAgICAgICAqIEByZXR1cm5zIHRoZSBhbW91bnQgdGhhdCB0aGUgc2NhbGUgaGFzIHNoaWZ0ZWRcclxuICAgICAgICAqICgwIGlmIG5vdCBzaGlmdGVkKVxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IHNjYWxlID0gbmV3IFNjYWxlKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhzY2FsZS5zaGlmdCgxKSk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhzY2FsZS5zaGlmdGVkKCkpOyAvLyAxXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgc2hpZnRlZEludGVydmFsKCkge1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzLl9zaGlmdGVkSW50ZXJ2YWw7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIFNjYWxlIG1vZGVzXHJcbiAgICAgICAgKi9cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoaXMgc2NhbGUgaW4gdGhlIElvbmlhbihtYWpvcikgbW9kZVxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IHNjYWxlID0gbmV3IFNjYWxlKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhzY2FsZS5pb25pYW4oKSk7IC8vIFNjYWxlKGNvcHkpXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgaW9uaWFuKCkge1xyXG4gICAgICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5jb3B5KCk7XHJcbiAgICAgICAgICAgc2NhbGUudGVtcGxhdGUgPSBTY2FsZVRlbXBsYXRlcy5pb25pYW47XHJcbiAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAY2hhaW5hYmxlXHJcbiAgICAgICAgKiBAcmV0dXJucyBhIGNvcHkgb2YgdGhpcyBzY2FsZSBpbiB0aGUgRG9yaWFuIG1vZGVcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coc2NhbGUuZG9yaWFuKCkpOyAvLyBTY2FsZShjb3B5KVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGRvcmlhbigpIHtcclxuICAgICAgICAgICBjb25zdCBzY2FsZSA9IHRoaXMuY29weSgpO1xyXG4gICAgICAgICAgIHNjYWxlLnRlbXBsYXRlID0gU2NhbGVUZW1wbGF0ZXMuZG9yaWFuO1xyXG4gICAgICAgICAgIHJldHVybiBzY2FsZTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoaXMgc2NhbGUgaW4gdGhlIFBocnlnaWFuIG1vZGVcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coc2NhbGUucGhyeWdpYW4oKSk7IC8vIFNjYWxlKGNvcHkpXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgcGhyeWdpYW4oKSB7XHJcbiAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLmNvcHkoKTtcclxuICAgICAgICAgICBzY2FsZS50ZW1wbGF0ZSA9IFNjYWxlVGVtcGxhdGVzLnBocnlnaWFuO1xyXG4gICAgICAgICAgIHJldHVybiBzY2FsZTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoaXMgc2NhbGUgaW4gdGhlIEx5ZGlhbiBtb2RlXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3Qgc2NhbGUgPSBuZXcgU2NhbGUoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKHNjYWxlLmx5ZGlhbigpKTsgLy8gU2NhbGUoY29weSlcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBseWRpYW4oKSB7XHJcbiAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLmNvcHkoKTtcclxuICAgICAgICAgICBzY2FsZS50ZW1wbGF0ZSA9IFNjYWxlVGVtcGxhdGVzLmx5ZGlhbjtcclxuICAgICAgICAgICByZXR1cm4gc2NhbGU7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBjaGFpbmFibGVcclxuICAgICAgICAqIEByZXR1cm5zIGEgY29weSBvZiB0aGlzIHNjYWxlIGluIHRoZSBNaXhvbHlkaWFuIG1vZGVcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coc2NhbGUubWl4b2x5ZGlhbigpKTsgLy8gU2NhbGUoY29weSlcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBtaXhvbHlkaWFuKCkge1xyXG4gICAgICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5jb3B5KCk7XHJcbiAgICAgICAgICAgc2NhbGUudGVtcGxhdGUgPSBTY2FsZVRlbXBsYXRlcy5taXhvbHlkaWFuO1xyXG4gICAgICAgICAgIHJldHVybiBzY2FsZTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoaXMgc2NhbGUgaW4gdGhlIEFlb2xpYW4obWlub3IpIG1vZGVcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coc2NhbGUuYWVvbGlhbigpKTsgLy8gU2NhbGUoY29weSlcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBhZW9saWFuKCkge1xyXG4gICAgICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5jb3B5KCk7XHJcbiAgICAgICAgICAgc2NhbGUudGVtcGxhdGUgPSBTY2FsZVRlbXBsYXRlcy5hZW9saWFuO1xyXG4gICAgICAgICAgIHJldHVybiBzY2FsZTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoaXMgc2NhbGUgaW4gdGhlIExvY3JpYW4gbW9kZVxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IHNjYWxlID0gbmV3IFNjYWxlKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhzY2FsZS5sb2NyaWFuKCkpOyAvLyBTY2FsZShjb3B5KVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGxvY3JpYW4oKSB7XHJcbiAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLmNvcHkoKTtcclxuICAgICAgICAgICBzY2FsZS50ZW1wbGF0ZSA9IFNjYWxlVGVtcGxhdGVzLmxvY3JpYW47XHJcbiAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiByZXR1cm5zIHN0cmluZyB2ZXJzaW9uIG9mIHRoZSBzY2FsZVxyXG4gICAgICAgICogQHJldHVybnMgc3RyaW5nIHZlcnNpb24gb2YgdGhlIHNjYWxlXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3Qgc2NhbGUgPSBuZXcgU2NhbGUoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKHNjYWxlLnRvU3RyaW5nKCkpOyAvLyAnQydcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICB0b1N0cmluZygpIHtcclxuICAgICAgICAgICBsZXQgc2NhbGVOYW1lcyA9IHNjYWxlTmFtZUxvb2t1cCh0aGlzLl90ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgaWYgKCFzY2FsZU5hbWVzKVxyXG4gICAgICAgICAgICAgICBzY2FsZU5hbWVzID0gdGhpcy5nZXROb3RlTmFtZXMoKS5qb2luKFwiLCBcIik7XHJcbiAgICAgICAgICAgcmV0dXJuIGAke1NlbWl0b25lJDFbdGhpcy5fa2V5XX0ke3RoaXMuX29jdGF2ZX0oJHtzY2FsZU5hbWVzfSlgO1xyXG4gICAgICAgfVxyXG4gICB9XHJcbiAgIC8qKlxyXG4gICAgKiBhdHRlbXB0cyB0byBsb29rdXAgdGhlIG5vdGUgbmFtZSBmb3IgYSBzY2FsZSBlZmZpY2llbnRseVxyXG4gICAgKiBAcGFyYW0gc2NhbGUgLSB0aGUgc2NhbGUgdG8gbG9va3VwXHJcbiAgICAqIEBwYXJhbSBwcmVmZXJTaGFycEtleSAtIGlmIHRydWUsIHdpbGwgcHJlZmVyIHNoYXJwIGtleXMgb3ZlciBmbGF0IGtleXNcclxuICAgICogQHJldHVybnMgdGhlIG5vdGUgbmFtZXMgZm9yIHRoZSBzY2FsZVxyXG4gICAgKiBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgIGNvbnN0IHNjYWxlTm90ZU5hbWVMb29rdXAgPSAoc2NhbGUsIHByZWZlclNoYXJwS2V5ID0gdHJ1ZSkgPT4ge1xyXG4gICAgICAgdHJ5IHtcclxuICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtzY2FsZS5rZXl9LSR7c2NhbGUub2N0YXZlfS0ke0pTT04uc3RyaW5naWZ5KHNjYWxlLnRlbXBsYXRlKX1gO1xyXG4gICAgICAgICAgIGNvbnN0IG5vdGVzID0gbm90ZXNMb29rdXAoa2V5KTtcclxuICAgICAgICAgICBpZiAobm90ZXMpIHtcclxuICAgICAgICAgICAgICAgcmV0dXJuIG5vdGVzO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH1cclxuICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgICAgfVxyXG4gICAgICAgbGV0IG5vdGVzID0gWy4uLnNjYWxlLm5vdGVzXTtcclxuICAgICAgIG5vdGVzID0gc2hpZnQobm90ZXMsIC1zY2FsZS5zaGlmdGVkSW50ZXJ2YWwoKSk7IC8vdW5zaGlmdCBiYWNrIHRvIGtleSA9IDAgaW5kZXhcclxuICAgICAgIGNvbnN0IG5vdGVzUGFydHMgPSBub3Rlcy5tYXAoKG5vdGUpID0+IG5vdGUudG9TdHJpbmcoKS5zcGxpdChcIi9cIikpO1xyXG4gICAgICAgY29uc3Qgb2N0YXZlcyA9IG5vdGVzLm1hcCgobm90ZSkgPT4gbm90ZS5vY3RhdmUpO1xyXG4gICAgICAgY29uc3QgcmVtb3ZhYmxlcyA9IFtcIkIjXCIsIFwiQnNcIiwgXCJDYlwiLCBcIkUjXCIsIFwiRXNcIiwgXCJGYlwiXTtcclxuICAgICAgIGNvbnN0IG5vdGVOYW1lcyA9IFtdO1xyXG4gICAgICAgZm9yIChjb25zdCBbaSwgbm90ZVBhcnRzXSBvZiBub3Rlc1BhcnRzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgIC8vcmVtb3ZlIENiIEIjIGV0Y1xyXG4gICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBub3RlUGFydHMpIHtcclxuICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGFueSBudW1iZXJzIGZyb20gdGhlIG5vdGUgbmFtZShvY3RhdmUpXHJcbiAgICAgICAgICAgICAgIC8vIHBhcnQucmVwbGFjZSgvXFxkL2csIFwiXCIpO1xyXG4gICAgICAgICAgICAgICBpZiAocmVtb3ZhYmxlcy5pbmNsdWRlcyhwYXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBub3RlTmFtZXMuaW5kZXhPZihwYXJ0KTtcclxuICAgICAgICAgICAgICAgICAgIG5vdGVOYW1lcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGlmIChub3RlTmFtZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgIG5vdGVOYW1lcy5wdXNoKHByZWZlclNoYXJwS2V5ID8gbm90ZVBhcnRzWzBdIDogbm90ZVBhcnRzW25vdGVQYXJ0cy5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBpZiAobm90ZVBhcnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICBub3RlTmFtZXMucHVzaChub3RlUGFydHNbMF0pO1xyXG4gICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgY29uc3Qgd2hvbGVOb3RlcyA9IFtcclxuICAgICAgICAgICAgICAgXCJBXCIsXHJcbiAgICAgICAgICAgICAgIFwiQlwiLFxyXG4gICAgICAgICAgICAgICBcIkNcIixcclxuICAgICAgICAgICAgICAgXCJEXCIsXHJcbiAgICAgICAgICAgICAgIFwiRVwiLFxyXG4gICAgICAgICAgICAgICBcIkZcIixcclxuICAgICAgICAgICAgICAgXCJHXCIsXHJcbiAgICAgICAgICAgICAgIFwiQVwiLFxyXG4gICAgICAgICAgICAgICBcIkJcIixcclxuICAgICAgICAgICAgICAgXCJDXCIsXHJcbiAgICAgICAgICAgICAgIFwiRFwiLFxyXG4gICAgICAgICAgICAgICBcIkVcIixcclxuICAgICAgICAgICAgICAgXCJGXCIsXHJcbiAgICAgICAgICAgICAgIFwiR1wiLFxyXG4gICAgICAgICAgIF07XHJcbiAgICAgICAgICAgY29uc3QgbGFzdFdob2xlTm90ZSA9IG5vdGVOYW1lc1tub3RlTmFtZXMubGVuZ3RoIC0gMV1bMF07XHJcbiAgICAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gd2hvbGVOb3Rlcy5pbmRleE9mKGxhc3RXaG9sZU5vdGUpO1xyXG4gICAgICAgICAgIGNvbnN0IG5leHROb3RlID0gd2hvbGVOb3Rlc1tsYXN0SW5kZXggKyAxXTtcclxuICAgICAgICAgICBpZiAobm90ZVBhcnRzWzBdLmluY2x1ZGVzKG5leHROb3RlKSkge1xyXG4gICAgICAgICAgICAgICBjb25zdCBoYXNPY3RhdmUgPSBub3RlUGFydHNbMF0ubWF0Y2goL1xcZC9nKTtcclxuICAgICAgICAgICAgICAgbm90ZU5hbWVzLnB1c2gobm90ZVBhcnRzWzBdICsgKGhhc09jdGF2ZSA/IFwiXCIgOiBvY3RhdmVzW2ldKSk7XHJcbiAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBjb25zdCBoYXNPY3RhdmUgPSBub3RlUGFydHNbbm90ZVBhcnRzLmxlbmd0aCAtIDFdLm1hdGNoKC9cXGQvZyk7XHJcbiAgICAgICAgICAgbm90ZU5hbWVzLnB1c2gobm90ZVBhcnRzW25vdGVQYXJ0cy5sZW5ndGggLSAxXSArIChoYXNPY3RhdmUgPyBcIlwiIDogb2N0YXZlc1tpXSkpO1xyXG4gICAgICAgfVxyXG4gICAgICAgY29uc3Qgc2hpZnRlZE5vdGVOYW1lcyA9IHNoaWZ0KG5vdGVOYW1lcywgc2NhbGUuc2hpZnRlZEludGVydmFsKCkpO1xyXG4gICAgICAgcmV0dXJuIHNoaWZ0ZWROb3RlTmFtZXM7XHJcbiAgIH07XHJcbiAgIC8qKlxyXG4gICAgKiBjcmVhdGVzIGEgbG9va3VwIHRhYmxlIGZvciBhbGwgbm90ZXMgZm9ybWF0dGVkIGFzIFtBLUddWyN8YnxzXVswLTldXHJcbiAgICAqL1xyXG4gICBjb25zdCBjcmVhdGVOb3Rlc0xvb2t1cFRhYmxlID0gKCkgPT4ge1xyXG4gICAgICAgY29uc3Qgc2NhbGVUYWJsZSA9IHt9O1xyXG4gICAgICAgZm9yIChsZXQgaXRvbmUgPSBUT05FU19NSU47IGl0b25lIDwgVE9ORVNfTUlOICsgT0NUQVZFX01BWDsgaXRvbmUrKykge1xyXG4gICAgICAgICAgIGZvciAobGV0IGlvY3RhdmUgPSBPQ1RBVkVfTUlOOyBpb2N0YXZlIDw9IE9DVEFWRV9NQVg7IGlvY3RhdmUrKykge1xyXG4gICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRlbXBsYXRlIG9mIE9iamVjdC52YWx1ZXMoU2NhbGVUZW1wbGF0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAga2V5OiBpdG9uZSxcclxuICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgb2N0YXZlOiBpb2N0YXZlLFxyXG4gICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICBzY2FsZVRhYmxlW2Ake2l0b25lfS0ke2lvY3RhdmV9LSR7SlNPTi5zdHJpbmdpZnkodGVtcGxhdGUpfWBdID1cclxuICAgICAgICAgICAgICAgICAgICAgICBzY2FsZU5vdGVOYW1lTG9va3VwKHNjYWxlKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgIH1cclxuICAgICAgIHJldHVybiBzY2FsZVRhYmxlO1xyXG4gICB9O1xyXG4gICAvKipcclxuICAgICogY3JlYXRlcyB0aGUgbG9va3VwIHRhYmxlIGFzIHNvb24gYXMgdGhlIG1vZHVsZSBpcyBsb2FkZWRcclxuICAgICovXHJcbiAgIGxldCBfbm90ZXNMb29rdXAgPSB7fTtcclxuICAgY29uc3Qgbm90ZXNMb29rdXAgPSAoa2V5KSA9PiB7XHJcbiAgICAgICAvLyBidWlsZFNjYWxlTm90ZVRhYmxlKCk7XHJcbiAgICAgICByZXR1cm4gX25vdGVzTG9va3VwW2tleV07XHJcbiAgIH07XHJcbiAgIGNvbnN0IGJ1aWxkU2NhbGVOb3RlVGFibGUgPSAoKSA9PiB7XHJcbiAgICAgICAvLyBpZiAoT2JqZWN0LmVudHJpZXMoX25vdGVzTG9va3VwKS5sZW5ndGggPiAwKSByZXR1cm4gX25vdGVzTG9va3VwO1xyXG4gICAgICAgX25vdGVzTG9va3VwID0gY3JlYXRlTm90ZXNMb29rdXBUYWJsZSgpO1xyXG4gICAgICAgT2JqZWN0LmZyZWV6ZShfbm90ZXNMb29rdXApO1xyXG4gICAgICAgY29uc29sZS5sb2coXCJidWlsdCBzY2FsZSBub3RlIHRhYmxlXCIpO1xyXG4gICAgICAgcmV0dXJuIF9ub3Rlc0xvb2t1cDtcclxuICAgfTtcblxuICAgLyoqXHJcbiAgICAqIFNob3J0Y3V0IGZvciBtb2RpZmllcnNcclxuICAgICogQGludGVybmFsXHJcbiAgICAqL1xyXG4gICBjb25zdCBmbGF0ID0gLTE7XHJcbiAgIGNvbnN0IGZsYXRfZmxhdCA9IC0yO1xyXG4gICBjb25zdCBzaGFycCA9IDE7XHJcbiAgIC8qKlxyXG4gICAgKiBDaG9yZCB0ZW1wbGF0ZXNcclxuICAgICogQGludGVybmFsXHJcbiAgICAqL1xyXG4gICBjb25zdCBDaG9yZFRlbXBsYXRlcyA9IHtcclxuICAgICAgIG1hajogWzEsIDMsIDVdLFxyXG4gICAgICAgbWFqNDogWzEsIDMsIDQsIDVdLFxyXG4gICAgICAgbWFqNjogWzEsIDMsIDUsIDZdLFxyXG4gICAgICAgbWFqNjk6IFsxLCAzLCA1LCA2LCA5XSxcclxuICAgICAgIG1hajc6IFsxLCAzLCA1LCA3XSxcclxuICAgICAgIG1hajk6IFsxLCAzLCA1LCA3LCA5XSxcclxuICAgICAgIG1hajExOiBbMSwgMywgNSwgNywgOSwgMTFdLFxyXG4gICAgICAgbWFqMTM6IFsxLCAzLCA1LCA3LCA5LCAxMSwgMTNdLFxyXG4gICAgICAgbWFqN3MxMTogWzEsIDMsIDUsIDcsIFsxMSwgc2hhcnBdXSxcclxuICAgICAgIG1hamI1OiBbMSwgMywgWzUsIGZsYXRdXSxcclxuICAgICAgIG1pbjogWzEsIFszLCBmbGF0XSwgNV0sXHJcbiAgICAgICBtaW40OiBbMSwgWzMsIGZsYXRdLCA0LCA1XSxcclxuICAgICAgIG1pbjY6IFsxLCBbMywgZmxhdF0sIDUsIDZdLFxyXG4gICAgICAgbWluNzogWzEsIFszLCBmbGF0XSwgNSwgWzcsIGZsYXRdXSxcclxuICAgICAgIG1pbkFkZDk6IFsxLCBbMywgZmxhdF0sIDUsIDldLFxyXG4gICAgICAgbWluNjk6IFsxLCBbMywgZmxhdF0sIDUsIDYsIDldLFxyXG4gICAgICAgbWluOTogWzEsIFszLCBmbGF0XSwgNSwgWzcsIGZsYXRdLCA5XSxcclxuICAgICAgIG1pbjExOiBbMSwgWzMsIGZsYXRdLCA1LCBbNywgZmxhdF0sIDksIDExXSxcclxuICAgICAgIG1pbjEzOiBbMSwgWzMsIGZsYXRdLCA1LCBbNywgZmxhdF0sIDksIDExLCAxM10sXHJcbiAgICAgICBtaW43YjU6IFsxLCBbMywgZmxhdF0sIFs1LCBmbGF0XSwgWzcsIGZsYXRdXSxcclxuICAgICAgIGRvbTc6IFsxLCAzLCA1LCBbNywgZmxhdF1dLFxyXG4gICAgICAgZG9tOTogWzEsIDMsIDUsIFs3LCBmbGF0XSwgOV0sXHJcbiAgICAgICBkb20xMTogWzEsIDMsIDUsIFs3LCBmbGF0XSwgOSwgMTFdLFxyXG4gICAgICAgZG9tMTM6IFsxLCAzLCA1LCBbNywgZmxhdF0sIDksIDExLCAxM10sXHJcbiAgICAgICBkb203czU6IFsxLCAzLCBbNSwgc2hhcnBdLCBbNywgZmxhdF1dLFxyXG4gICAgICAgZG9tN2I1OiBbMSwgMywgWzUsIGZsYXRdLCBbNywgZmxhdF1dLFxyXG4gICAgICAgZG9tN2I5OiBbMSwgMywgNSwgWzcsIGZsYXRdLCBbOSwgZmxhdF1dLFxyXG4gICAgICAgZG9tN3M5OiBbMSwgMywgNSwgWzcsIGZsYXRdLCBbOSwgc2hhcnBdXSxcclxuICAgICAgIGRvbTlzNTogWzEsIDMsIFs1LCBzaGFycF0sIFs3LCBmbGF0XSwgOV0sXHJcbiAgICAgICBkb205YjU6IFsxLCAzLCBbNSwgZmxhdF0sIFs3LCBmbGF0XSwgOV0sXHJcbiAgICAgICBkb203czVzOTogWzEsIDMsIFs1LCBzaGFycF0sIFs3LCBmbGF0XSwgWzksIHNoYXJwXV0sXHJcbiAgICAgICBkb203czViOTogWzEsIDMsIFs1LCBzaGFycF0sIFs3LCBmbGF0XSwgWzksIGZsYXRdXSxcclxuICAgICAgIGRvbTdzMTE6IFsxLCAzLCA1LCBbNywgZmxhdF0sIFsxMSwgc2hhcnBdXSxcclxuICAgICAgIGRpbTogWzEsIFszLCBmbGF0XSwgWzUsIGZsYXRdXSxcclxuICAgICAgIGRpbTc6IFsxLCBbMywgZmxhdF0sIFs1LCBmbGF0XSwgWzcsIGZsYXRfZmxhdF1dLFxyXG4gICAgICAgYXVnOiBbMSwgMywgWzUsIHNoYXJwXV0sXHJcbiAgICAgICBzdXMyOiBbMSwgMiwgNV0sXHJcbiAgICAgICBzdXM0OiBbMSwgWzQsIGZsYXRdLCA1XSxcclxuICAgICAgIGZpZnRoOiBbMSwgNV0sXHJcbiAgICAgICBiNTogWzEsIFs1LCBmbGF0XV0sXHJcbiAgICAgICBzMTE6IFsxLCA1LCBbMTEsIHNoYXJwXV0sXHJcbiAgIH07XHJcbiAgIE9iamVjdC5rZXlzKENob3JkVGVtcGxhdGVzKS5mb3JFYWNoKChlbGVtZW50KSA9PiBPYmplY3QuZnJlZXplKENob3JkVGVtcGxhdGVzW2VsZW1lbnRdKSk7XG5cbiAgIGNvbnN0IERFRkFVTFRfQ0hPUkRfVEVNUExBVEUgPSBbMSwgMywgNV07XHJcbiAgIGNvbnN0IERFRkFVTFRfU0NBTEUgPSBuZXcgU2NhbGUoKTtcblxuICAgLy8gaW1wb3J0IHRhYmxlIGZyb20gXCIuL25vdGVMb29rdXAuanNvblwiO1xyXG4gICAvKipcclxuICAgICogUmVnZXggZm9yIG1hdGNoaW5nIG5vdGUgbmFtZSwgbW9kaWZpZXIsIGFuZCBvY3RhdmVcclxuICAgICovXHJcbiAgIGNvbnN0IG5hbWVSZWdleCA9IC8oW0EtR10pKD89W14oXSpcXCkpL2c7XHJcbiAgIGNvbnN0IG1vZGlmaWVyUmVnZXggPSAvKCN8c3xiKSg/PVteKF0qXFwpKS9nO1xyXG4gICBjb25zdCBvY3RhdmVSZWdleCA9IC8oWzAtOV0rKSg/PVteKF0qXFwpKS9nO1xyXG4gICBjb25zdCBjaG9yZE5hbWVSZWdleCA9IC8obWlufG1hanxkaW18YXVnKSg/IVteKF0qXFwpKS9nO1xyXG4gICBjb25zdCBhZGRpdGlvbnNSZWdleCA9IC8oWyN8c3xiXT9bMC05XSspKD8hW14oXSpcXCkpL2c7XHJcbiAgIC8qKlxyXG4gICAgKiBAcGFyYW0gY2hvcmQgdGhlIHN0cmluZyB0byBwYXJzZVxyXG4gICAgKiBAcmV0dXJucyBhIHZhbGlkIENob3JkSW5pdGlhbGl6ZXJcclxuICAgICogQGludGVybmFsXHJcbiAgICAqL1xyXG4gICBjb25zdCBwYXJzZUNob3JkID0gKGNob3JkKSA9PiB7XHJcbiAgICAgICB0cnkge1xyXG4gICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNob3JkTG9va3VwKGNob3JkKTtcclxuICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfVxyXG4gICAgICAgY2F0Y2gge1xyXG4gICAgICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgICAgIH1cclxuICAgICAgIGxldCBub3RlSWRlbmlmaWVyID0gXCJcIjtcclxuICAgICAgIGxldCBub3RlTW9kaWZpZXIgPSAwO1xyXG4gICAgICAgbGV0IG5vdGVPY3RhdmUgPSBcIlwiO1xyXG4gICAgICAgbGV0IGNob3JkTmFtZSA9IFwibWFqXCI7XHJcbiAgICAgICBsZXQgYWRkaXRpb25zID0gW107XHJcbiAgICAgICBjb25zdCBuYW1lTWF0Y2ggPSBjaG9yZC5tYXRjaChuYW1lUmVnZXgpPy5qb2luKFwiXCIpLnNwbGl0KFwiXCIpO1xyXG4gICAgICAgY29uc3QgbW9kaWZpZXJNYXRjaCA9IGNob3JkLm1hdGNoKG1vZGlmaWVyUmVnZXgpPy5qb2luKFwiXCIpLnNwbGl0KFwiXCIpO1xyXG4gICAgICAgY29uc3Qgb2N0YXZlTWF0Y2ggPSBjaG9yZC5tYXRjaChvY3RhdmVSZWdleCk/LmpvaW4oXCJcIikuc3BsaXQoXCJcIik7XHJcbiAgICAgICBjb25zdCBjaG9yZE5hbWVNYXRjaCA9IGNob3JkLm1hdGNoKGNob3JkTmFtZVJlZ2V4KT8uam9pbihcIlwiKTtcclxuICAgICAgIGNvbnN0IGFkZGl0aW9uc01hdGNoID0gY2hvcmQubWF0Y2goYWRkaXRpb25zUmVnZXgpPy5qb2luKFwiXCIpLnNwbGl0KFwiXCIpO1xyXG4gICAgICAgLy8gY29tYmluZSBhbGwgbW9kaWZpZXJzXHJcbiAgICAgICBpZiAobW9kaWZpZXJNYXRjaCkge1xyXG4gICAgICAgICAgIGlmIChtb2RpZmllck1hdGNoLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgLy8gY29tYmluZSBhbGwgbW9kaWZpZXJzIGludG8gYW4gb2ZmZXNldCB2YWx1ZSB0byBiZSBhZGRlZCB0byB0aGUgc2VtaXRvbmVcclxuICAgICAgICAgICAgICAgbm90ZU1vZGlmaWVyID0gbW9kaWZpZXJNYXRjaFxyXG4gICAgICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gcGFyc2VNb2RpZmllcihpdGVtKSlcclxuICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgIG5vdGVNb2RpZmllciA9IHBhcnNlTW9kaWZpZXIobW9kaWZpZXJNYXRjaFswXSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfVxyXG4gICAgICAgaWYgKG9jdGF2ZU1hdGNoKSB7XHJcbiAgICAgICAgICAgY29uc3QgW29jdGF2ZV0gPSBvY3RhdmVNYXRjaDtcclxuICAgICAgICAgICBub3RlT2N0YXZlID0gb2N0YXZlO1xyXG4gICAgICAgfVxyXG4gICAgICAgaWYgKGNob3JkTmFtZU1hdGNoKSB7XHJcbiAgICAgICAgICAgLy8gY29uc3QgW25hbWVdID0gY2hvcmROYW1lTWF0Y2g7XHJcbiAgICAgICAgICAgY2hvcmROYW1lID0gY2hvcmROYW1lTWF0Y2g7XHJcbiAgICAgICB9XHJcbiAgICAgICBpZiAoYWRkaXRpb25zTWF0Y2gpIHtcclxuICAgICAgICAgICBhZGRpdGlvbnMgPSBhZGRpdGlvbnNNYXRjaDtcclxuICAgICAgIH1cclxuICAgICAgIGNvbnN0IGludGVydmFscyA9IFtdO1xyXG4gICAgICAgaWYgKG5hbWVNYXRjaCkge1xyXG4gICAgICAgICAgIGNvbnN0IFtub3RlTmFtZV0gPSBuYW1lTWF0Y2g7XHJcbiAgICAgICAgICAgbm90ZUlkZW5pZmllciA9IG5vdGVOYW1lO1xyXG4gICAgICAgICAgIGxldCBtb2RpZmllciA9IDA7XHJcbiAgICAgICAgICAgaWYgKG5vdGVNb2RpZmllcilcclxuICAgICAgICAgICAgICAgbW9kaWZpZXIgPSBub3RlTW9kaWZpZXI7XHJcbiAgICAgICAgICAgY29uc3Qgd3JhcHBlZFRvbmUgPSB3cmFwKGdldFdob2xlVG9uZUZyb21OYW1lKG5vdGVJZGVuaWZpZXIpICsgbW9kaWZpZXIsIFRPTkVTX01JTiwgVE9ORVNfTUFYKTtcclxuICAgICAgICAgICBjb25zdCBzZW1pdG9uZSA9IHdyYXBwZWRUb25lLnZhbHVlO1xyXG4gICAgICAgICAgIGxldCBvY3RhdmUgPSA0O1xyXG4gICAgICAgICAgIGlmIChub3RlT2N0YXZlKVxyXG4gICAgICAgICAgICAgICBvY3RhdmUgPSBjbGFtcChwYXJzZUludChub3RlT2N0YXZlLCAxMCksIE9DVEFWRV9NSU4sIE9DVEFWRV9NQVgpO1xyXG4gICAgICAgICAgIGludGVydmFscy5wdXNoKC4uLkNob3JkVGVtcGxhdGVzW2Nob3JkTmFtZV0pO1xyXG4gICAgICAgICAgIGZvciAoY29uc3QgYWRkaXRpb24gb2YgYWRkaXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgIGxldCBtb2QgPSAwO1xyXG4gICAgICAgICAgICAgICBpZiAoYWRkaXRpb25bMF0gPT09IFwiI1wiIHx8IGFkZGl0aW9uWzBdID09PSBcInNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgbW9kID0gMTtcclxuICAgICAgICAgICAgICAgICAgIGFkZGl0aW9ucy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGVsc2UgaWYgKGFkZGl0aW9uWzBdID09PSBcImJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgbW9kID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICBhZGRpdGlvbnMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBjb25zdCBhZGRpdGlvbk51bSA9IHBhcnNlSW50KGFkZGl0aW9uLCAxMCk7XHJcbiAgICAgICAgICAgICAgIGlmIChpbnRlcnZhbHMuaW5jbHVkZXMoYWRkaXRpb25OdW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGludGVydmFscy5pbmRleE9mKGFkZGl0aW9uTnVtKTtcclxuICAgICAgICAgICAgICAgICAgIGludGVydmFsc1tpbmRleF0gPSBbYWRkaXRpb25OdW0sIG1vZF07XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICBpbnRlcnZhbHMucHVzaChbYWRkaXRpb25OdW0sIG1vZF0pO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgIHJvb3Q6IHNlbWl0b25lLFxyXG4gICAgICAgICAgICAgICBvY3RhdmU6IG9jdGF2ZSxcclxuICAgICAgICAgICAgICAgdGVtcGxhdGU6IGludGVydmFscyxcclxuICAgICAgICAgICB9O1xyXG4gICAgICAgfVxyXG4gICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjaG9yZCBuYW1lXCIpO1xyXG4gICB9O1xyXG4gICAvKipcclxuICAgICogQHJldHVybnMgYSBsb29rdXAgdGFibGUgb2YgY2hvcmQgbmFtZXMgYW5kIHRoZWlyIGluaXRpYWxpemVyc1xyXG4gICAgKiBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgIGNvbnN0IGNyZWF0ZVRhYmxlID0gKCkgPT4ge1xyXG4gICAgICAgY29uc3QgdGFibGUgPSB7fTtcclxuICAgICAgIGNvbnN0IG5vdGVMZXR0ZXJzID0gW1wiQVwiLCBcIkJcIiwgXCJDXCIsIFwiRFwiLCBcIkVcIiwgXCJGXCIsIFwiR1wiXTtcclxuICAgICAgIGNvbnN0IG5vdGVNb2RpZmllcnMgPSBbXCJiXCIsIFwiI1wiLCBcInNcIl07XHJcbiAgICAgICBjb25zdCBxdWFsaXRpZXMgPSBbXCJtYWpcIiwgXCJtaW5cIiwgXCJkaW1cIiwgXCJhdWdcIiwgXCJzdXNcIl07XHJcbiAgICAgICBjb25zdCBhZGRpdGlvbnMgPSBbXHJcbiAgICAgICAgICAgXCJcIixcclxuICAgICAgICAgICBcIjJcIixcclxuICAgICAgICAgICBcIjNcIixcclxuICAgICAgICAgICBcIjRcIixcclxuICAgICAgICAgICBcIjVcIixcclxuICAgICAgICAgICBcIjZcIixcclxuICAgICAgICAgICBcIjdcIixcclxuICAgICAgICAgICBcIjlcIixcclxuICAgICAgICAgICBcIjExXCIsXHJcbiAgICAgICAgICAgXCIxM1wiLFxyXG4gICAgICAgICAgIFwiYjJcIixcclxuICAgICAgICAgICBcImIzXCIsXHJcbiAgICAgICAgICAgXCJiNFwiLFxyXG4gICAgICAgICAgIFwiYjVcIixcclxuICAgICAgICAgICBcImI2XCIsXHJcbiAgICAgICAgICAgXCJiN1wiLFxyXG4gICAgICAgICAgIFwiYjlcIixcclxuICAgICAgICAgICBcImIxMVwiLFxyXG4gICAgICAgICAgIFwiYjEzXCIsXHJcbiAgICAgICAgICAgXCJzMlwiLFxyXG4gICAgICAgICAgIFwiczNcIixcclxuICAgICAgICAgICBcInM0XCIsXHJcbiAgICAgICAgICAgXCJzNVwiLFxyXG4gICAgICAgICAgIFwiczZcIixcclxuICAgICAgICAgICBcInM3XCIsXHJcbiAgICAgICAgICAgXCJzOVwiLFxyXG4gICAgICAgICAgIFwiczExXCIsXHJcbiAgICAgICAgICAgXCJzMTNcIixcclxuICAgICAgICAgICBcIiMyXCIsXHJcbiAgICAgICAgICAgXCIjM1wiLFxyXG4gICAgICAgICAgIFwiIzRcIixcclxuICAgICAgICAgICBcIiM1XCIsXHJcbiAgICAgICAgICAgXCIjNlwiLFxyXG4gICAgICAgICAgIFwiIzdcIixcclxuICAgICAgICAgICBcIiM5XCIsXHJcbiAgICAgICAgICAgXCIjMTFcIixcclxuICAgICAgICAgICBcIiMxM1wiLFxyXG4gICAgICAgICAgIFwiN3MxMVwiLFxyXG4gICAgICAgICAgIFwiNyMxMVwiLFxyXG4gICAgICAgICAgIFwiN2I5XCIsXHJcbiAgICAgICAgICAgXCI3IzlcIixcclxuICAgICAgICAgICBcIjdiNVwiLFxyXG4gICAgICAgICAgIFwiNyM1XCIsXHJcbiAgICAgICAgICAgXCI3YjliNVwiLFxyXG4gICAgICAgICAgIFwiNyM5IzVcIixcclxuICAgICAgICAgICBcIjdiMTNcIixcclxuICAgICAgICAgICBcIjcjMTNcIixcclxuICAgICAgICAgICBcIjkjNVwiLFxyXG4gICAgICAgICAgIFwiOWI1XCIsXHJcbiAgICAgICAgICAgXCI5IzExXCIsXHJcbiAgICAgICAgICAgXCI5YjExXCIsXHJcbiAgICAgICAgICAgXCI5IzEzXCIsXHJcbiAgICAgICAgICAgXCI5YjEzXCIsXHJcbiAgICAgICAgICAgXCIxMSM1XCIsXHJcbiAgICAgICAgICAgXCIxMWI1XCIsXHJcbiAgICAgICAgICAgXCIxMSM5XCIsXHJcbiAgICAgICAgICAgXCIxMWI5XCIsXHJcbiAgICAgICAgICAgXCIxMSMxM1wiLFxyXG4gICAgICAgICAgIFwiMTFiMTNcIixcclxuICAgICAgIF07XHJcbiAgICAgICBmb3IgKGNvbnN0IHF1YWxpdHkgb2YgcXVhbGl0aWVzKSB7XHJcbiAgICAgICAgICAgZm9yIChjb25zdCBhZGRpdGlvbiBvZiBhZGRpdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgZm9yIChjb25zdCBub3RlTGV0dGVyIG9mIG5vdGVMZXR0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgKCR7bm90ZUxldHRlcn0pJHtxdWFsaXR5fSR7YWRkaXRpb259YDtcclxuICAgICAgICAgICAgICAgICAgIHRhYmxlW2tleV0gPSBwYXJzZUNob3JkKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5vdGVNb2RpZmllciBvZiBub3RlTW9kaWZpZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYCgke25vdGVMZXR0ZXJ9JHtub3RlTW9kaWZpZXJ9KSR7cXVhbGl0eX0ke2FkZGl0aW9ufWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdGFibGVba2V5XSA9IHBhcnNlQ2hvcmQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gT0NUQVZFX01JTjsgaSA8PSBPQ1RBVkVfTUFYOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYCgke25vdGVMZXR0ZXJ9JHtub3RlTW9kaWZpZXJ9JHtpfSkke3F1YWxpdHl9JHthZGRpdGlvbn1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZVtrZXldID0gcGFyc2VDaG9yZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgIH1cclxuICAgICAgIHJldHVybiB0YWJsZTtcclxuICAgfTtcclxuICAgbGV0IF9jaG9yZExvb2t1cCA9IHt9O1xyXG4gICAvKipcclxuICAgICogQHBhcmFtIGtleSB0aGUgc3RyaW5nIHRvIGxvb2t1cFxyXG4gICAgKiBAcmV0dXJucyBhIHZhbGlkIGNob3JkIGluaXRpYWxpemVyXHJcbiAgICAqIEB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIGtleSBpcyBub3QgYSB2YWxpZCBjaG9yZFxyXG4gICAgKiBAaW50ZXJuYWxcclxuICAgICovXHJcbiAgIGNvbnN0IGNob3JkTG9va3VwID0gKGtleSkgPT4ge1xyXG4gICAgICAgLy8gYnVpbGRDaG9yZFRhYmxlKCk7XHJcbiAgICAgICByZXR1cm4gX2Nob3JkTG9va3VwW2tleV07XHJcbiAgIH07XHJcbiAgIC8vIHJlZ2lzdGVySW5pdGlhbGl6ZXIoKCkgPT4ge1xyXG4gICAvLyAgICBfY2hvcmRMb29rdXAgPSBjcmVhdGVUYWJsZSgpO1xyXG4gICAvLyB9KTtcclxuICAgLy8gaWYgKHRhYmxlICYmIE9iamVjdC5rZXlzKHRhYmxlKS5sZW5ndGggPiAwKSB7XHJcbiAgIC8vICAgIF9jaG9yZExvb2t1cCA9IHRhYmxlIGFzIHsgW2tleTogc3RyaW5nXTogQ2hvcmRJbml0aWFsaXplciB9O1xyXG4gICAvLyB9IGVsc2Uge1xyXG4gICAvLyAgICBfY2hvcmRMb29rdXAgPSBjcmVhdGVUYWJsZSgpO1xyXG4gICAvLyB9XHJcbiAgIGNvbnN0IGJ1aWxkQ2hvcmRUYWJsZSA9ICgpID0+IHtcclxuICAgICAgIC8vIGlmIChPYmplY3QuZW50cmllcyhfY2hvcmRMb29rdXApLmxlbmd0aCA+IDApIHJldHVybiBfY2hvcmRMb29rdXA7XHJcbiAgICAgICBfY2hvcmRMb29rdXAgPSBjcmVhdGVUYWJsZSgpO1xyXG4gICAgICAgT2JqZWN0LmZyZWV6ZShfY2hvcmRMb29rdXApO1xyXG4gICAgICAgY29uc29sZS5sb2coXCJidWlsdCBjaG9yZCB0YWJsZVwiKTtcclxuICAgICAgIC8vIGNvbnNvbGUubG9nKE9iamVjdC5lbnRyaWVzKF9jaG9yZExvb2t1cCkubGVuZ3RoKTtcclxuICAgICAgIHJldHVybiBfY2hvcmRMb29rdXA7XHJcbiAgIH07XG5cbiAgIC8qKlxyXG4gICAgKiBDaG9yZHMgY29uc2lzdCBvZiBhIHJvb3Qgbm90ZSwgb2N0YXZlLCBjaG9yZCB0ZW1wbGF0ZSwgYW5kIGEgYmFzZSBzY2FsZS48YnI+PGJyPlxyXG4gICAgKiBUaGUgY2hvcmQgdGVtcGxhdGUgaXMgYW4gYXJyYXkgb2YgaW50ZWdlcnMsIGVhY2ggaW50ZWdlciByZXByZXNlbnRpbmc8YnI+XHJcbiAgICAqICBhIHNjYWxlIGRlZ3JlZSBmcm9tIHRoZSBiYXNlIHNjYWxlKGRlZmF1bHRzIHRvIG1ham9yKS48YnI+XHJcbiAgICAqIFRoZSBkZWZhdWx0IHRlbXBsYXRlIGlzIHRoZSBJLElJSSxWIGRlbm90ZWQgYXMgWzEsMyw1XTxicj5cclxuICAgICogQ2hvcmRJbnRlcnZhbHMgdXNlZCBpbiB0ZW1wbGF0ZXMgY2FuIGFsc28gY29udGFpbiBhIG1vZGlmaWVyLDxicj5cclxuICAgICogZm9yIGEgcGFydGljdWxhciBzY2FsZSBkZWdyZWUsIHN1Y2ggYXMgWzEsMyxbNSwgLTFdXTxicj5cclxuICAgICogd2hlcmUgLTEgaXMgZmxhdCwgMCBpcyBuYXR1cmFsLCBhbmQgMSBpcyBzaGFycC48YnI+XHJcbiAgICAqIEl0IGNvdWxkIGFsc28gYmUgd3JpdHRlbiBhcyBbMSwzLFs1LCBtb2RpZmllci5mbGF0XV08YnI+XHJcbiAgICAqIGlmIHlvdSBpbXBvcnQgbW9kaWZpZXIuXHJcbiAgICAqXHJcbiAgICAqIFRoZSBmb2xsb3dpbmcgcHJlZGVmaW5lZCB0ZW1wbGF0ZXMgYXJlIGF2YWlsYWJsZTo8YnI+XHJcbiAgICAqIDx0YWJsZT5cclxuICAgICogPHRyPlxyXG4gICAgKiA8dGQ+bWFqPC90ZD5cclxuICAgICogPHRkPm1hajQ8L3RkPlxyXG4gICAgKiA8dGQ+bWFqNjwvdGQ+XHJcbiAgICAqIDx0ZD5tYWo2OTwvdGQ+XHJcbiAgICAqIDwvdHI+PHRyPlxyXG4gICAgKiA8dGQ+bWFqNzwvdGQ+XHJcbiAgICAqIDx0ZD5tYWo5PC90ZD5cclxuICAgICogPHRkPm1hajExPC90ZD5cclxuICAgICogPHRkPm1hajEzPC90ZD5cclxuICAgICogPC90cj48dHI+XHJcbiAgICAqIDx0ZD5tYWo3czExPC90ZD5cclxuICAgICogPHRkPm1hamI1PC90ZD5cclxuICAgICogPHRkPm1pbjwvdGQ+XHJcbiAgICAqIDx0ZD5taW40PC90ZD5cclxuICAgICogPC90cj48dHI+XHJcbiAgICAqIDx0ZD5taW42PC90ZD5cclxuICAgICogPHRkPm1pbjc8L3RkPlxyXG4gICAgKiA8dGQ+bWluQWRkOTwvdGQ+XHJcbiAgICAqIDx0ZD5taW42OTwvdGQ+XHJcbiAgICAqIDwvdHI+PHRyPlxyXG4gICAgKiA8dGQ+bWluOTwvdGQ+XHJcbiAgICAqIDx0ZD5taW4xMTwvdGQ+XHJcbiAgICAqIDx0ZD5taW4xMzwvdGQ+XHJcbiAgICAqIDx0ZD5taW43YjU8L3RkPlxyXG4gICAgKiA8L3RyPjx0cj5cclxuICAgICogPHRkPmRvbTc8L3RkPlxyXG4gICAgKiA8dGQ+ZG9tOTwvdGQ+XHJcbiAgICAqIDx0ZD5kb20xMTwvdGQ+XHJcbiAgICAqIDx0ZD5kb20xMzwvdGQ+XHJcbiAgICAqIDwvdHI+PHRyPlxyXG4gICAgKiA8dGQ+ZG9tN3M1PC90ZD5cclxuICAgICogPHRkPmRvbTdiNTwvdGQ+XHJcbiAgICAqIDx0ZD5kb203czk8L3RkPlxyXG4gICAgKiA8dGQ+ZG9tN2I5PC90ZD5cclxuICAgICogPC90cj48dHI+XHJcbiAgICAqIDx0ZD5kb205YjU8L3RkPlxyXG4gICAgKiA8dGQ+ZG9tOXM1PC90ZD5cclxuICAgICogPHRkPmRvbTdzMTE8L3RkPlxyXG4gICAgKiA8dGQ+ZG9tN3M1czk8L3RkPlxyXG4gICAgKiA8L3RyPjx0cj5cclxuICAgICogPHRkPmRvbTdzNWI5PC90ZD5cclxuICAgICogPHRkPmRpbTwvdGQ+XHJcbiAgICAqIDx0ZD5kaW03PC90ZD5cclxuICAgICogPHRkPmF1ZzwvdGQ+XHJcbiAgICAqIDwvdHI+PHRyPlxyXG4gICAgKiA8dGQ+c3VzMjwvdGQ+XHJcbiAgICAqIDx0ZD5zdXM0PC90ZD5cclxuICAgICogPHRkPmZpZnRoPC90ZD5cclxuICAgICogPHRkPmI1PC90ZD5cclxuICAgICogPC90cj48dHI+XHJcbiAgICAqIDx0ZD5zMTE8L3RkPlxyXG4gICAgKiA8L3RyPlxyXG4gICAgKiA8L3RhYmxlPlxyXG4gICAgKlxyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAqIGltcG9ydCB7IENob3JkIH0gZnJvbSBcIm11c2ljdGhlb3J5anNcIjtcclxuICAgICogaW1wb3J0IHtDaG9yZFRlbXBsYXRlfSBmcm9tIFwibXVzaWN0aGVvcnlqc1wiO1xyXG4gICAgKiBpbXBvcnQge0Nob3JkSW50ZXJ2YWx9IGZyb20gXCJtdXNpY3RoZW9yeWpzXCI7XHJcbiAgICAqIGltcG9ydCB7TW9kaWZpZXJ9IGZyb20gXCJtdXNpY3RoZW9yeWpzXCI7XHJcbiAgICAqIGltcG9ydCB7Q2hvcmRJbml0aWFsaXplcn0gZnJvbSBcIm11c2ljdGhlb3J5anNcIjsvLyBUeXBlc2NyaXB0IG9ubHkgaWYgbmVlZGVkXHJcbiAgICAqIGBgYFxyXG4gICAgKi9cclxuICAgY2xhc3MgQ2hvcmQge1xyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogaW1wb3J0IHsgQ2hvcmQsIENob3JkVGVtcGxhdGVzLCBNb2RpZmllciB9IGZyb20gXCJtdXNpY3RoZW9yeWpzXCI7XHJcbiAgICAgICAgKlxyXG4gICAgICAgICogLy9jcmVhdGVzIGEgY2hvcmQgd2l0aCB0aGUgZGVmYXVsdCgxLDMsNSkgdGVtcGxhdGUsIHJvb3Qgb2YgQywgaW4gdGhlIDR0aCBvY3RhdmVcclxuICAgICAgICAqIGNvbnN0IGNob3JkID0gbmV3IENob3JkKCk7XHJcbiAgICAgICAgKlxyXG4gICAgICAgICogLy8gY3JlYXRlcyBhIGNob3JkIHdpdGggdGhlIHByZS1kZWZpbmVkIGRpbWluaXNoZWQgdGVtcGxhdGUsIHJvb3Qgb2YgRWIsIGluIHRoZSA1dGggb2N0YXZlXHJcbiAgICAgICAgKiBjb25zdCBjaG9yZCA9IG5ldyBDaG9yZCh7cm9vdDogMywgb2N0YXZlOiA1LCB0ZW1wbGF0ZTogQ2hvcmRUZW1wbGF0ZXMuZGltfSk7XHJcbiAgICAgICAgKlxyXG4gICAgICAgICogLy8gU3RyaW5nIHBhcnNpbmcgc2hvdWxkIGZvbGxvdyB0aGUgZm9ybWF0OiAocm9vdC1ub3RlLW5hbWVbcywjLGJdW29jdGF2ZV0pW2Nob3JkLXRlbXBsYXRlLW5hbWV8W2Nob3JkLXF1YWxpdHldW21vZGlmaWVyc11dXHJcbiAgICAgICAgKiAvLyBjcmVhdGVzIGEgY2hvcmQgZnJvbSBhIHN0cmluZ1xyXG4gICAgICAgICogY29uc3QgY2hvcmQgPSBuZXcgQ2hvcmQoJyhENCltaW40Jyk7XHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgY29uc3RydWN0b3IodmFsdWVzKSB7XHJcbiAgICAgICAgICAgaWYgKCF2YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBbLi4uREVGQVVMVF9DSE9SRF9URU1QTEFURV07XHJcbiAgICAgICAgICAgICAgIHRoaXMub2N0YXZlID0gREVGQVVMVF9PQ1RBVkU7XHJcbiAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IERFRkFVTFRfU0VNSVRPTkU7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZXMgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VDaG9yZCh2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IFsuLi4ocGFyc2VkPy50ZW1wbGF0ZSA/PyBERUZBVUxUX0NIT1JEX1RFTVBMQVRFKV07XHJcbiAgICAgICAgICAgICAgIHRoaXMub2N0YXZlID0gcGFyc2VkPy5vY3RhdmUgPz8gREVGQVVMVF9PQ1RBVkU7XHJcbiAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IHBhcnNlZD8ucm9vdCA/PyBERUZBVUxUX1NFTUlUT05FO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBbLi4uKHZhbHVlcy50ZW1wbGF0ZSA/PyBERUZBVUxUX0NIT1JEX1RFTVBMQVRFKV07XHJcbiAgICAgICAgICAgICAgIHRoaXMub2N0YXZlID0gdmFsdWVzLm9jdGF2ZSA/PyBERUZBVUxUX09DVEFWRTtcclxuICAgICAgICAgICAgICAgdGhpcy5yb290ID0gdmFsdWVzLnJvb3QgPz8gREVGQVVMVF9TRU1JVE9ORTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgdGhpcy5fYmFzZVNjYWxlID0gbmV3IFNjYWxlKHsga2V5OiB0aGlzLl9yb290LCBvY3RhdmU6IHRoaXMuX29jdGF2ZSB9KTtcclxuICAgICAgICAgICB0aGlzLl9ub3Rlc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogdW5pcXVlIGlkIGZvciB0aGlzIGluc3RhbmNlXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3QgY2hvcmQgPSBuZXcgQ2hvcmQoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNob3JkLmlkKTsgLy8gaGFsODkzNGhsbFxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGlkID0gdWlkKCk7XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIHJvb3RcclxuICAgICAgICAqL1xyXG4gICAgICAgX3Jvb3QgPSBERUZBVUxUX1NFTUlUT05FO1xyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3QgY2hvcmQgPSBuZXcgQ2hvcmQoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNob3JkLnJvb3QpOyAvLyAwKHNlbWl0b25lKVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGdldCByb290KCkge1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzLl9yb290O1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBTZXR0aW5nIHRoZSByb290IHRvIGEgdmFsdWUgb3V0c2lkZSBvZiB0aGUgcmFuZ2UgWzAsIDExXShzZW1pdG9uZSkgd2lsbDxici8+XHJcbiAgICAgICAgKiB3cmFwIHRoZSBzZW1pdG9uZSB0byB0aGUgcmFuZ2UgWzAsIDExXSBhbmQgY2hhbmdlIHRoZSBvY3RhdmUgZGVwZW5kaW5nPGJyLz5cclxuICAgICAgICAqIG9uIGhvdyBtYW55IHRpbWVzIHRoZSBzZW1pdG9uZSBoYXMgYmVlbiB3cmFwcGVkLlxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGNob3JkID0gbmV3IENob3JkKCk7XHJcbiAgICAgICAgKiBjaG9yZC5yb290ID0gNDsgLy8gc2V0cyB0aGUgcm9vdCB0byA0dGggc2VtaXRvbmUoRSlcclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNob3JkLnJvb3QpOyAvLyA0KHNlbWl0b25lKVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHNldCByb290KHZhbHVlKSB7XHJcbiAgICAgICAgICAgLy8gdGhpcy5fcm9vdCA9IHZhbHVlO1xyXG4gICAgICAgICAgIGNvbnN0IHdyYXBwZWQgPSB3cmFwKHZhbHVlLCBUT05FU19NSU4sIFRPTkVTX01BWCk7XHJcbiAgICAgICAgICAgdGhpcy5fcm9vdCA9IHdyYXBwZWQudmFsdWU7XHJcbiAgICAgICAgICAgdGhpcy5fb2N0YXZlID0gdGhpcy5fb2N0YXZlICsgd3JhcHBlZC5udW1XcmFwcztcclxuICAgICAgICAgICB0aGlzLl9ub3Rlc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogYmFzZSBzY2FsZVxyXG4gICAgICAgICovXHJcbiAgICAgICBfYmFzZVNjYWxlID0gREVGQVVMVF9TQ0FMRTtcclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGNob3JkID0gbmV3IENob3JkKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhjaG9yZC5iYXNlU2NhbGUpOyAvLyBwcmludHMgdGhlIGRlZmF1bHQgc2NhbGUobWFqb3IpXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgZ2V0IGJhc2VTY2FsZSgpIHtcclxuICAgICAgICAgICByZXR1cm4gdGhpcy5fYmFzZVNjYWxlO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBOb3QgYSBsb3Qgb2YgZ29vZCByZWFzb25zIHRvIGNoYW5nZSB0aGlzIGV4Y2VwdCBmb3IgZXhwZXJpbWVudGF0aW9uXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3QgY2hvcmQgPSBuZXcgQ2hvcmQoKTtcclxuICAgICAgICAqIGNob3JkLmJhc2VTY2FsZSA9IG5ldyBTY2FsZSh7IGtleTogMywgb2N0YXZlOiA1LCB0ZW1wbGF0ZTogWzEsIFszLCBNb2RpZmllci5mbGF0XSwgNV0gfSk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhjaG9yZC5iYXNlU2NhbGUpOyAvLyBwcmludHMgdGhlIG1pbm9yIHNjYWxlXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgc2V0IGJhc2VTY2FsZSh2YWx1ZSkge1xyXG4gICAgICAgICAgIHRoaXMuX2Jhc2VTY2FsZSA9IHZhbHVlO1xyXG4gICAgICAgICAgIHRoaXMuX2Jhc2VTY2FsZS5vY3RhdmUgPSB0aGlzLl9vY3RhdmU7XHJcbiAgICAgICAgICAgdGhpcy5fbm90ZXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIG9jdGF2ZVxyXG4gICAgICAgICovXHJcbiAgICAgICBfb2N0YXZlID0gREVGQVVMVF9PQ1RBVkU7XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIFRoZSBvY3RhdmUgaXMgY2xhbXBlZCB0byB0aGUgcmFuZ2UgWzAsIDldLlxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGNob3JkID0gbmV3IENob3JkKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhjaG9yZC5vY3RhdmUpOyAvLyA0KG9jdGF2ZSlcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBnZXQgb2N0YXZlKCkge1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzLl9vY3RhdmU7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBjaG9yZCA9IG5ldyBDaG9yZCgpO1xyXG4gICAgICAgICogY2hvcmQub2N0YXZlID0gNTsgLy8gc2V0cyB0aGUgb2N0YXZlIHRvIDV0aFxyXG4gICAgICAgICogY29uc29sZS5sb2coY2hvcmQub2N0YXZlKTsgLy8gNShvY3RhdmUpXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgc2V0IG9jdGF2ZSh2YWx1ZSkge1xyXG4gICAgICAgICAgIHRoaXMuX29jdGF2ZSA9IGNsYW1wKHZhbHVlLCBPQ1RBVkVfTUlOLCBPQ1RBVkVfTUFYKTtcclxuICAgICAgICAgICB0aGlzLl9iYXNlU2NhbGUub2N0YXZlID0gdGhpcy5fb2N0YXZlO1xyXG4gICAgICAgICAgIHRoaXMuX25vdGVzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiB0ZW1wbGF0ZVxyXG4gICAgICAgICovXHJcbiAgICAgICBfdGVtcGxhdGUgPSBbXTtcclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGNob3JkID0gbmV3IENob3JkKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhjaG9yZC50ZW1wbGF0ZSk7IC8vIHByaW50cyB0aGUgZGVmYXVsdCB0ZW1wbGF0ZVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGdldCB0ZW1wbGF0ZSgpIHtcclxuICAgICAgICAgICByZXR1cm4gWy4uLnRoaXMuX3RlbXBsYXRlXTtcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIGZvbGxvd2luZyBwcmVkZWZpbmVkIHRlbXBsYXRlcyBhcmUgYXZhaWxhYmxlOjxicj5cclxuICAgICAgICAqIDx0YWJsZT5cclxuICAgICAgICAqIDx0cj5cclxuICAgICAgICAqIDx0ZD5tYWo8L3RkPlxyXG4gICAgICAgICogPHRkPm1hajQ8L3RkPlxyXG4gICAgICAgICogPHRkPm1hajY8L3RkPlxyXG4gICAgICAgICogPHRkPm1hajY5PC90ZD5cclxuICAgICAgICAqIDwvdHI+PHRyPlxyXG4gICAgICAgICogPHRkPm1hajc8L3RkPlxyXG4gICAgICAgICogPHRkPm1hajk8L3RkPlxyXG4gICAgICAgICogPHRkPm1hajExPC90ZD5cclxuICAgICAgICAqIDx0ZD5tYWoxMzwvdGQ+XHJcbiAgICAgICAgKiA8L3RyPjx0cj5cclxuICAgICAgICAqIDx0ZD5tYWo3czExPC90ZD5cclxuICAgICAgICAqIDx0ZD5tYWpiNTwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+bWluPC90ZD5cclxuICAgICAgICAqIDx0ZD5taW40PC90ZD5cclxuICAgICAgICAqIDwvdHI+PHRyPlxyXG4gICAgICAgICogPHRkPm1pbjY8L3RkPlxyXG4gICAgICAgICogPHRkPm1pbjc8L3RkPlxyXG4gICAgICAgICogPHRkPm1pbkFkZDk8L3RkPlxyXG4gICAgICAgICogPHRkPm1pbjY5PC90ZD5cclxuICAgICAgICAqIDwvdHI+PHRyPlxyXG4gICAgICAgICogPHRkPm1pbjk8L3RkPlxyXG4gICAgICAgICogPHRkPm1pbjExPC90ZD5cclxuICAgICAgICAqIDx0ZD5taW4xMzwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+bWluN2I1PC90ZD5cclxuICAgICAgICAqIDwvdHI+PHRyPlxyXG4gICAgICAgICogPHRkPmRvbTc8L3RkPlxyXG4gICAgICAgICogPHRkPmRvbTk8L3RkPlxyXG4gICAgICAgICogPHRkPmRvbTExPC90ZD5cclxuICAgICAgICAqIDx0ZD5kb20xMzwvdGQ+XHJcbiAgICAgICAgKiA8L3RyPjx0cj5cclxuICAgICAgICAqIDx0ZD5kb203czU8L3RkPlxyXG4gICAgICAgICogPHRkPmRvbTdiNTwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+ZG9tN3M5PC90ZD5cclxuICAgICAgICAqIDx0ZD5kb203Yjk8L3RkPlxyXG4gICAgICAgICogPC90cj48dHI+XHJcbiAgICAgICAgKiA8dGQ+ZG9tOWI1PC90ZD5cclxuICAgICAgICAqIDx0ZD5kb205czU8L3RkPlxyXG4gICAgICAgICogPHRkPmRvbTdzMTE8L3RkPlxyXG4gICAgICAgICogPHRkPmRvbTdzNXM5PC90ZD5cclxuICAgICAgICAqIDwvdHI+PHRyPlxyXG4gICAgICAgICogPHRkPmRvbTdzNWI5PC90ZD5cclxuICAgICAgICAqIDx0ZD5kaW08L3RkPlxyXG4gICAgICAgICogPHRkPmRpbTc8L3RkPlxyXG4gICAgICAgICogPHRkPmF1ZzwvdGQ+XHJcbiAgICAgICAgKiA8L3RyPjx0cj5cclxuICAgICAgICAqIDx0ZD5zdXMyPC90ZD5cclxuICAgICAgICAqIDx0ZD5zdXM0PC90ZD5cclxuICAgICAgICAqIDx0ZD5maWZ0aDwvdGQ+XHJcbiAgICAgICAgKiA8dGQ+YjU8L3RkPlxyXG4gICAgICAgICogPC90cj48dHI+XHJcbiAgICAgICAgKiA8dGQ+czExPC90ZD5cclxuICAgICAgICAqIDwvdHI+XHJcbiAgICAgICAgKiA8L3RhYmxlPlxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGNob3JkID0gbmV3IENob3JkKCk7XHJcbiAgICAgICAgKiBjaG9yZC50ZW1wbGF0ZSA9IFsxLCBbMywgTW9kaWZpZXIuZmxhdF0sIDVdOyAvLyBzZXRzIHRoZSB0ZW1wbGF0ZSB0byBhIG1pbm9yIGNob3JkXHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhjaG9yZC50ZW1wbGF0ZSk7IC8vIHByaW50cyB0aGUgbmV3IHRlbXBsYXRlXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgc2V0IHRlbXBsYXRlKHZhbHVlKSB7XHJcbiAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBbLi4udmFsdWVdO1xyXG4gICAgICAgICAgIHRoaXMuX25vdGVzRGlydHkgPSB0cnVlO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBub3Rlc1xyXG4gICAgICAgICogbm90ZXMgYXJlIGdlbmVyYXRlZCBhbmQgY2FjaGVkIGFzIG5lZWRlZFxyXG4gICAgICAgICovXHJcbiAgICAgICBfbm90ZXMgPSBbXTtcclxuICAgICAgIF9ub3Rlc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgIC8qKlxyXG4gICAgICAgICogd2lsbCBnZW5lcmF0ZSBub3RlcyBpZiBuZWVkZWQgb3IgcmV0dXJuIHRoZSBjYWNoZWQgbm90ZXNcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBjaG9yZCA9IG5ldyBDaG9yZCgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coY2hvcmQubm90ZXMpOyAvLyBwcmludHMgdGhlIGRlZmF1bHQgbm90ZXNcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBnZXQgbm90ZXMoKSB7XHJcbiAgICAgICAgICAgaWYgKHRoaXMuX25vdGVzRGlydHkpIHtcclxuICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZU5vdGVzKCk7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX25vdGVzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vdGVzO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBnZW5lcmF0ZSBub3RlcyhpbnRlcm5hbClcclxuICAgICAgICAqIGdlbmVyYXRlcyB0aGUgbm90ZXMgZm9yIHRoaXMgc2NhbGVcclxuICAgICAgICAqL1xyXG4gICAgICAgZ2VuZXJhdGVOb3RlcygpIHtcclxuICAgICAgICAgICB0aGlzLl9ub3RlcyA9IFtdO1xyXG4gICAgICAgICAgIGZvciAoY29uc3QgaW50ZXJ2YWwgb2YgdGhpcy5fdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgbGV0IHRvbmUgPSAwO1xyXG4gICAgICAgICAgICAgICBsZXQgbW9kID0gMDtcclxuICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICB0b25lID0gaW50ZXJ2YWxbMF07XHJcbiAgICAgICAgICAgICAgICAgICBtb2QgPSBpbnRlcnZhbFsxXTtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgIHRvbmUgPSBpbnRlcnZhbDtcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0b25lO1xyXG4gICAgICAgICAgICAgICBjb25zdCBub3RlID0gdGhpcy5fYmFzZVNjYWxlLmRlZ3JlZShvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICBjb25zdCBub3RlVG9uZSA9IG5vdGUuc2VtaXRvbmU7XHJcbiAgICAgICAgICAgICAgIG5vdGUuc2VtaXRvbmUgPSBub3RlVG9uZSArIG1vZDtcclxuICAgICAgICAgICAgICAgdGhpcy5fbm90ZXMucHVzaChub3RlKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vdGVzO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcmV0dXJucyB0aGUgbm90ZSBuYW1lcyAtPiBbJ0M0JywgJ0U0JywgJ0c0J11cclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBjaG9yZCA9IG5ldyBDaG9yZCgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coY2hvcmQuZ2V0Tm90ZU5hbWVzKCkpOyAvLyBbJ0M0JywgJ0U0JywgJ0c0J11cclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBnZXROb3RlTmFtZXMoKSB7XHJcbiAgICAgICAgICAgY29uc3Qgbm90ZU5hbWVzID0gW107XHJcbiAgICAgICAgICAgZm9yIChjb25zdCBub3RlIG9mIHRoaXMubm90ZXMpIHtcclxuICAgICAgICAgICAgICAgbm90ZU5hbWVzLnB1c2gobm90ZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgcmV0dXJuIG5vdGVOYW1lcztcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoZSBjaG9yZFxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGNob3JkID0gbmV3IENob3JkKCk7XHJcbiAgICAgICAgKiBjb25zdCBjb3B5ID0gY2hvcmQuY29weSgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coY2hvcmQuZXF1YWxzKGNvcHkpKTsgLy8gdHJ1ZVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGNvcHkoKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIG5ldyBDaG9yZCh7XHJcbiAgICAgICAgICAgICAgIHJvb3Q6IHRoaXMucm9vdCxcclxuICAgICAgICAgICAgICAgb2N0YXZlOiB0aGlzLm9jdGF2ZSxcclxuICAgICAgICAgICAgICAgdGVtcGxhdGU6IFsuLi50aGlzLl90ZW1wbGF0ZV0sXHJcbiAgICAgICAgICAgfSk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBwYXJhbSBvdGhlciB0aGUgb3RoZXIgY2hvcmQgdG8gY29tcGFyZSB0b1xyXG4gICAgICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIGNob3JkcyBhcmUgZXF1YWxcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBjaG9yZCA9IG5ldyBDaG9yZCgpO1xyXG4gICAgICAgICogY29uc3QgY29weSA9IGNob3JkLmNvcHkoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNob3JkLmVxdWFscyhjb3B5KSk7IC8vIHRydWVcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICAgICByZXR1cm4gKHRoaXMucm9vdCA9PT0gb3RoZXIucm9vdCAmJlxyXG4gICAgICAgICAgICAgICB0aGlzLm9jdGF2ZSA9PT0gb3RoZXIub2N0YXZlICYmXHJcbiAgICAgICAgICAgICAgIGlzRXF1YWwodGhpcy5fdGVtcGxhdGUsIG90aGVyLnRlbXBsYXRlKSk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIG11dGF0ZXMgdGhlIGNob3JkIGluIHBsYWNlXHJcbiAgICAgICAgKiBAY2hhaW5hYmxlXHJcbiAgICAgICAgKiBAcmV0dXJucyB0aGUgY2hvcmQgd2l0aCBhIG5hdHJ1YWwgM3JkXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3QgY2hvcmQgPSBuZXcgQ2hvcmQoKTtcclxuICAgICAgICAqIGNob3JkLm1pbm9yKCk7XHJcbiAgICAgICAgKiBjaG9yZC5tYWpvcigpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coY2hvcmQudGVtcGxhdGUpOyAvLyBbMSwzLDVdXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgbWFqb3IoKSB7XHJcbiAgICAgICAgICAgbGV0IGluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90ZW1wbGF0ZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGVbaV0gPT09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gdGhpcy5fdGVtcGxhdGVbaV07XHJcbiAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGludGVydmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKChpbnRlcnZhbFswXSA/PyAwKSA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLnB1c2goMyk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZVtpbmRleF0gPSAzO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICB0aGlzLl9ub3Rlc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoZSBjaG9yZCB3aXRoIGEgbmF0dXJhbCAzcmRcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBjaG9yZCA9IG5ldyBDaG9yZCgpO1xyXG4gICAgICAgICogY2hvcmQubWlub3IoKTtcclxuICAgICAgICAqIGNvbnN0IGNvcHkgPSBjaG9yZC5tYWpvcmVkKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhjb3B5LnRlbXBsYXRlKTsgLy8gWzEsMyw1XVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIG1ham9yZWQoKSB7XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuY29weSgpLm1ham9yKCk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGNob3JkIGhhcyBhIG5hdHVyYWwgM3JkXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3QgY2hvcmQgPSBuZXcgQ2hvcmQoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNob3JkLmlzTWFqb3IoKSk7IC8vIHRydWVcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBpc01ham9yKCkge1xyXG4gICAgICAgICAgIGZvciAoY29uc3QgaW50ZXJ2YWwgb2YgdGhpcy5fdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoKGludGVydmFsWzBdID8/IDApID09PSAzICYmIChpbnRlcnZhbFsxXSA/PyAwKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKGludGVydmFsID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiAgbXV0YXRlcyB0aGUgY2hvcmQgaW4gcGxhY2VcclxuICAgICAgICAqIEBjaGFpbmFibGVcclxuICAgICAgICAqIEByZXR1cm5zIHRoZSBjaG9yZCB3aXRoIGEgZmxhdCAzcmRcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBjaG9yZCA9IG5ldyBDaG9yZCgpO1xyXG4gICAgICAgICogY2hvcmQubWlub3IoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNob3JkLnRlbXBsYXRlKTsgLy8gWzEsWzMsLTFdLDVdXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgbWlub3IoKSB7XHJcbiAgICAgICAgICAgbGV0IGluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90ZW1wbGF0ZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGVbaV0gPT09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gdGhpcy5fdGVtcGxhdGVbaV07XHJcbiAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGludGVydmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKChpbnRlcnZhbFswXSA/PyAwKSA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLnB1c2goWzMsIC0xXSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZVtpbmRleF0gPSBbMywgLTFdO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICB0aGlzLl9ub3Rlc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoZSBjaG9yZCB3aXRoIGEgZmxhdCAzcmRcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBjaG9yZCA9IG5ldyBDaG9yZCgpO1xyXG4gICAgICAgICogY29uc3QgY29weSA9IGNob3JkLm1pbm9yZWQoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNvcHkudGVtcGxhdGUpOyAvLyBbMSxbMywtMV0sNV1cclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBtaW5vcmVkKCkge1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzLmNvcHkoKS5taW5vcigpO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBjaG9yZCBoYXMgYSBmbGF0IDNyZFxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGNob3JkID0gbmV3IENob3JkKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhjaG9yZC5pc01pbm9yKCkpOyAvLyBmYWxzZVxyXG4gICAgICAgICogY2hvcmQubWlub3IoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNob3JkLmlzTWlub3IoKSk7IC8vIHRydWVcclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBpc01pbm9yKCkge1xyXG4gICAgICAgICAgIGZvciAoY29uc3QgaW50ZXJ2YWwgb2YgdGhpcy5fdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoKGludGVydmFsWzBdID8/IDApID09PSAzICYmIChpbnRlcnZhbFsxXSA/PyAwKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIE11dGF0ZXMgdGhlIGNob3JkIGluIHBsYWNlXHJcbiAgICAgICAgKiBAY2hhaW5hYmxlXHJcbiAgICAgICAgKiBAcmV0dXJucyB0aGUgY2hvcmQgd2l0aCBhIHNoYXJwIDV0aFxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGNob3JkID0gbmV3IENob3JkKCk7XHJcbiAgICAgICAgKiBjaG9yZC5hdWdtZW50KCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhjaG9yZC50ZW1wbGF0ZSk7IC8vIFsxLCAzLCBbNSwgTW9kaWZpZXIuc2hhcnBdXVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGF1Z21lbnQoKSB7XHJcbiAgICAgICAgICAgbGV0IGluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90ZW1wbGF0ZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGVbaV0gPT09IDUpIHtcclxuICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gdGhpcy5fdGVtcGxhdGVbaV07XHJcbiAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGludGVydmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKChpbnRlcnZhbFswXSA/PyAwKSA9PT0gNSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLnB1c2goWzUsIDFdKTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlW2luZGV4XSA9IFs1LCAxXTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgdGhpcy5fbm90ZXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBjaGFpbmFibGVcclxuICAgICAgICAqIEByZXR1cm5zIGEgY29weSBvZiB0aGUgY2hvcmQgd2l0aCBhIHNoYXJwIDV0aFxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGNob3JkID0gbmV3IENob3JkKCk7XHJcbiAgICAgICAgKiBjb25zdCBjb3B5ID0gY2hvcmQuYXVnbWVudGVkKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhjb3B5LnRlbXBsYXRlKTsgLy8gWzEsIDMsIFs1LCBNb2RpZmllci5zaGFycF1dXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgYXVnbWVudGVkKCkge1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzLmNvcHkoKS5hdWdtZW50KCk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGNob3JkIGhhcyBhIHNoYXJwIDV0aFxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGNob3JkID0gbmV3IENob3JkKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhjaG9yZC5pc0F1Z21lbnRlZCgpKTsgLy8gZmFsc2VcclxuICAgICAgICAqIGNob3JkLmF1Z21lbnQoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNob3JkLmlzQXVnbWVudGVkKCkpOyAvLyB0cnVlXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgaXNBdWdtZW50ZWQoKSB7XHJcbiAgICAgICAgICAgZm9yIChjb25zdCBpbnRlcnZhbCBvZiB0aGlzLl90ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnRlcnZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgIGlmICgoaW50ZXJ2YWxbMF0gPz8gMCkgPT09IDUgJiYgKGludGVydmFsWzFdID8/IDApID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBNdXRhdGVzIHRoZSBjaG9yZCBpbiBwbGFjZVxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgdGhlIGNob3JkIHdpdGggYSBmbGF0IDV0aFxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGNob3JkID0gbmV3IENob3JkKCk7XHJcbiAgICAgICAgKiBjaG9yZC5kaW1pbmlzaCgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coY2hvcmQudGVtcGxhdGUpOyAvLyBbMSwgMywgWzUsIE1vZGlmaWVyLmZsYXRdXVxyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIGRpbWluaXNoKCkge1xyXG4gICAgICAgICAgIGxldCBpbmRleCA9IC0xO1xyXG4gICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGVtcGxhdGUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlW2ldID09PSA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHRoaXMuX3RlbXBsYXRlW2ldO1xyXG4gICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnRlcnZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgIGlmICgoaW50ZXJ2YWxbMF0gPz8gMCkgPT09IDUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZS5wdXNoKFs1LCAtMV0pO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGVbaW5kZXhdID0gWzUsIC0xXTtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgdGhpcy5fbm90ZXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEBjaGFpbmFibGVcclxuICAgICAgICAqIEByZXR1cm5zIGEgY29weSBvZiB0aGUgY2hvcmQgd2l0aCBhIGZsYXQgNXRoXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3QgY2hvcmQgPSBuZXcgQ2hvcmQoKTtcclxuICAgICAgICAqIGNvbnN0IGNvcHkgPSBjaG9yZC5kaW1pbmlzaGVkKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhjb3B5LnRlbXBsYXRlKTsgLy8gWzEsIDMsIFs1LCBNb2RpZmllci5mbGF0XV1cclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBkaW1pbmlzaGVkKCkge1xyXG4gICAgICAgICAgIHJldHVybiB0aGlzLmNvcHkoKS5kaW1pbmlzaCgpO1xyXG4gICAgICAgfVxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBjaG9yZCBoYXMgYSBmbGF0IDV0aFxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGNob3JkID0gbmV3IENob3JkKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhjaG9yZC5pc0RpbWluaXNoZWQoKSk7IC8vIGZhbHNlXHJcbiAgICAgICAgKiBjaG9yZC5kaW1pbmlzaCgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coY2hvcmQuaXNEaW1pbmlzaGVkKCkpOyAvLyB0cnVlXHJcbiAgICAgICAgKiBgYGBcclxuICAgICAgICAqL1xyXG4gICAgICAgaXNEaW1pbmlzaGVkKCkge1xyXG4gICAgICAgICAgIGZvciAoY29uc3QgaW50ZXJ2YWwgb2YgdGhpcy5fdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoKGludGVydmFsWzBdID8/IDApID09PSA1ICYmIChpbnRlcnZhbFsxXSA/PyAwKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIE11dGF0ZXMgdGhlIGNob3JkIGluIHBsYWNlXHJcbiAgICAgICAgKiBAY2hhaW5hYmxlXHJcbiAgICAgICAgKiBAcmV0dXJucyB0aGUgY2hvcmQgd2l0aCBhIGZsYXQgMyw1LCBhbmQgN3RoXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3QgY2hvcmQgPSBuZXcgQ2hvcmQoKTtcclxuICAgICAgICAqIGNob3JkLmhhbGZEaW1pbmlzaCgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coY2hvcmQudGVtcGxhdGUpOyAvLyBbMSwgWzMsIE1vZGlmaWVyLmZsYXRdLCBbNSwgTW9kaWZpZXIuZmxhdF0sIFs3LCBNb2RpZmllci5mbGF0XV1cclxuICAgICAgICAqXHJcbiAgICAgICAgKi9cclxuICAgICAgIGhhbGZEaW1pbmlzaCgpIHtcclxuICAgICAgICAgICB0aGlzLm1pbm9yKCk7IC8vIGdldCBmbGF0IDNyZFxyXG4gICAgICAgICAgIHRoaXMuZGltaW5pc2goKTsgLy8gZ2V0IGZsYXQgNXRoXHJcbiAgICAgICAgICAgbGV0IGluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90ZW1wbGF0ZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGVbaV0gPT09IDcpIHtcclxuICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gdGhpcy5fdGVtcGxhdGVbaV07XHJcbiAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGludGVydmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgaWYgKChpbnRlcnZhbFswXSA/PyAwKSA9PT0gNykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLnB1c2goWzcsIC0xXSk7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZVtpbmRleF0gPSBbNywgLTFdO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICB0aGlzLl9ub3Rlc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoZSBjaG9yZCB3aXRoIGEgZmxhdCAzLDUsIGFuZCA3dGhcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBjaG9yZCA9IG5ldyBDaG9yZCgpO1xyXG4gICAgICAgICogY29uc3QgY29weSA9IGNob3JkLmhhbGZEaW1pbmlzaGVkKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhjb3B5LnRlbXBsYXRlKTsgLy8gWzEsIDMsIFs1LCBNb2RpZmllci5mbGF0XSwgWzcsIE1vZGlmaWVyLmZsYXRdXVxyXG4gICAgICAgICovXHJcbiAgICAgICBoYWxmRGltaW5pc2hlZCgpIHtcclxuICAgICAgICAgICByZXR1cm4gdGhpcy5jb3B5KCkuaGFsZkRpbWluaXNoKCk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGNob3JkIGhhcyBhIGZsYXQgMyw1LCBhbmQgN3RoXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3QgY2hvcmQgPSBuZXcgQ2hvcmQoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNob3JkLmlzSGFsZkRpbWluaXNoZWQoKSk7IC8vIGZhbHNlXHJcbiAgICAgICAgKiBjaG9yZC5oYWxmRGltaW5pc2goKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNob3JkLmlzSGFsZkRpbWluaXNoZWQoKSk7IC8vIHRydWVcclxuICAgICAgICAqL1xyXG4gICAgICAgaXNIYWxmRGltaW5pc2hlZCgpIHtcclxuICAgICAgICAgICBsZXQgdGhpcmQgPSBmYWxzZTtcclxuICAgICAgICAgICBsZXQgZmlmdGggPSBmYWxzZTtcclxuICAgICAgICAgICBsZXQgc2V2ZW50aCA9IGZhbHNlO1xyXG4gICAgICAgICAgIGZvciAoY29uc3QgaW50ZXJ2YWwgb2YgdGhpcy5fdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICBpZiAoKGludGVydmFsWzBdID8/IDApID09PSA3ICYmIChpbnRlcnZhbFsxXSA/PyAwKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICBzZXZlbnRoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChpbnRlcnZhbFswXSA/PyAwKSA9PT0gNSAmJiAoaW50ZXJ2YWxbMV0gPz8gMCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgZmlmdGggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKGludGVydmFsWzBdID8/IDApID09PSAzICYmIChpbnRlcnZhbFsxXSA/PyAwKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB0aGlyZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgcmV0dXJuIHRoaXJkICYmIGZpZnRoICYmIHNldmVudGg7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIE11dGF0ZXMgdGhlIGNob3JkIGluIHBsYWNlXHJcbiAgICAgICAgKiBAY2hhaW5hYmxlXHJcbiAgICAgICAgKiBAcmV0dXJucyB0aGUgY2hvcmQgd2l0aCB3aXRoIHRoZSBmaXJzdCBub3RlIG1vdmVkIHRvIHRoZSBlbmQgdXAgb25lIG9jdGF2ZVxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGBgYGphdmFzY3JpcHRcclxuICAgICAgICAqIGNvbnN0IGNob3JkID0gbmV3IENob3JkKCk7XHJcbiAgICAgICAgKiBjb25zb2xlLmxvZyhjaG9yZC50ZW1wbGF0ZSk7IC8vIFsxLDMsNV1cclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNob3JkLmdldE5vdGVOYW1lcygpKTsgLy8gWydDNCcsICdFNCcsICdHNCddXHJcbiAgICAgICAgKiBjaG9yZC5pbnZlcnQoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNob3JkLnRlbXBsYXRlKTsgLy8gWzMsNSwxXVxyXG4gICAgICAgICogY29uc29sZS5sb2coY2hvcmQuZ2V0Tm90ZU5hbWVzKCkpOyAvLyBbJ0U0JywgJ0c0JywgJ0M1J11cclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBpbnZlcnQoKSB7XHJcbiAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5fdGVtcGxhdGVbMF0pO1xyXG4gICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX3RlbXBsYXRlWzBdKSkge1xyXG4gICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZVswXVswXSArPSB0aGlzLl9iYXNlU2NhbGUudGVtcGxhdGUubGVuZ3RoO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGVbMF0gKz0gdGhpcy5fYmFzZVNjYWxlLnRlbXBsYXRlLmxlbmd0aDtcclxuICAgICAgICAgICB9XHJcbiAgICAgICAgICAgY29uc3QgbmV3VGVtcGxhdGUgPSBzaGlmdCh0aGlzLl90ZW1wbGF0ZSwgdGhpcy5fdGVtcGxhdGUubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBuZXdUZW1wbGF0ZTtcclxuICAgICAgICAgICB0aGlzLl9ub3Rlc0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgIH1cclxuICAgICAgIC8qKlxyXG4gICAgICAgICogQGNoYWluYWJsZVxyXG4gICAgICAgICogQHJldHVybnMgYSBjb3B5IG9mIHRoZSBjaG9yZCB3aXRoIHdpdGggdGhlIGZpcnN0IG5vdGUgbW92ZWQgdG8gdGhlIGVuZCB1cCBvbmUgb2N0YXZlXHJcbiAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICogYGBgamF2YXNjcmlwdFxyXG4gICAgICAgICogY29uc3QgY2hvcmQgPSBuZXcgQ2hvcmQoKTtcclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNob3JkLnRlbXBsYXRlKTsgLy8gWzEsMyw1XVxyXG4gICAgICAgICogY29uc29sZS5sb2coY2hvcmQuZ2V0Tm90ZU5hbWVzKCkpOyAvLyBbJ0M0JywgJ0U0JywgJ0c0J11cclxuICAgICAgICAqIGNvbnN0IGNvcHkgPSBjaG9yZC5pbnZlcnRlZCgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coY29weS50ZW1wbGF0ZSk7IC8vIFszLDUsMV1cclxuICAgICAgICAqIGNvbnNvbGUubG9nKGNvcHkuZ2V0Tm90ZU5hbWVzKCkpOyAvLyBbJ0U0JywgJ0c0JywgJ0M1J11cclxuICAgICAgICAqIGBgYFxyXG4gICAgICAgICovXHJcbiAgICAgICBpbnZlcnRlZCgpIHtcclxuICAgICAgICAgICByZXR1cm4gdGhpcy5jb3B5KCkuaW52ZXJ0KCk7XHJcbiAgICAgICB9XHJcbiAgICAgICAvKipcclxuICAgICAgICAqIEByZXR1cm5zIHRoZSBzdHJpbmcgZm9ybSBvZiB0aGUgY2hvcmRcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBgYGBqYXZhc2NyaXB0XHJcbiAgICAgICAgKiBjb25zdCBjaG9yZCA9IG5ldyBDaG9yZCgpO1xyXG4gICAgICAgICogY29uc29sZS5sb2coY2hvcmQudG9TdHJpbmcoKSk7IC8vICcoQzQpbWFqJ1xyXG4gICAgICAgICogYGBgXHJcbiAgICAgICAgKi9cclxuICAgICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhDaG9yZFRlbXBsYXRlcyk7XHJcbiAgICAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhDaG9yZFRlbXBsYXRlcykubWFwKCh0ZW1wbGF0ZSkgPT4gSlNPTi5zdHJpbmdpZnkodGVtcGxhdGUpKTtcclxuICAgICAgICAgICBjb25zdCBpbmRleCA9IHZhbHVlcy5pbmRleE9mKEpTT04uc3RyaW5naWZ5KHRoaXMuX3RlbXBsYXRlKSk7XHJcbiAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYCgke1NlbWl0b25lJDFbdGhpcy5fcm9vdF19JHt0aGlzLl9vY3RhdmV9KWA7XHJcbiAgICAgICAgICAgY29uc3Qgc3RyID0gaW5kZXggPiAtMSA/IHByZWZpeCArIGtleXNbaW5kZXhdIDogdGhpcy5nZXROb3RlTmFtZXMoKS5qb2luKFwiLFwiKTtcclxuICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgfVxyXG4gICB9XG5cbiAgIC8qKlxyXG4gICAgKiBCdWlsZHMgbG9va3VwIHRhYmxlcyBmb3IgbW9yZSBwZXJmb3JtYW50IHN0cmluZyBwYXJzaW5nLjxici8+XHJcbiAgICAqIFNob3VsZCBvbmx5KG9wdGlvbmFsbHkpIGJlIGNhbGxlZCBvbmNlIHNvb24gYWZ0ZXIgdGhlIGxpYnJhcnkgaXMgbG9hZGVkIGFuZDxici8+XHJcbiAgICAqIG9ubHkgaWYgeW91IGFyZSB1c2luZyBzdHJpbmcgaW5pdGlhbGl6ZXJzLlxyXG4gICAgKi9cclxuICAgY29uc3QgYnVpbGRUYWJsZXMgPSAoKSA9PiB7XHJcbiAgICAgICBidWlsZE5vdGVUYWJsZSgpO1xyXG4gICAgICAgYnVpbGROb3RlU3RyaW5nVGFibGUoKTtcclxuICAgICAgIGJ1aWxkU2NhbGVUYWJsZSgpO1xyXG4gICAgICAgYnVpbGRTY2FsZU5vdGVUYWJsZSgpO1xyXG4gICAgICAgYnVpbGRTY2FsZU5hbWVUYWJsZSgpO1xyXG4gICAgICAgYnVpbGRDaG9yZFRhYmxlKCk7XHJcbiAgIH07XG5cbiAgIGV4cG9ydHMuQ2hvcmQgPSBDaG9yZDtcbiAgIGV4cG9ydHMuQ2hvcmRUZW1wbGF0ZXMgPSBDaG9yZFRlbXBsYXRlcztcbiAgIGV4cG9ydHMuSW5zdHJ1bWVudCA9IEluc3RydW1lbnQ7XG4gICBleHBvcnRzLk1vZGlmaWVyID0gTW9kaWZpZXIkMTtcbiAgIGV4cG9ydHMuTm90ZSA9IE5vdGU7XG4gICBleHBvcnRzLlNjYWxlID0gU2NhbGU7XG4gICBleHBvcnRzLlNjYWxlVGVtcGxhdGVzID0gU2NhbGVUZW1wbGF0ZXM7XG4gICBleHBvcnRzLlNlbWl0b25lID0gU2VtaXRvbmUkMTtcbiAgIGV4cG9ydHMuYnVpbGRUYWJsZXMgPSBidWlsZFRhYmxlcztcblxuICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiaW1wb3J0IHsgTm90ZSwgU2NhbGUsIFNjYWxlVGVtcGxhdGVzIH0gZnJvbSBcIm11c2ljdGhlb3J5anNcIlxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4vbXlsb2dnZXJcIjtcbmltcG9ydCB7IEJFQVRfTEVOR1RILCBEaXZpc2lvbmVkUmljaG5vdGVzLCBNdXNpY1BhcmFtcyB9IGZyb20gXCIuL3V0aWxzXCJcblxuXG50eXBlIExpZ2h0U2NhbGUgPSB7XG4gICAga2V5OiBudW1iZXIsXG4gICAgdGVtcGxhdGVTbHVnOiBzdHJpbmcsXG4gICAgc2VtaXRvbmVzOiBudW1iZXJbXSxcbn07XG5cblxuY29uc3Qgc2NhbGVzRm9yTm90ZXMgPSAobm90ZXM6IE5vdGVbXSwgcGFyYW1zOiBNdXNpY1BhcmFtcyk6IFNjYWxlW10gPT4ge1xuICAgIGNvbnN0IHNjYWxlcyA9IG5ldyBTZXQ8TGlnaHRTY2FsZT4oKVxuICAgIC8vIEZpcnN0IGFkZCBhbGwgc2NhbGVzXG4gICAgZm9yIChjb25zdCBzY2FsZVNsdWcgaW4gcGFyYW1zLnNjYWxlU2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBwYXJhbXMuc2NhbGVTZXR0aW5nc1tzY2FsZVNsdWddO1xuICAgICAgICBpZiAodGVtcGxhdGUuZW5hYmxlZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgc2VtaXRvbmU9MDsgc2VtaXRvbmUgPCAxMjsgc2VtaXRvbmUrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gbmV3IFNjYWxlKHtrZXk6IHNlbWl0b25lLCB0ZW1wbGF0ZTogU2NhbGVUZW1wbGF0ZXNbc2NhbGVTbHVnXX0pXG4gICAgICAgICAgICAgICAgc2NhbGVzLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogc2VtaXRvbmUsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlU2x1Zzogc2NhbGVTbHVnLFxuICAgICAgICAgICAgICAgICAgICBzZW1pdG9uZXM6IHNjYWxlLm5vdGVzLm1hcChub3RlID0+IG5vdGUuc2VtaXRvbmUpLFxuICAgICAgICAgICAgICAgIH0gYXMgTGlnaHRTY2FsZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBub3RlIG9mIG5vdGVzKSB7XG4gICAgICAgIGNvbnN0IHNlbWl0b25lID0gbm90ZS5zZW1pdG9uZVxuICAgICAgICBmb3IgKGNvbnN0IHNjYWxlIG9mIHNjYWxlcykge1xuICAgICAgICAgICAgaWYgKCFzY2FsZS5zZW1pdG9uZXMuaW5jbHVkZXMoc2VtaXRvbmUpKSB7XG4gICAgICAgICAgICAgICAgc2NhbGVzLmRlbGV0ZShzY2FsZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2NhbGUgb2Ygc2NhbGVzKSB7XG4gICAgICAgIHJldC5wdXNoKG5ldyBTY2FsZSh7a2V5OiBzY2FsZS5rZXksIHRlbXBsYXRlOiBTY2FsZVRlbXBsYXRlc1tzY2FsZS50ZW1wbGF0ZVNsdWddfSkpXG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblxuZXhwb3J0IGNvbnN0IGdldEF2YWlsYWJsZVNjYWxlcyA9ICh2YWx1ZXM6IHtcbiAgICBsYXRlc3REaXZpc2lvbjogbnVtYmVyLFxuICAgIGRpdmlzaW9uZWRSaWNoTm90ZXM6IERpdmlzaW9uZWRSaWNobm90ZXMsXG4gICAgcGFyYW1zOiBNdXNpY1BhcmFtcyxcbiAgICByYW5kb21Ob3RlczogQXJyYXk8Tm90ZT4sXG4gICAgbG9nZ2VyOiBMb2dnZXIsXG59KTogQXJyYXk8e1xuICAgIHNjYWxlOiBTY2FsZSxcbiAgICB0ZW5zaW9uOiBudW1iZXIsXG59PiA9PiB7XG4gICAgY29uc3Qge2xhdGVzdERpdmlzaW9uLCBkaXZpc2lvbmVkUmljaE5vdGVzLCBwYXJhbXMsIHJhbmRvbU5vdGVzLCBsb2dnZXJ9ID0gdmFsdWVzO1xuICAgIC8vIEdpdmVuIGEgbmV3IGNob3JkLCBmaW5kIGF2YWlsYWJsZSBzY2FsZXMgYmFzZSBvbiB0aGUgcHJldmlvdXMgbm90ZXNcbiAgICBjb25zdCBjdXJyZW50QXZhaWxhYmxlU2NhbGVzID0gc2NhbGVzRm9yTm90ZXMocmFuZG9tTm90ZXMsIHBhcmFtcylcblxuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2NhbGUgb2YgY3VycmVudEF2YWlsYWJsZVNjYWxlcykge1xuICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICAgIHRlbnNpb246IDAsXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgbG9nZ2VyLmxvZyhcImN1cnJlbnRBdmFpbGFibGVTY2FsZXNcIiwgY3VycmVudEF2YWlsYWJsZVNjYWxlcylcblxuICAgIC8vIEdvIGJhY2sgYSBmZXcgY2hvcmRzIGFuZCBmaW5kIHRoZSBzY2FsZXMgdGhhdCBhcmUgYXZhaWxhYmxlLlxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRpdmlzaW9uID0gbGF0ZXN0RGl2aXNpb24gLSAoaSAqIEJFQVRfTEVOR1RIKVxuICAgICAgICBpZiAoIWRpdmlzaW9uZWRSaWNoTm90ZXNbZGl2aXNpb25dKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3RlcyA9IGRpdmlzaW9uZWRSaWNoTm90ZXNbZGl2aXNpb25dLm1hcChyaWNoTm90ZSA9PiByaWNoTm90ZS5ub3RlKVxuICAgICAgICBjb25zdCBhdmFpbGFibGVTY2FsZXMgPSBzY2FsZXNGb3JOb3Rlcyhub3RlcywgcGFyYW1zKVxuICAgICAgICBmb3IgKGNvbnN0IHBvdGVudGlhbFNjYWxlIG9mIHJldCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhdmFpbGFibGVTY2FsZXMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS5lcXVhbHMocG90ZW50aWFsU2NhbGUuc2NhbGUpKVxuICAgICAgICAgICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgd2Fzbid0IGF2YWlsYWJsZSwgaW5jcmVhc2UgdGVuc2lvblxuICAgICAgICAgICAgICAgIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsU2NhbGUudGVuc2lvbiArPSAyMCAgLy8gQmFzZSBvZiBob3cgbG9uZyBhZ28gaXQgd2FzXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsU2NhbGUudGVuc2lvbiArPSAxMFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbFNjYWxlLnRlbnNpb24gKz0gNVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbFNjYWxlLnRlbnNpb24gKz0gMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiU2NhbGUgXCIsIHBvdGVudGlhbFNjYWxlLnNjYWxlLnRvU3RyaW5nKCksXCIgd2Fzbid0IGF2YWlsYWJsZSBhdCBkaXZpc2lvbiBcIiwgZGl2aXNpb24sIFwiLCBpbmNyZWFzZSB0ZW5zaW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxvZ2dlci5wcmludChcIkF2YWlsYWJsZSBzY2FsZXNcIiwgcmV0KVxuXG4gICAgcmV0dXJuIHJldC5maWx0ZXIoaXRlbSA9PiBpdGVtLnRlbnNpb24gPCAyMCk7XG59IiwiaW1wb3J0IHtcbiAgICBidWlsZFRhYmxlcyxcbiAgICBTY2FsZSwgICAgXG4gICAgTm90ZSxcbn0gZnJvbSBcIm11c2ljdGhlb3J5anNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuL215bG9nZ2VyXCI7XG5pbXBvcnQgeyBDaG9yZCwgTnVsbGFibGUsIERpdmlzaW9uZWRSaWNobm90ZXMsIFJpY2hOb3RlLCBCRUFUX0xFTkdUSCwgTWFpbk11c2ljUGFyYW1zIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IFJhbmRvbUNob3JkR2VuZXJhdG9yIH0gZnJvbSBcIi4vcmFuZG9tY2hvcmRzXCI7XG5pbXBvcnQgeyBnZXRJbnZlcnNpb25zIH0gZnJvbSBcIi4vaW52ZXJzaW9uc1wiO1xuaW1wb3J0IHsgZ2V0VGVuc2lvbiB9IGZyb20gXCIuL3RlbnNpb25cIjtcbmltcG9ydCB7IGJ1aWxkVG9wTWVsb2R5IH0gZnJvbSBcIi4vdG9wbWVsb2R5XCI7XG5pbXBvcnQgeyBhZGRIYWxmTm90ZXMgfSBmcm9tIFwiLi9oYWxmbm90ZXNcIjtcbmltcG9ydCB7IGdldEF2YWlsYWJsZVNjYWxlcyB9IGZyb20gXCIuL2F2YWlsYWJsZXNjYWxlc1wiO1xuXG5cbmNvbnN0IHNsZWVwTVMgPSBhc3luYyAobXM6IG51bWJlcik6IFByb21pc2U8bnVsbD4gPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cblxuY29uc3QgbWFrZUNob3JkcyA9IGFzeW5jIChtYWluUGFyYW1zOiBNYWluTXVzaWNQYXJhbXMsIHByb2dyZXNzQ2FsbGJhY2s6IE51bGxhYmxlPEZ1bmN0aW9uPiA9IG51bGwpOiBQcm9taXNlPERpdmlzaW9uZWRSaWNobm90ZXM+ID0+IHtcbiAgICAvLyBnZW5lcmF0ZSBhIHByb2dyZXNzaW9uXG5cbiAgICBjb25zdCBiZWF0c1BlckJhciA9IG1haW5QYXJhbXMuYmVhdHNQZXJCYXIgfHwgNDtcblxuICAgIGNvbnN0IG1heEJlYXRzID0gbWFpblBhcmFtcy5nZXRNYXhCZWF0cygpO1xuICAgIC8vbGV0IGN1cnJlbnRTY2FsZSA9IG5ldyBTY2FsZSh7IGtleTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTIpICwgb2N0YXZlOiA1LCB0ZW1wbGF0ZTogU2NhbGVUZW1wbGF0ZXNbcGFyYW1zLnNjYWxlVGVtcGxhdGVdfSk7XG4gICAgbGV0IGN1cnJlbnRTY2FsZSA9IG5ldyBTY2FsZSh7IGtleTogMCwgb2N0YXZlOiA1IH0pO1xuXG4gICAgbGV0IHJlc3VsdDogRGl2aXNpb25lZFJpY2hub3RlcyA9IHt9O1xuICAgIGxldCB0ZW5zaW9uczogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgIGxldCBwcmV2Q2hvcmQgPSBudWxsO1xuICAgIGxldCBwcmV2SW52ZXJzaW9uTmFtZTogTnVsbGFibGU8c3RyaW5nPiA9IG51bGw7XG4gICAgY29uc3QgcHJldk5vdGVzOiBBcnJheTxOb3RlPiA9IFtdO1xuICAgIGNvbnN0IHByZXZNZWxvZHk6IE5vdGVbXSA9IFtdO1xuXG4gICAgLy8gZm9yIChsZXQgaT0wOyBpPG1heFRlbnNpb25zOyBpKyspIHtcbiAgICAvLyAgICAgLy8gdGVuc2lvbkJlYXRzLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heEJlYXRzIC0gMTApKSArIDYpO1xuICAgIC8vIH1cblxuICAgIGZvciAobGV0IGRpdmlzaW9uID0gMDsgZGl2aXNpb24gPCBtYXhCZWF0cyAqIEJFQVRfTEVOR1RIOyBkaXZpc2lvbiArPSBCRUFUX0xFTkdUSCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBtYWluUGFyYW1zLmN1cnJlbnRDYWRlbmNlUGFyYW1zKGRpdmlzaW9uKTtcbiAgICAgICAgY29uc3QgYmVhdHNVbnRpbExhc3RDaG9yZEluQ2FkZW5jZSA9IHBhcmFtcy5iZWF0c1VudGlsQ2FkZW5jZUVuZDtcbiAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcImRpdmlzaW9uXCIsIGRpdmlzaW9uLCBwcmV2Q2hvcmQgPyBwcmV2Q2hvcmQudG9TdHJpbmcoKSA6IFwibnVsbFwiLCBcIiBzY2FsZSBcIiwgY3VycmVudFNjYWxlLnRvU3RyaW5nKCkpO1xuICAgICAgICBjb25zdCBjdXJyZW50QmVhdCA9IE1hdGguZmxvb3IoZGl2aXNpb24gLyBCRUFUX0xFTkdUSCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiYmVhdHNVbnRpbExhc3RDaG9yZEluQ2FkZW5jZVwiLCBiZWF0c1VudGlsTGFzdENob3JkSW5DYWRlbmNlKTtcblxuICAgICAgICBjb25zdCBiZWF0U2V0dGluZyA9IHBhcmFtcy5iZWF0U2V0dGluZ3NbY3VycmVudEJlYXRdO1xuICAgICAgICBsZXQgdGVuc2lvbk92ZXJyaWRlID0gbnVsbDtcbiAgICAgICAgaWYgKGJlYXRTZXR0aW5nKSB7XG4gICAgICAgICAgICB0ZW5zaW9uT3ZlcnJpZGUgPSBwYXJzZUZsb2F0KGJlYXRTZXR0aW5nLnRlbnNpb24gYXMgdW5rbm93biBhcyBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVuc2lvbk92ZXJyaWRlID0gcGFyYW1zLmJhc2VUZW5zaW9uO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaG9yZElzR29vZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCByYW5kb21HZW5lcmF0b3IgPSBuZXcgUmFuZG9tQ2hvcmRHZW5lcmF0b3IocGFyYW1zLCBjdXJyZW50U2NhbGUpXG4gICAgICAgIGxldCBuZXdDaG9yZDogTnVsbGFibGU8Q2hvcmQ+ID0gbnVsbDtcbiAgICAgICAgbGV0IHRlbnNpb24gPSAwO1xuICAgICAgICBsZXQgbmV3U2NhbGU6IE51bGxhYmxlPFNjYWxlPiA9IG51bGw7XG4gICAgICAgIGxldCBvbGROZXdTY2FsZTogTnVsbGFibGU8U2NhbGU+ID0gbnVsbDtcblxuICAgICAgICBjb25zdCByYW5kb21Ob3RlczogQXJyYXk8Tm90ZT4gPSBbXTtcblxuICAgICAgICBsZXQgaXRlcmF0aW9ucyA9IDA7XG4gICAgICAgIGxldCBiZXN0UmVzdWx0OiB7XG4gICAgICAgICAgICBub3RlczogQXJyYXk8Tm90ZT4sXG4gICAgICAgICAgICB0ZW5zaW9uOiBudW1iZXIsXG4gICAgICAgICAgICBzY2FsZTogU2NhbGUsXG4gICAgICAgICAgICBjaG9yZDogTnVsbGFibGU8Q2hvcmQ+LFxuICAgICAgICB9ID0ge1xuICAgICAgICAgICAgbm90ZXM6IFtdLFxuICAgICAgICAgICAgdGVuc2lvbjogOTk5LFxuICAgICAgICAgICAgc2NhbGU6IGN1cnJlbnRTY2FsZSxcbiAgICAgICAgICAgIGNob3JkOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBjbG9zZXN0VGVuc2lvbiA9IC0xMDA7XG4gICAgICAgIGxldCB3YW50ZWRUZW5zaW9uID0gMDtcbiAgICAgICAgbGV0IGdvQmFjayA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlICghY2hvcmRJc0dvb2QpIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICAgIGlmIChpdGVyYXRpb25zICUgMTAwKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgc2xlZXBNUygxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZXJhdGlvbnMgPiAxMDAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJUb28gbWFueSBpdGVyYXRpb25zLCBicmVha2luZywgY2xvc2VzdFRlbnNpb246IFwiLCBjbG9zZXN0VGVuc2lvbik7XG4gICAgICAgICAgICAgICAgZ29CYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjcml0ZXJpYUxldmVsID0gTWF0aC5mbG9vcihpdGVyYXRpb25zIC8gKDUwKSk7XG4gICAgICAgICAgICBpZiAoaXRlcmF0aW9ucyAlIDEwMCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHByZXZpb3VzIGNob3JkcyBhZ2FpbiB3aXRoIGRpZmZlcmVudCBjcml0ZXJpYUxldmVsLi4uXG4gICAgICAgICAgICAgICAgcmFuZG9tR2VuZXJhdG9yLmNsZWFuVXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0Nob3JkID0gcmFuZG9tR2VuZXJhdG9yLmdldENob3JkKCk7XG4gICAgICAgICAgICBjb25zdCBjaG9yZExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcbiAgICAgICAgICAgIGxldCBhbGxJbnZlcnNpb25zO1xuICAgICAgICAgICAgbGV0IGF2YWlsYWJsZVNjYWxlcztcblxuICAgICAgICAgICAgaWYgKGJlYXRzVW50aWxMYXN0Q2hvcmRJbkNhZGVuY2UgPT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEZvcmNlIHNhbWUgY2hvcmQgdHdpY2VcbiAgICAgICAgICAgICAgICBjaG9yZElzR29vZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmFuZG9tTm90ZXMuc3BsaWNlKDAsIHJhbmRvbU5vdGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmFuZG9tTm90ZXMucHVzaCguLi5wcmV2Tm90ZXMpO1xuICAgICAgICAgICAgICAgIG5ld0Nob3JkID0gcHJldkNob3JkO1xuICAgICAgICAgICAgICAgIHRlbnNpb24gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIW5ld0Nob3JkKSB7XG4gICAgICAgICAgICAgICAgY2hvcmRMb2dnZXIubG9nKFwiRmFpbGVkIHRvIGdldCBhIG5ldyBjaG9yZCAoYWxsIHVzZWQpIFVzaW5nIHRoZSBiZXN0IHJlc3VsdFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoYmVzdFJlc3VsdC50ZW5zaW9uIDwgMTAgfHwgZGl2aXNpb24gPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJCZXN0IHJlc3VsdCBpcyBnb29kIGVub3VnaCwgdXNpbmcgaXRcIik7XG4gICAgICAgICAgICAgICAgICAgIGNob3JkSXNHb29kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tTm90ZXMuc3BsaWNlKDAsIHJhbmRvbU5vdGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmRvbU5vdGVzLnB1c2goLi4uYmVzdFJlc3VsdC5ub3Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Nob3JkID0gYmVzdFJlc3VsdC5jaG9yZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2Q2hvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZDaG9yZCA9IG5ld0Nob3JkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRlbnNpb24gPSBiZXN0UmVzdWx0LnRlbnNpb247XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkJlc3QgcmVzdWx0IGlzIG5vdCBnb29kIGVub3VnaCwgZ29pbmcgYmFja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gR28gYmFjayB0byBwcmV2aW91cyBjaG9yZCwgYW5kIG1ha2UgaXQgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgY2hvcmRJc0dvb2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZ29CYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdmFpbGFibGVTY2FsZUxvZ2dlciA9IG5ldyBMb2dnZXIoY2hvcmRMb2dnZXIpXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlU2NhbGVzID0gZ2V0QXZhaWxhYmxlU2NhbGVzKHtcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0RGl2aXNpb246IGRpdmlzaW9uLFxuICAgICAgICAgICAgICAgICAgICBkaXZpc2lvbmVkUmljaE5vdGVzOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICByYW5kb21Ob3RlczogbmV3Q2hvcmQubm90ZXMsXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcjogYXZhaWxhYmxlU2NhbGVMb2dnZXIsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBpZiAocHJldk1lbG9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhCZWF0cyAtIGN1cnJlbnRCZWF0IDwgMyB8fCBiZWF0c1VudGlsTGFzdENob3JkSW5DYWRlbmNlIDwgMyB8fCBjdXJyZW50QmVhdCA8IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFsbG93IG90aGVyIHNjYWxlcyB0aGFuIHRoZSBjdXJyZW50IG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlU2NhbGVzID0gYXZhaWxhYmxlU2NhbGVzLmZpbHRlcihzID0+IHMuc2NhbGUuZXF1YWxzKGN1cnJlbnRTY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGVTY2FsZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFsbEludmVyc2lvbnMgPSBnZXRJbnZlcnNpb25zKG5ld0Nob3JkLCBwcmV2Tm90ZXMsIGN1cnJlbnRCZWF0LCBwYXJhbXMsIG5ldyBMb2dnZXIoY2hvcmRMb2dnZXIpLCBtYXhCZWF0cyAtIGN1cnJlbnRCZWF0KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNob3JkSXNHb29kKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGludmVyc2lvblJlc3VsdCBvZiBhbGxJbnZlcnNpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNob3JkSXNHb29kKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpbnZlcnNpb25Mb2dnZXIgPSBuZXcgTG9nZ2VyKGNob3JkTG9nZ2VyKTtcbiAgICAgICAgICAgICAgICBpbnZlcnNpb25Mb2dnZXIudGl0bGUgPSBbXCJJbnZlcnNpb24gXCIsIGAke2ludmVyc2lvblJlc3VsdC5pbnZlcnNpb25OYW1lfWBdO1xuICAgICAgICAgICAgICAgIHJhbmRvbU5vdGVzLnNwbGljZSgwLCByYW5kb21Ob3Rlcy5sZW5ndGgpOyAgLy8gRW1wdHkgdGhpcyBhbmQgcmVwbGFjZSBjb250ZW50c1xuICAgICAgICAgICAgICAgIHJhbmRvbU5vdGVzLnB1c2goLi4uaW52ZXJzaW9uUmVzdWx0Lm5vdGVzKTtcbiAgICAgICAgICAgICAgICBsZXQgYmVzdFRlbnNpb24gPSA5OTk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhdmFpbGFibGVTY2FsZSBvZiBhdmFpbGFibGVTY2FsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVMb2dnZXIgPSBuZXcgTG9nZ2VyKGludmVyc2lvbkxvZ2dlcilcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hvcmRUZW5zaW9uTG9nZ2VyID0gbmV3IExvZ2dlcihzY2FsZUxvZ2dlcik7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlTG9nZ2VyLnRpdGxlID0gW1wiU2NhbGUgXCIsIGAke2F2YWlsYWJsZVNjYWxlLnNjYWxlLnRvU3RyaW5nKCl9YF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaG9yZElzR29vZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVuc2lvblJlc3VsdCA9IGdldFRlbnNpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kb21Ob3RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZVNjYWxlLnNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmVhdHNVbnRpbExhc3RDaG9yZEluQ2FkZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNob3JkVGVuc2lvbkxvZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEJlYXRzIC0gY3VycmVudEJlYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZlcnNpb25SZXN1bHQuaW52ZXJzaW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZJbnZlcnNpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjaG9yZFRlbnNpb25Mb2dnZXIudGl0bGUgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q2hvcmQgPyBwcmV2Q2hvcmQudG9TdHJpbmcoKSA6IFwiXCIsIFwiIC0+IFwiLCBuZXdDaG9yZC50b1N0cmluZygpLCBcIjogXCIsIHRlbnNpb25SZXN1bHQudGVuc2lvblxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hvcmQgaW4gcGFyYW1zLmNob3JkU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNob3JkU2V0dGluZyA9IHBhcmFtcy5jaG9yZFNldHRpbmdzW2Nob3JkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNob3JkV2VpZ2h0ID0gcGFyc2VGbG9hdChgJHtjaG9yZFNldHRpbmcud2VpZ2h0fWAgfHwgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdDaG9yZC5jaG9yZFR5cGUgPT0gY2hvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uUmVzdWx0LnRlbnNpb24gLT0gKChjaG9yZFdlaWdodCAqIDEwKSAqKiAzKSAvIDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNob3JkVGVuc2lvbkxvZ2dlci5sb2coXCJDaG9yZCBcIiwgY2hvcmQsIFwiIHdlaWdodDogXCIsIGNob3JkV2VpZ2h0LCBcIiB0ZW5zaW9uOiBcIiwgdGVuc2lvblJlc3VsdC50ZW5zaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uUmVzdWx0LnRlbnNpb24gKz0gYXZhaWxhYmxlU2NhbGUudGVuc2lvbiAvIE1hdGgubWF4KDAuMDEsIHBhcmFtcy5tb2R1bGF0aW9uV2VpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY2hvcmRUZW5zaW9uTG9nZ2VyLmxvZyhcIlNjYWxlIHRlbnNpb246IFwiLCB0ZW5zaW9uUmVzdWx0LnRlbnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldk1lbG9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWF2YWlsYWJsZVNjYWxlLnNjYWxlLmVxdWFscyhjdXJyZW50U2NhbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVuc2lvblJlc3VsdC50ZW5zaW9uICs9IDEgLyBNYXRoLm1heCgwLjAxLCBwYXJhbXMubW9kdWxhdGlvbldlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hvcmRUZW5zaW9uTG9nZ2VyLmxvZyhcIlNjYWxlIGNoYW5nZSB0ZW5zaW9uOiBcIiwgdGVuc2lvblJlc3VsdC50ZW5zaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4QmVhdHMgLSBjdXJyZW50QmVhdCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGFzdCAyIGJhcnMsIGRvbid0IGNoYW5nZSBzY2FsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uUmVzdWx0LnRlbnNpb24gKz0gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmVhdHNVbnRpbExhc3RDaG9yZEluQ2FkZW5jZSA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY2hhbmdlIHNjYWxlIGluIGxhc3QgMiBiZWF0cyBvZiBjYWRlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNpb25SZXN1bHQudGVuc2lvbiArPSAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QmVhdCA8IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY2hhbmdlIHNjYWxlIGluIGZpcnN0IDUgYmVhdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVuc2lvblJlc3VsdC50ZW5zaW9uICs9IDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGVuc2lvbiA9IHRlbnNpb25SZXN1bHQudGVuc2lvbjtcblxuICAgICAgICAgICAgICAgICAgICB3YW50ZWRUZW5zaW9uID0gMC40O1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAodGVuc2lvbkJlYXRzLmluY2x1ZGVzKGN1cnJlbnRCZWF0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgd2FudGVkVGVuc2lvbiA9IGhpZ2hUZW5zaW9uO1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhCZWF0cyAtIGN1cnJlbnRCZWF0IDwgNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluYWwgYmFyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YW50ZWRUZW5zaW9uID0gLTAuNVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWF0c1VudGlsTGFzdENob3JkSW5DYWRlbmNlIDwgMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FudGVkVGVuc2lvbiA9IC0wLjc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YW50ZWRUZW5zaW9uICs9ICgwLjEgKiBjcml0ZXJpYUxldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW5zaW9uT3ZlcnJpZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FudGVkVGVuc2lvbiA9IHBhcnNlRmxvYXQodGVuc2lvbk92ZXJyaWRlIGFzIGFueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YW50ZWRUZW5zaW9uICs9ICgwLjEgKiBjcml0ZXJpYUxldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW5zaW9uIDwgYmVzdFRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RUZW5zaW9uID0gdGVuc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW5zaW9uIDwgd2FudGVkVGVuc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hvcmRJc0dvb2QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NhbGUgPSBhdmFpbGFibGVTY2FsZS5zY2FsZS5jb3B5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaG9yZFRlbnNpb25Mb2dnZXIubG9nKFwiQ2hvcmQgaXMgZ29vZDogXCIsIHRlbnNpb24sIFwiIHdhbnRlZDogXCIsIHdhbnRlZFRlbnNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkludmVyc2lvbk5hbWUgPSBpbnZlcnNpb25SZXN1bHQuaW52ZXJzaW9uTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgLy8gU2tpcCBjaGVja2luZyBvdGhlciB2b2ljZSBsZWFkaW5nIGludmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW5zaW9uIDwgYmVzdFJlc3VsdC50ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdFJlc3VsdC50ZW5zaW9uID0gdGVuc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0UmVzdWx0Lm5vdGVzLnNwbGljZSgwLCBiZXN0UmVzdWx0Lm5vdGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdFJlc3VsdC5ub3Rlcy5wdXNoKC4uLnJhbmRvbU5vdGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0UmVzdWx0LmNob3JkID0gbmV3Q2hvcmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaG9yZFRlbnNpb25Mb2dnZXIubG9nKFwiQ2hvcmQgaXMgYmFkOiBcIiwgdGVuc2lvbiwgXCIgd2FudGVkOiBcIiwgd2FudGVkVGVuc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModGVuc2lvbiAtIHdhbnRlZFRlbnNpb24pIDwgTWF0aC5hYnMoY2xvc2VzdFRlbnNpb24gLSB3YW50ZWRUZW5zaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RUZW5zaW9uID0gdGVuc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2l2ZVVQID0gcHJvZ3Jlc3NDYWxsYmFjayhudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2l2ZVVQKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZHVjZSBjYWRlbmNlIGNvdW50IHRvIGZpeCBlcnJvcnMgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFyYW1zLmNhZGVuY2VDb3VudCA9IE1hdGguZmxvb3IoKGN1cnJlbnRCZWF0IC8gKGJhcnNQZXJDYWRlbmNlRW5kICogYmVhdHNQZXJCYXIpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlTG9nZ2VyLnRpdGxlLnB1c2goXCJ0ZW5zaW9uOiBcIik7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlTG9nZ2VyLnRpdGxlLnB1c2goYCR7dGVuc2lvbn1gKTtcbiAgICAgICAgICAgICAgICB9ICAvLyBGb3IgYXZhaWxhYmxlIHNjYWxlcyBlbmRcbiAgICAgICAgICAgICAgICBpbnZlcnNpb25Mb2dnZXIudGl0bGUucHVzaChcInRlbnNpb246IFwiKTtcbiAgICAgICAgICAgICAgICBpbnZlcnNpb25Mb2dnZXIudGl0bGUucHVzaChgJHtiZXN0VGVuc2lvbn1gKTtcbiAgICAgICAgICAgICAgICBpbnZlcnNpb25Mb2dnZXIucHJpbnQoKTtcbiAgICAgICAgICAgIH0gIC8vIEZvciB2b2ljZWxlYWRpbmcgcmVzdWx0cyBlbmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNob3JkTG9nZ2VyLnByaW50KHByZXZDaG9yZCA/IHByZXZDaG9yZC50b1N0cmluZygpIDogXCJcIiwgXCIgLT4gXCIsIG5ld0Nob3JkLnRvU3RyaW5nKCksIFwiOiBcIiwgdGVuc2lvbi50b0ZpeGVkKDEpLCBcIiAoXCIgKyB3YW50ZWRUZW5zaW9uICsgXCIpXCIpO1xuICAgICAgICB9ICAvLyBXaGlsZSBlbmRcbiAgICAgICAgaWYgKGdvQmFjaykge1xuICAgICAgICAgICAgLy8gR28gYmFjayB0byBwcmV2aW91cyBjaG9yZCwgYW5kIG1ha2UgaXQgYWdhaW5cbiAgICAgICAgICAgIGlmIChkaXZpc2lvbiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZGl2aXNpb24gLT0gQkVBVF9MRU5HVEggKiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0Nob3JkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICB0ZW5zaW9ucy5wdXNoKHRlbnNpb24pO1xuICAgICAgICBjb25zdCBuZXdDaG9yZFN0cmluZyA9IG5ld0Nob3JkLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChuZXdTY2FsZSkge1xuICAgICAgICAgICAgY3VycmVudFNjYWxlID0gbmV3U2NhbGU7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwibmV3IHNjYWxlOiBcIiwgY3VycmVudFNjYWxlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTY2FsZSkge1xuICAgICAgICAgICAgb2xkTmV3U2NhbGUgPSBuZXdTY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2TWVsb2R5LnB1c2gocmFuZG9tTm90ZXNbMF0pO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGAke2JlYXRzVW50aWxMYXN0Q2hvcmRJbkNhZGVuY2V9OiAke3RlbnNpb24udG9GaXhlZCgxKX0gLSAke25ld0Nob3JkU3RyaW5nfSAoJHtjdXJyZW50U2NhbGUudG9TdHJpbmcoKX0pYCk7XG4gICAgICAgIHJlc3VsdFtjdXJyZW50QmVhdCAqIEJFQVRfTEVOR1RIXSA9IHJhbmRvbU5vdGVzLm1hcCgobm90ZSwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICBub3RlOiBub3RlLFxuICAgICAgICAgICAgcGFydEluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBCRUFUX0xFTkdUSCxcbiAgICAgICAgICAgIGNob3JkOiBuZXdDaG9yZCxcbiAgICAgICAgICAgIHNjYWxlOiBjdXJyZW50U2NhbGUsXG4gICAgICAgICAgICB0ZW5zaW9uOiB0ZW5zaW9uLFxuICAgICAgICAgICAgaW52ZXJzaW9uTmFtZTogYCR7cHJldkludmVyc2lvbk5hbWV9YCxcbiAgICAgICAgfSkgYXMgUmljaE5vdGUpO1xuXG4gICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGN1cnJlbnRCZWF0LCByZXN1bHRbY3VycmVudEJlYXQgKiBCRUFUX0xFTkdUSF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkNob3JkID0gbmV3Q2hvcmQ7XG5cbiAgICAgICAgcHJldk5vdGVzLnNwbGljZSgwLCBwcmV2Tm90ZXMubGVuZ3RoKTtcbiAgICAgICAgcHJldk5vdGVzLnB1c2goLi4ucmFuZG9tTm90ZXMpO1xuXG4gICAgICAgIHJhbmRvbUdlbmVyYXRvci5jbGVhblVwKCk7XG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYWtlTXVzaWMocGFyYW1zOiBNYWluTXVzaWNQYXJhbXMsIHByb2dyZXNzQ2FsbGJhY2s6IE51bGxhYmxlPEZ1bmN0aW9uPiA9IG51bGwpIHtcbiAgICBsZXQgZGl2aXNpb25lZE5vdGVzOiBEaXZpc2lvbmVkUmljaG5vdGVzID0ge307XG4gICAgbGV0IGl0ZXJhdGlvbnMgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgaWYgKGl0ZXJhdGlvbnMgPiA1KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRvbyBtYW55IGl0ZXJhdGlvbnMsIGJyZWFraW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXZpc2lvbmVkTm90ZXM6IHt9LFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpdmlzaW9uZWROb3RlcyA9IGF3YWl0IG1ha2VDaG9yZHMocGFyYW1zLCBwcm9ncmVzc0NhbGxiYWNrKTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRpdmlzaW9uZWROb3RlcykubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgIH1cblxuICAgIC8vIGNvbnN0IGRpdmlzaW9uZWROb3RlczogRGl2aXNpb25lZFJpY2hub3RlcyA9IG5ld1ZvaWNlTGVhZGluZ05vdGVzKGNob3JkcywgcGFyYW1zKTtcbiAgICBidWlsZFRvcE1lbG9keShkaXZpc2lvbmVkTm90ZXMsIHBhcmFtcyk7XG4gICAgLy8gYWRkRWlnaHRoTm90ZXMoZGl2aXNpb25lZE5vdGVzLCBwYXJhbXMpXG4gICAgYWRkSGFsZk5vdGVzKGRpdmlzaW9uZWROb3RlcywgcGFyYW1zKVxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkaXZpc2lvbmVkTm90ZXM6IGRpdmlzaW9uZWROb3RlcyxcbiAgICB9XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VNZWxvZHkoZGl2aXNpb25lZE5vdGVzOiBEaXZpc2lvbmVkUmljaG5vdGVzLCBtYWluUGFyYW1zOiBNYWluTXVzaWNQYXJhbXMpIHtcbiAgICAvLyBSZW1vdmUgb2xkIG1lbG9keSBhbmQgbWFrZSBhIG5ldyBvbmVcbiAgICBjb25zdCBtYXhCZWF0cyA9IG1haW5QYXJhbXMuZ2V0TWF4QmVhdHMoKVxuXG4gICAgZm9yIChsZXQgZGl2aXNpb249MDsgZGl2aXNpb24gPCBtYXhCZWF0cyAqIEJFQVRfTEVOR1RIOyBkaXZpc2lvbisrKSB7XG4gICAgICAgIGNvbnN0IG9uQmVhdCA9IGRpdmlzaW9uICUgQkVBVF9MRU5HVEggPT0gMDtcbiAgICAgICAgaWYgKCFvbkJlYXQpIHtcbiAgICAgICAgICAgIGRpdmlzaW9uZWROb3Rlc1tkaXZpc2lvbl0gPSBbXVxuICAgICAgICB9IGVsc2UgaWYgKGRpdmlzaW9uZWROb3Rlc1tkaXZpc2lvbl0gJiYgZGl2aXNpb25lZE5vdGVzW2RpdmlzaW9uXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkaXZpc2lvbmVkTm90ZXNbZGl2aXNpb25dLmZvckVhY2gocmljaE5vdGUgPT4ge1xuICAgICAgICAgICAgICAgIHJpY2hOb3RlLmR1cmF0aW9uID0gQkVBVF9MRU5HVEg7XG4gICAgICAgICAgICAgICAgcmljaE5vdGUudGllID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gY29uc3QgZGl2aXNpb25lZE5vdGVzOiBEaXZpc2lvbmVkUmljaG5vdGVzID0gbmV3Vm9pY2VMZWFkaW5nTm90ZXMoY2hvcmRzLCBwYXJhbXMpO1xuICAgIGJ1aWxkVG9wTWVsb2R5KGRpdmlzaW9uZWROb3RlcywgbWFpblBhcmFtcyk7XG4gICAgLy8gYWRkRWlnaHRoTm90ZXMoZGl2aXNpb25lZE5vdGVzLCBwYXJhbXMpXG4gICAgYWRkSGFsZk5vdGVzKGRpdmlzaW9uZWROb3RlcywgbWFpblBhcmFtcylcbn1cblxuLy8gZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRlc3RGdW5jKHBhcmFtczogTXVzaWNQYXJhbXMpIHtcbi8vICAgICBjb25zb2xlLmxvZyhwYXJhbXMpXG4vLyAgICAgbGV0IGNob3JkczogQXJyYXk8QXJyYXk8UmljaE5vdGU+PiA9IFtdO1xuXG4vLyAgICAgY2hvcmRzID0gbW9vbmxpZ2h0c29uYXRhXG4vLyAgICAgICAgIC5tYXAoKG5vdGVOYW1lcykgPT4gKFxuLy8gICAgICAgICAgICAgbm90ZU5hbWVzLm1hcChcbi8vICAgICAgICAgICAgICAgICAobm90ZU5hbWUpID0+ICh7XG4vLyAgICAgICAgICAgICAgICAgICAgIG5vdGU6IG5ldyBOb3RlKG5vdGVOYW1lKSxcbi8vICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IEJFQVRfTEVOR1RILFxuLy8gICAgICAgICAgICAgICAgIH0pIGFzIFJpY2hOb3RlXG4vLyAgICAgICAgICAgICApXG4vLyAgICAgICAgICkpO1xuXG4vLyAgICAgY29uc3QgZGl2aXNpb25lZE5vdGVzOiBEaXZpc2lvbmVkUmljaG5vdGVzID0ge307XG5cbi8vICAgICAvLyBMb3dlciBhbGwgc2VtaXRvbmVzIGJ5IDRcbi8vICAgICBjaG9yZHMuZm9yRWFjaChyaWNoTm90ZUxpc3QgPT4gcmljaE5vdGVMaXN0LmZvckVhY2gocmljaE5vdGUgPT4ge1xuLy8gICAgICAgICBjb25zdCBnVG9uZSA9IGdsb2JhbFNlbWl0b25lKHJpY2hOb3RlLm5vdGUpIC0gNDtcbi8vICAgICAgICAgcmljaE5vdGUubm90ZS5zZW1pdG9uZSA9IGdUb25lICUgMTI7XG4vLyAgICAgICAgIHJpY2hOb3RlLm5vdGUub2N0YXZlID0gTWF0aC5mbG9vcihnVG9uZSAvIDEyKTtcbi8vICAgICB9KSlcblxuXG4vLyAgICAgbGV0IHByZXZDaG9yZCA9IGNob3Jkc1swXTtcbi8vICAgICBmb3IgKGxldCBpPTA7IGk8Y2hvcmRzLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgIGNvbnN0IGNob3JkID0gY2hvcmRzW2ldO1xuLy8gICAgICAgICBjb25zdCBzY2FsZSA9IG5ldyBTY2FsZSh7a2V5OiAwLCB0ZW1wbGF0ZTogU2NhbGVUZW1wbGF0ZXMubWFqb3J9KTtcbi8vICAgICAgICAgY29uc29sZS5sb2coZ2V0VGVuc2lvbihwcmV2Q2hvcmQubWFwKHJpY2hOb3RlID0+IHJpY2hOb3RlLm5vdGUpLCBjaG9yZC5tYXAocmljaE5vdGUgPT4gcmljaE5vdGUubm90ZSksIHNjYWxlLCAxMCwgcGFyYW1zKSk7XG4vLyAgICAgICAgIHByZXZDaG9yZCA9IGNob3JkO1xuLy8gICAgICAgICBkaXZpc2lvbmVkTm90ZXNbaSAqIEJFQVRfTEVOR1RIXSA9IGNob3JkLm1hcCgobm90ZSwgaW5kZXgpID0+ICh7XG4vLyAgICAgICAgICAgICBub3RlOiBub3RlLm5vdGUsXG4vLyAgICAgICAgICAgICBwYXJ0SW5kZXg6IGluZGV4LFxuLy8gICAgICAgICAgICAgZHVyYXRpb246IEJFQVRfTEVOR1RILFxuLy8gICAgICAgICAgICAgc2NhbGU6IHNjYWxlLFxuLy8gICAgICAgICB9KSBhcyBSaWNoTm90ZSk7XG4vLyAgICAgfVxuXG4vLyAgICAgcmV0dXJuIHtcbi8vICAgICAgICAgY2hvcmRzOiBjaG9yZHMsXG4vLyAgICAgICAgIGRpdmlzaW9uZWROb3RlczogZGl2aXNpb25lZE5vdGVzLFxuLy8gICAgIH1cbi8vIH1cblxuZXhwb3J0IHsgYnVpbGRUYWJsZXMgfSIsImltcG9ydCB7IEJFQVRfTEVOR1RILCBEaXZpc2lvbmVkUmljaG5vdGVzLCBNYWluTXVzaWNQYXJhbXMgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5leHBvcnQgY29uc3QgYWRkSGFsZk5vdGVzID0gKGRpdmlzaW9uZWROb3RlczogRGl2aXNpb25lZFJpY2hub3RlcywgbWFpblBhcmFtczogTWFpbk11c2ljUGFyYW1zKSA9PiB7XG5cbiAgICBjb25zdCBiZWF0c1BlckJhciA9IG1haW5QYXJhbXMuYmVhdHNQZXJCYXIgfHwgNDtcbiAgICBjb25zdCBsYXN0RGl2aXNpb24gPSBtYWluUGFyYW1zLmdldE1heEJlYXRzKCkgKiBCRUFUX0xFTkdUSDtcblxuICAgIGZvciAobGV0IGRpdmlzaW9uID0gMDsgZGl2aXNpb24gPCBsYXN0RGl2aXNpb24gLSBCRUFUX0xFTkdUSDsgZGl2aXNpb24gKz0gQkVBVF9MRU5HVEgpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbWFpblBhcmFtcy5jdXJyZW50Q2FkZW5jZVBhcmFtcyhkaXZpc2lvbik7XG4gICAgICAgIGNvbnN0IGxhc3RCZWF0ID0gTWF0aC5mbG9vcihkaXZpc2lvbiAvIEJFQVRfTEVOR1RIKSAqIEJFQVRfTEVOR1RIO1xuICAgICAgICBsZXQgYmVhdHNVbnRpbExhc3RDaG9yZEluQ2FkZW5jZSA9IHBhcmFtcy5iZWF0c1VudGlsQ2FkZW5jZUVuZDtcbiAgICAgICAgbGV0IGNhZGVuY2VFbmRpbmcgPSBiZWF0c1VudGlsTGFzdENob3JkSW5DYWRlbmNlIDwgMlxuICAgICAgICBpZiAocGFyYW1zLmhhbGZOb3RlcyAmJiAhY2FkZW5jZUVuZGluZykge1xuICAgICAgICAgICAgLy8gQWRkIGEgdGllIHN0YXJ0IHRvIHRoZSBwcmV2aW91cyBub3RlIHRvIGRvdWJsZSBsZW5ndGgsIGFuZCB0aWUgc3RvcCB0byB0aGlzXG4gICAgICAgICAgICAvLyBpZiBpdCdzIGNvbnRpbnVpbmcgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNOb3RlcyA9IGRpdmlzaW9uZWROb3Rlc1tkaXZpc2lvbiAtIDEyXSB8fCBbXTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROb3RlcyA9IGRpdmlzaW9uZWROb3Rlc1tkaXZpc2lvbl0gfHwgW107XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8NDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNOb3RlID0gcHJldmlvdXNOb3Rlcy5maWx0ZXIoKG4pID0+IG4ucGFydEluZGV4ID09IGkpWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROb3RlID0gY3VycmVudE5vdGVzLmZpbHRlcigobikgPT4gbi5wYXJ0SW5kZXggPT0gaSlbMF07XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzTm90ZSAmJiBjdXJyZW50Tm90ZSAmJiBwcmV2aW91c05vdGUubm90ZS5lcXVhbHMoY3VycmVudE5vdGUubm90ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzTm90ZS5kdXJhdGlvbiAhPSBCRUFUX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb3RlLmR1cmF0aW9uICE9IEJFQVRfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNOb3RlLnRpZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c05vdGUudGllID0gXCJzdGFydFwiO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm90ZS50aWUgPSBcInN0b3BcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInByZXZpb3VzTm90ZXM6IFwiLCBwcmV2aW91c05vdGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IE5vdGUgfSBmcm9tIFwibXVzaWN0aGVvcnlqc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4vbXlsb2dnZXJcIjtcbmltcG9ydCB7IENob3JkLCBnbG9iYWxTZW1pdG9uZSwgTXVzaWNQYXJhbXMsIHNlbWl0b25lRGlzdGFuY2UgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5leHBvcnQgdHlwZSBJbnZlcnNpb25SZXN1bHQgPSB7XG4gICAgZ1RvbmVEaWZmczogQXJyYXk8QXJyYXk8bnVtYmVyPj4sXG4gICAgbm90ZXM6IHtba2V5OiBudW1iZXJdOiBOb3RlfSxcbiAgICByYXRpbmc6IG51bWJlcixcbiAgICBpbnZlcnNpb25OYW1lOiBzdHJpbmcsXG59XG5cbmV4cG9ydCB0eXBlIFNpbXBsZUludmVyc2lvblJlc3VsdCA9IHtcbiAgICBub3RlczogQXJyYXk8Tm90ZT4sXG4gICAgcmF0aW5nOiBudW1iZXIsXG4gICAgaW52ZXJzaW9uTmFtZTogc3RyaW5nLFxufVxuXG5leHBvcnQgY29uc3QgZ2V0SW52ZXJzaW9ucyA9IChjaG9yZDogQ2hvcmQsIHByZXZOb3RlczogQXJyYXk8Tm90ZT4sIGJlYXQ6IG51bWJlciwgcGFyYW1zOiBNdXNpY1BhcmFtcywgbG9nZ2VyOiBMb2dnZXIsIGJlYXRzVW50aWxMYXN0Q2hvcmRJblNvbmc6IG51bWJlcik6IEFycmF5PFNpbXBsZUludmVyc2lvblJlc3VsdD4gPT4ge1xuICAgIC8vIFJldHVybiBOb3RlcyBpbiB0aGUgQ2hvcmQgdGhhdCBhcmUgY2xvc2VzdCB0byB0aGUgcHJldmlvdXMgbm90ZXNcbiAgICAvLyBGb3IgZWFjaCBwYXJ0XG5cbiAgICBjb25zdCBwMU5vdGUgPSBwYXJhbXMucGFydHNbMF0ubm90ZSB8fCBcIkY0XCI7XG4gICAgY29uc3QgcDJOb3RlID0gcGFyYW1zLnBhcnRzWzFdLm5vdGUgfHwgXCJDNFwiO1xuICAgIGNvbnN0IHAzTm90ZSA9IHBhcmFtcy5wYXJ0c1syXS5ub3RlIHx8IFwiQTNcIjtcbiAgICBjb25zdCBwNE5vdGUgPSBwYXJhbXMucGFydHNbM10ubm90ZSB8fCBcIkMzXCI7XG5cbiAgICBjb25zdCBzdGFydGluZ0dsb2JhbFNlbWl0b25lcyA9IFtcbiAgICAgICAgZ2xvYmFsU2VtaXRvbmUobmV3IE5vdGUocDFOb3RlKSksXG4gICAgICAgIGdsb2JhbFNlbWl0b25lKG5ldyBOb3RlKHAyTm90ZSkpLFxuICAgICAgICBnbG9iYWxTZW1pdG9uZShuZXcgTm90ZShwM05vdGUpKSxcbiAgICAgICAgZ2xvYmFsU2VtaXRvbmUobmV3IE5vdGUocDROb3RlKSksXG4gICAgXVxuXG4gICAgY29uc3Qgc2VtaXRvbmVMaW1pdHMgPSBbXG4gICAgICAgIFtzdGFydGluZ0dsb2JhbFNlbWl0b25lc1swXSArIC0xMiwgc3RhcnRpbmdHbG9iYWxTZW1pdG9uZXNbMF0gKyAxMiAtIDVdLFxuICAgICAgICBbc3RhcnRpbmdHbG9iYWxTZW1pdG9uZXNbMV0gKyAtMTIsIHN0YXJ0aW5nR2xvYmFsU2VtaXRvbmVzWzFdICsgMTIgLSA1XSxcbiAgICAgICAgW3N0YXJ0aW5nR2xvYmFsU2VtaXRvbmVzWzJdICsgLTEyLCBzdGFydGluZ0dsb2JhbFNlbWl0b25lc1syXSArIDEyIC0gNV0sXG4gICAgICAgIFtzdGFydGluZ0dsb2JhbFNlbWl0b25lc1szXSArIC0xMiwgc3RhcnRpbmdHbG9iYWxTZW1pdG9uZXNbM10gKyAxMiAtIDVdLFxuICAgIF1cbiAgICBsb2dnZXIubG9nKHNlbWl0b25lTGltaXRzKVxuXG4gICAgLy8gQWRkIGEgcmVzdWx0IGZvciBlYWNoIHBvc3NpYmxlIGludmVyc2lvblxuICAgIGNvbnN0IHJldDogQXJyYXk8U2ltcGxlSW52ZXJzaW9uUmVzdWx0PiA9IFtdO1xuXG4gICAgbGV0IGxhc3RCZWF0R2xvYmFsU2VtaXRvbmVzID0gWy4uLnN0YXJ0aW5nR2xvYmFsU2VtaXRvbmVzXVxuICAgIGlmIChwcmV2Tm90ZXMpIHtcbiAgICAgICAgbGFzdEJlYXRHbG9iYWxTZW1pdG9uZXMgPSBwcmV2Tm90ZXMubWFwKG5vdGUgPT4gZ2xvYmFsU2VtaXRvbmUobm90ZSkpO1xuICAgIH1cblxuICAgIGlmICghY2hvcmQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmIChjaG9yZCkge1xuICAgICAgICAvLyBGb3IgZWFjaCBiZWF0LCB3ZSB0cnkgdG8gZmluZCBhIGdvb2QgbWF0Y2hpbmcgc2VtaXRvbmUgZm9yIGVhY2ggcGFydC5cblxuICAgICAgICAvLyBSdWxlczpcbiAgICAgICAgLy8gV2l0aFx0cm9vdCBwb3NpdGlvbiB0cmlhZHM6IGRvdWJsZSB0aGUgcm9vdC4gXG5cbiAgICAgICAgLy8gV2l0aCBmaXJzdCBpbnZlcnNpb24gdHJpYWRzOiBkb3VibGUgdGhlIHJvb3Qgb3IgNXRoLCBpbiBnZW5lcmFsLiBJZiBvbmUgbmVlZHMgdG8gZG91YmxlIFxuICAgICAgICAvLyB0aGUgM3JkLCB0aGF0IGlzIGFjY2VwdGFibGUsIGJ1dCBhdm9pZCBkb3VibGluZyB0aGUgbGVhZGluZyB0b25lLlxuXG4gICAgICAgIC8vIFdpdGggc2Vjb25kIGludmVyc2lvbiB0cmlhZHM6IGRvdWJsZSB0aGUgZmlmdGguIFxuXG4gICAgICAgIC8vIFdpdGggIHNldmVudGggIGNob3JkczogIHRoZXJlICBpcyAgb25lIHZvaWNlICBmb3IgIGVhY2ggIG5vdGUsICBzbyAgZGlzdHJpYnV0ZSBhcyAgZml0cy4gSWYgIG9uZSBcbiAgICAgICAgLy8gbXVzdCBvbWl0IGEgbm90ZSBmcm9tIHRoZSBjaG9yZCwgdGhlbiBvbWl0IHRoZSA1dGguXG5cbiAgICAgICAgY29uc3QgZmlyc3RJbnRlcnZhbCA9IHNlbWl0b25lRGlzdGFuY2UoY2hvcmQubm90ZXNbMF0uc2VtaXRvbmUsIGNob3JkLm5vdGVzWzFdLnNlbWl0b25lKVxuICAgICAgICBjb25zdCB0aGlyZElzR29vZCA9IGZpcnN0SW50ZXJ2YWwgPT0gMyB8fCBmaXJzdEludGVydmFsID09IDQ7XG4gICAgICAgIGxvZ2dlci5sb2coXCJub3RlczogXCIsIGNob3JkLm5vdGVzLm1hcChuID0+IG4udG9TdHJpbmcoKSkpO1xuXG4gICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgaW52ZXJzaW9uIGFuZCBjaG9yZCB0eXBlLCB3ZSdyZSBkb2luZyBkaWZmZXJlbnQgdGhpbmdzXG5cbiAgICAgICAgbGV0IGludmVyc2lvbk5hbWVzID0gW1wicm9vdFwiLCBcImZpcnN0LXJvb3RcIiwgXCJmaXJzdC10aGlyZFwiLCBcImZpcnN0LWZpZnRoXCIsIFwic2Vjb25kXCJdO1xuICAgICAgICBsZXQgY29tYmluYXRpb25Db3VudCA9IDMgKiAyICogMTtcbiAgICAgICAgaWYgKGNob3JkLm5vdGVzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIGludmVyc2lvbk5hbWVzID0gW1wicm9vdFwiLCBcImZpcnN0XCIsIFwic2Vjb25kXCIsIFwidGhpcmRcIl07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBza2lwRmlmdGhJbmRleCA9IDA7IHNraXBGaWZ0aEluZGV4IDwgMjsgc2tpcEZpZnRoSW5kZXgrKykge1xuICAgICAgICBmb3IgKGxldCBpbnZlcnNpb25JbmRleD0wOyBpbnZlcnNpb25JbmRleDxpbnZlcnNpb25OYW1lcy5sZW5ndGg7IGludmVyc2lvbkluZGV4KyspIHtcbiAgICAgICAgZm9yIChsZXQgY29tYmluYXRpb25JbmRleD0wOyBjb21iaW5hdGlvbkluZGV4PGNvbWJpbmF0aW9uQ291bnQ7IGNvbWJpbmF0aW9uSW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3Qgc2tpcEZpZnRoID0gc2tpcEZpZnRoSW5kZXggPT0gMTtcblxuICAgICAgICAgICAgLy8gV2UgdHJ5IGVhY2ggaW52ZXJzaW9uLiBXaGljaCBpcyBiZXN0P1xuICAgICAgICAgICAgY29uc3QgaW52ZXJzaW9uID0gaW52ZXJzaW9uTmFtZXNbaW52ZXJzaW9uSW5kZXhdO1xuICAgICAgICAgICAgaWYgKGJlYXRzVW50aWxMYXN0Q2hvcmRJblNvbmcgPCAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnZlcnNpb24uc3RhcnRzV2l0aCgncm9vdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBEb24ndCBkbyBhbnl0aGluZyBidXQgcm9vdCBwb3NpdGlvbiBvbiB0aGUgbGFzdCBjaG9yZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaW52ZXJzaW9uUmVzdWx0OiBJbnZlcnNpb25SZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgZ1RvbmVEaWZmczogW10sXG4gICAgICAgICAgICAgICAgbm90ZXM6IHt9LFxuICAgICAgICAgICAgICAgIHJhdGluZzogMCxcbiAgICAgICAgICAgICAgICBpbnZlcnNpb25OYW1lOiBpbnZlcnNpb25OYW1lc1tpbnZlcnNpb25JbmRleF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHNraXBGaWZ0aCkge1xuICAgICAgICAgICAgICAgIGludmVyc2lvblJlc3VsdC5pbnZlcnNpb25OYW1lICs9IFwiLXNraXBGaWZ0aFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhZGRQYXJ0Tm90ZSA9IChwYXJ0SW5kZXg6IG51bWJlciwgbm90ZTogTm90ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGludmVyc2lvblJlc3VsdC5ub3Rlc1twYXJ0SW5kZXhdID0gbmV3IE5vdGUoe1xuICAgICAgICAgICAgICAgICAgICBzZW1pdG9uZTogbm90ZS5zZW1pdG9uZSxcbiAgICAgICAgICAgICAgICAgICAgb2N0YXZlOiAxICAvLyBkdW1teVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiaW52ZXJzaW9uOiBcIiwgaW52ZXJzaW9uLCBcInNraXBGaWZ0aDogXCIsIHNraXBGaWZ0aCk7XG4gICAgICAgICAgICBsZXQgcGFydFRvSW5kZXg6IHsgW2tleTogbnVtYmVyXTogbnVtYmVyIH0gPSB7fTtcblxuICAgICAgICAgICAgLy8gRmlyc3Qgc2VsZWN0IGJvdHRvbSBub3RlXG4gICAgICAgICAgICBpZiAoaW52ZXJzaW9uLnN0YXJ0c1dpdGgoJ3Jvb3QnKSkge1xuICAgICAgICAgICAgICAgIHBhcnRUb0luZGV4WzNdID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW52ZXJzaW9uLnN0YXJ0c1dpdGgoJ2ZpcnN0JykpIHtcbiAgICAgICAgICAgICAgICBwYXJ0VG9JbmRleFszXSA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGludmVyc2lvbi5zdGFydHNXaXRoKCdzZWNvbmQnKSkge1xuICAgICAgICAgICAgICAgIHBhcnRUb0luZGV4WzNdID0gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW52ZXJzaW9uLnN0YXJ0c1dpdGgoJ3RoaXJkJykpIHtcbiAgICAgICAgICAgICAgICBwYXJ0VG9JbmRleFszXSA9IDM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExpc3Qgbm90ZXMgd2UgaGF2ZSBsZWZ0IG92ZXJcbiAgICAgICAgICAgIGxldCBsZWZ0T3ZlckluZGV4ZXM6IG51bWJlcltdID0gW107XG4gICAgICAgICAgICBpZiAoY2hvcmQubm90ZXMubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW52ZXJzaW9uID09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRPdmVySW5kZXhlcyA9IFswLCAxLCAyXTsgIC8vIERvdWJsZSB0aGUgcm9vdFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW52ZXJzaW9uID09IFwiZmlyc3Qtcm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IC0+IFdlIGFscmVhZHkgaGF2ZSAxXG4gICAgICAgICAgICAgICAgICAgIGxlZnRPdmVySW5kZXhlcyA9IFswLCAwLCAyXTsgIC8vIERvdWJsZSB0aGUgcm9vdFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW52ZXJzaW9uID09IFwiZmlyc3QtdGhpcmRcIikge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0T3ZlckluZGV4ZXMgPSBbMCwgMSwgMl07ICAvLyBEb3VibGUgdGhlIHRoaXJkXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnZlcnNpb24gPT0gXCJmaXJzdC1maWZ0aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRPdmVySW5kZXhlcyA9IFswLCAyLCAyXTsgIC8vIERvdWJsZSB0aGUgZmlmdGhcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGludmVyc2lvbiA9PSBcInNlY29uZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlY29uZCAtPiBXZSBhbHJlYWR5IGhhdmUgMlxuICAgICAgICAgICAgICAgICAgICBsZWZ0T3ZlckluZGV4ZXMgPSBbMCwgMCwgMV07ICAvLyBEb3VibGUgdGhlIHJvb3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNob3JkLm5vdGVzLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgICAgICAgICAgbGVmdE92ZXJJbmRleGVzID0gWzAsIDEsIDIsIDNdLmZpbHRlcihpID0+IGkgIT0gcGFydFRvSW5kZXhbM10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2tpcEZpZnRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRUb0luZGV4WzNdID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuJ3Qgc2tpcCBmaWZ0aCBpbiBzZWNvbmQgaW52ZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVmdE92ZXJJbmRleGVzLmZpbHRlcihpID0+IGkgPT0gMikubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuJ3Qgc2tpcCBmaWZ0aCBpZiB3ZSBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVmdE92ZXJJbmRleGVzID0gbGVmdE92ZXJJbmRleGVzLmZpbHRlcihpID0+IGkgIT0gMik7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGVpdGhlciBhIDAgb3IgMSB0byByZXBsYWNlIHRoZSBmaWZ0aFxuICAgICAgICAgICAgICAgIGlmIChsZWZ0T3ZlckluZGV4ZXMuZmlsdGVyKGkgPT4gaSA9PSAwKS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0T3ZlckluZGV4ZXMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0T3ZlckluZGV4ZXMucHVzaCgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiBjb21iaW5hdGlvbkluZGV4LCB3ZSBzZWxlY3QgdGhlIG5vdGVzIGZvciBwYXJ0SW5kZXhlcyAwLCAxLCAyXG4gICAgICAgICAgICBpZiAoY29tYmluYXRpb25JbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEZpcnN0IHBlcm11dGF0aW9uXG4gICAgICAgICAgICAgICAgcGFydFRvSW5kZXhbMF0gPSBsZWZ0T3ZlckluZGV4ZXNbMF07XG4gICAgICAgICAgICAgICAgcGFydFRvSW5kZXhbMV0gPSBsZWZ0T3ZlckluZGV4ZXNbMV07XG4gICAgICAgICAgICAgICAgcGFydFRvSW5kZXhbMl0gPSBsZWZ0T3ZlckluZGV4ZXNbMl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbWJpbmF0aW9uSW5kZXggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBTZWNvbmQgcGVybXV0YXRpb25cbiAgICAgICAgICAgICAgICBwYXJ0VG9JbmRleFswXSA9IGxlZnRPdmVySW5kZXhlc1swXTtcbiAgICAgICAgICAgICAgICBwYXJ0VG9JbmRleFsxXSA9IGxlZnRPdmVySW5kZXhlc1syXTtcbiAgICAgICAgICAgICAgICBwYXJ0VG9JbmRleFsyXSA9IGxlZnRPdmVySW5kZXhlc1sxXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tYmluYXRpb25JbmRleCA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXJkIHBlcm11dGF0aW9uXG4gICAgICAgICAgICAgICAgcGFydFRvSW5kZXhbMF0gPSBsZWZ0T3ZlckluZGV4ZXNbMV07XG4gICAgICAgICAgICAgICAgcGFydFRvSW5kZXhbMV0gPSBsZWZ0T3ZlckluZGV4ZXNbMF07XG4gICAgICAgICAgICAgICAgcGFydFRvSW5kZXhbMl0gPSBsZWZ0T3ZlckluZGV4ZXNbMl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbWJpbmF0aW9uSW5kZXggPT09IDMpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3VydGggcGVybXV0YXRpb25cbiAgICAgICAgICAgICAgICBwYXJ0VG9JbmRleFswXSA9IGxlZnRPdmVySW5kZXhlc1sxXTtcbiAgICAgICAgICAgICAgICBwYXJ0VG9JbmRleFsxXSA9IGxlZnRPdmVySW5kZXhlc1syXTtcbiAgICAgICAgICAgICAgICBwYXJ0VG9JbmRleFsyXSA9IGxlZnRPdmVySW5kZXhlc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tYmluYXRpb25JbmRleCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIC8vIEZpZnRoIHBlcm11dGF0aW9uXG4gICAgICAgICAgICAgICAgcGFydFRvSW5kZXhbMF0gPSBsZWZ0T3ZlckluZGV4ZXNbMl07XG4gICAgICAgICAgICAgICAgcGFydFRvSW5kZXhbMV0gPSBsZWZ0T3ZlckluZGV4ZXNbMF07XG4gICAgICAgICAgICAgICAgcGFydFRvSW5kZXhbMl0gPSBsZWZ0T3ZlckluZGV4ZXNbMV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbWJpbmF0aW9uSW5kZXggPT09IDUpIHtcbiAgICAgICAgICAgICAgICAvLyBTaXh0aCBwZXJtdXRhdGlvblxuICAgICAgICAgICAgICAgIHBhcnRUb0luZGV4WzBdID0gbGVmdE92ZXJJbmRleGVzWzJdO1xuICAgICAgICAgICAgICAgIHBhcnRUb0luZGV4WzFdID0gbGVmdE92ZXJJbmRleGVzWzFdO1xuICAgICAgICAgICAgICAgIHBhcnRUb0luZGV4WzJdID0gbGVmdE92ZXJJbmRleGVzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0SW5kZXg9MDsgcGFydEluZGV4PDQ7IHBhcnRJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGludmVyc2lvblJlc3VsdC5ub3Rlc1twYXJ0SW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcGFydCBpcyBhbHJlYWR5IHNldFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkUGFydE5vdGUocGFydEluZGV4LCBjaG9yZC5ub3Rlc1twYXJ0VG9JbmRleFtwYXJ0SW5kZXhdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMYXN0bHksIHdlIHNlbGVjdCB0aGUgbG93ZXN0IHBvc3NpYmxlIG9jdGF2ZSBmb3IgZWFjaCBwYXJ0XG4gICAgICAgICAgICBsZXQgbWluU2VtaXRvbmUgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgcGFydEluZGV4PTM7IHBhcnRJbmRleD49MDsgcGFydEluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RlID0gaW52ZXJzaW9uUmVzdWx0Lm5vdGVzW3BhcnRJbmRleF07XG4gICAgICAgICAgICAgICAgbGV0IGdUb25lID0gZ2xvYmFsU2VtaXRvbmUobm90ZSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgaT0wO1xuICAgICAgICAgICAgICAgIHdoaWxlIChnVG9uZSA8IHNlbWl0b25lTGltaXRzW3BhcnRJbmRleF1bMF0gfHwgZ1RvbmUgPCBtaW5TZW1pdG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMTAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIlRvbyBtYW55IGl0ZXJhdGlvbnNcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdUb25lICs9IDEyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnZlcnNpb25SZXN1bHQubm90ZXNbcGFydEluZGV4XSA9IG5ldyBOb3RlKHtcbiAgICAgICAgICAgICAgICAgICAgc2VtaXRvbmU6IGdUb25lICUgMTIsXG4gICAgICAgICAgICAgICAgICAgIG9jdGF2ZTogTWF0aC5mbG9vcihnVG9uZSAvIDEyKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgaW52ZXJzaW9ucmVzdWx0IGZvciBlYWNoIHBvc3NpYmxlIG9jdGF2ZSBjb21iaW5hdGlvblxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFBhcnQwTm90ZSA9IGdsb2JhbFNlbWl0b25lKGludmVyc2lvblJlc3VsdC5ub3Rlc1swXSk7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsUGFydDFOb3RlID0gZ2xvYmFsU2VtaXRvbmUoaW52ZXJzaW9uUmVzdWx0Lm5vdGVzWzFdKTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxQYXJ0Mk5vdGUgPSBnbG9iYWxTZW1pdG9uZShpbnZlcnNpb25SZXN1bHQubm90ZXNbMl0pO1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFBhcnQzTm90ZSA9IGdsb2JhbFNlbWl0b25lKGludmVyc2lvblJlc3VsdC5ub3Rlc1szXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0ME9jdGF2ZT0wOyBwYXJ0ME9jdGF2ZTwzOyBwYXJ0ME9jdGF2ZSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydDBOb3RlID0gaW5pdGlhbFBhcnQwTm90ZSArIHBhcnQwT2N0YXZlICogMTI7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQwTm90ZSA+IHNlbWl0b25lTGltaXRzWzBdWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwYXJ0MU9jdGF2ZT0wOyBwYXJ0MU9jdGF2ZTwzOyBwYXJ0MU9jdGF2ZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnQxTm90ZSA9IGluaXRpYWxQYXJ0MU5vdGUgKyBwYXJ0MU9jdGF2ZSAqIDEyO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydDFOb3RlID4gcGFydDBOb3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydDFOb3RlID4gc2VtaXRvbmVMaW1pdHNbMV1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHBhcnQyT2N0YXZlPTA7IHBhcnQyT2N0YXZlPDM7IHBhcnQyT2N0YXZlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnQyTm90ZSA9IGluaXRpYWxQYXJ0Mk5vdGUgKyBwYXJ0Mk9jdGF2ZSAqIDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQyTm90ZSA+IHBhcnQxTm90ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQyTm90ZSA+IHNlbWl0b25lTGltaXRzWzJdWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwYXJ0M09jdGF2ZT0wOyBwYXJ0M09jdGF2ZTwzOyBwYXJ0M09jdGF2ZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydDNOb3RlID0gaW5pdGlhbFBhcnQzTm90ZSArIHBhcnQzT2N0YXZlICogMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQzTm90ZSA+IHBhcnQyTm90ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQzTm90ZSA+IHNlbWl0b25lTGltaXRzWzNdWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VtaXRvbmU6IHBhcnQwTm90ZSAlIDEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGF2ZTogTWF0aC5mbG9vcihwYXJ0ME5vdGUgLyAxMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW1pdG9uZTogcGFydDFOb3RlICUgMTIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YXZlOiBNYXRoLmZsb29yKHBhcnQxTm90ZSAvIDEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbWl0b25lOiBwYXJ0Mk5vdGUgJSAxMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvY3RhdmU6IE1hdGguZmxvb3IocGFydDJOb3RlIC8gMTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VtaXRvbmU6IHBhcnQzTm90ZSAlIDEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGF2ZTogTWF0aC5mbG9vcihwYXJ0M05vdGUgLyAxMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52ZXJzaW9uTmFtZTogaW52ZXJzaW9uUmVzdWx0LmludmVyc2lvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdGluZzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nZ2VyLnByaW50KFwibmV3Vm9pY2VMZWFkaW5nTm90ZXM6IFwiLCBjaG9yZC50b1N0cmluZygpLCBcIiBiZWF0OiBcIiwgYmVhdCk7XG5cbiAgICAvLyBSYW5kb21pemUgb3JkZXIgb2YgcmV0XG4gICAgZm9yIChsZXQgaT0wOyBpPHJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmV0Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHRtcCA9IHJldFtpXTtcbiAgICAgICAgcmV0W2ldID0gcmV0W2pdO1xuICAgICAgICByZXRbal0gPSB0bXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn1cbiIsImltcG9ydCB7IE5vdGUsIFNjYWxlLCBTY2FsZVRlbXBsYXRlcyB9IGZyb20gJ211c2ljdGhlb3J5anMnO1xuXG5pbXBvcnQgYnVpbGRlciBmcm9tICd4bWxidWlsZGVyJztcbmltcG9ydCB7IERpdmlzaW9uZWRSaWNobm90ZXMsIGdsb2JhbFNlbWl0b25lLCBNYWluTXVzaWNQYXJhbXMsIE11c2ljUGFyYW1zLCBSaWNoTm90ZSB9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBCRUFUX0xFTkdUSCA9IDEyXG5cblxuZnVuY3Rpb24gc2VtaXRvbmVUb1BpdGNoKHNlbWl0b25lOiBudW1iZXIsIHNjYWxlOiBTY2FsZSwgZGlyZWN0aW9uOiBzdHJpbmc9XCJzaGFycFwiKTogeyBub3RlTmFtZTogc3RyaW5nLCBhbHRlcjogbnVtYmVyIH0ge1xuICBmb3IgKGNvbnN0IG5vdGUgb2Ygc2NhbGUubm90ZXMpIHtcbiAgICBpZiAobm90ZS5zZW1pdG9uZSA9PT0gc2VtaXRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vdGVOYW1lOiBub3RlLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDEpLFxuICAgICAgICBhbHRlcjogMCxcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qgbm90ZSBvZiBzY2FsZS5ub3Rlcykge1xuICAgIGlmIChkaXJlY3Rpb24gPT0gXCJmbGF0XCIgJiYgbm90ZS5zZW1pdG9uZSA9PT0gc2VtaXRvbmUgKyAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub3RlTmFtZTogbm90ZS50b1N0cmluZygpLnN1YnN0cmluZygwLCAxKSxcbiAgICAgICAgYWx0ZXI6IC0xLFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PSBcInNoYXJwXCIgJiYgbm90ZS5zZW1pdG9uZSA9PT0gc2VtaXRvbmUgLSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub3RlTmFtZTogbm90ZS50b1N0cmluZygpLnN1YnN0cmluZygwLCAxKSxcbiAgICAgICAgYWx0ZXI6IDEsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBub3RlIGZvciBzZW1pdG9uZSBcIiArIHNlbWl0b25lKTtcbn1cblxuXG5mdW5jdGlvbiByaWNoTm90ZUR1cmF0aW9uKHJpY2hOb3RlOiBSaWNoTm90ZSkge1xuICBjb25zdCBkdXJhdGlvbiA9IHJpY2hOb3RlLmR1cmF0aW9uO1xuICBsZXQgdHlwZTogc3RyaW5nID0gJ3F1YXJ0ZXInO1xuICBpZiAoZHVyYXRpb24gPT09IEJFQVRfTEVOR1RIICogNCkge1xuICAgIHR5cGUgPSAnd2hvbGUnO1xuICB9XG4gIGVsc2UgaWYgKGR1cmF0aW9uID09PSBCRUFUX0xFTkdUSCAqIDIpIHtcbiAgICB0eXBlID0gJ2hhbGYnO1xuICB9XG4gIGVsc2UgaWYgKGR1cmF0aW9uID09PSBCRUFUX0xFTkdUSCkge1xuICAgIHR5cGUgPSAncXVhcnRlcic7XG4gIH1cbiAgZWxzZSBpZiAoZHVyYXRpb24gPT0gQkVBVF9MRU5HVEggLyAyKSB7XG4gICAgdHlwZSA9ICdlaWdodGgnO1xuICB9XG4gIGVsc2UgaWYgKGR1cmF0aW9uID09IEJFQVRfTEVOR1RIIC8gNCkge1xuICAgIHR5cGUgPSAnMTZ0aCc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgICdkdXJhdGlvbic6IGR1cmF0aW9uLFxuICAgICd0eXBlJzogdHlwZSxcbiAgfVxufVxuXG5jb25zdCBmbGF0U2NhbGVTZW1pdG9uZXM6IFNldDxudW1iZXI+ID0gbmV3IFNldChbXG4gIChuZXcgTm90ZSgnRicpKS5zZW1pdG9uZSxcbiAgKG5ldyBOb3RlKCdCYicpKS5zZW1pdG9uZSxcbiAgKG5ldyBOb3RlKCdFYicpKS5zZW1pdG9uZSxcbiAgKG5ldyBOb3RlKCdBYicpKS5zZW1pdG9uZSxcbiAgKG5ldyBOb3RlKCdEYicpKS5zZW1pdG9uZSxcbiAgKG5ldyBOb3RlKCdHYicpKS5zZW1pdG9uZSxcbl0pO1xuXG5mdW5jdGlvbiBub3RlVG9QaXRjaChyaWNoTm90ZTogUmljaE5vdGUpIHtcbiAgY29uc3Qgbm90ZSA9IHJpY2hOb3RlLm5vdGU7XG4gIGNvbnN0IG5vdGVTY2FsZSA9IHJpY2hOb3RlLnNjYWxlO1xuICBjb25zdCBzY29yZVNjYWxlID0gbmV3IFNjYWxlKHtrZXk6IDAsIG9jdGF2ZTogbm90ZS5vY3RhdmUsIHRlbXBsYXRlOiBTY2FsZVRlbXBsYXRlcy5tYWpvcn0pXG4gIGxldCBkaXJlY3Rpb24gPSAnc2hhcnAnO1xuICBpZiAobm90ZVNjYWxlKSB7XG4gICAgY29uc3QgYmFzZSA9IG5vdGVTY2FsZS5ub3Rlc1swXS5zZW1pdG9uZTtcbiAgICBpZiAoZmxhdFNjYWxlU2VtaXRvbmVzLmhhcyhiYXNlKSkge1xuICAgICAgZGlyZWN0aW9uID0gJ2ZsYXQnO1xuICAgIH1cbiAgfVxuICBjb25zdCBwaXRjaCA9IHNlbWl0b25lVG9QaXRjaChub3RlLnNlbWl0b25lLCBzY29yZVNjYWxlLCBkaXJlY3Rpb24pO1xuICByZXR1cm4ge1xuICAgICdzdGVwJzogeyAnI3RleHQnOiBwaXRjaC5ub3RlTmFtZSB9LFxuICAgICdhbHRlcic6IHBpdGNoLmFsdGVyLFxuICAgICdvY3RhdmUnOiB7ICcjdGV4dCc6IG5vdGUub2N0YXZlIH1cbiAgfTtcbn1cblxuXG50eXBlIEtleUNoYW5nZSA9IHtcbiAgZmlmdGhzOiBudW1iZXIsXG4gIGNhbmNlbDogbnVtYmVyLFxuICBtb2RlOiBzdHJpbmcsXG59XG5cblxuZnVuY3Rpb24gYWRkUmljaE5vdGVUb01lYXN1cmUocmljaE5vdGU6IFJpY2hOb3RlLCBtZWFzdXJlOiBidWlsZGVyLlhNTEVsZW1lbnQsIHN0YWZmOiBudW1iZXIsIHZvaWNlOiBudW1iZXIsIGZpcnN0Tm90ZUluQ2hvcmQ6IGJvb2xlYW4sIHdyaXRlQ2hvcmQ6IGJvb2xlYW4sIGtleWNoYW5nZTogS2V5Q2hhbmdlIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkLCBwYXJhbXM6IE11c2ljUGFyYW1zKSB7XG4gIGlmIChyaWNoTm90ZS5kdXJhdGlvbiA9PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGR1cmF0aW9uID0gcmljaE5vdGVEdXJhdGlvbihyaWNoTm90ZSk7XG4gIGxldCBiZWFtTnVtYmVyID0gMTtcblxuICBsZXQgbm90YXRpb25zID0gdW5kZWZpbmVkO1xuICBpZiAocmljaE5vdGUudGllKSB7XG4gICAgbm90YXRpb25zID0ge1xuICAgICAgdGllZDoge1xuICAgICAgICAnQHR5cGUnOiByaWNoTm90ZS50aWUsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IGx5cmljID0gcmljaE5vdGUudGVuc2lvbiAmJiBzdGFmZiA9PSAwID8geyAndGV4dCc6IHsgJyN0ZXh0JzogcmljaE5vdGUudGVuc2lvbi50b0ZpeGVkKDIpIH0gfSA6IHVuZGVmaW5lZFxuXG4gIGlmIChyaWNoTm90ZS5zY2FsZSAmJiByaWNoTm90ZS5jaG9yZCAmJiBzdGFmZiA9PSAxKSB7XG4gICAgY29uc3Qgcm9tYW4gPSByaWNoTm90ZS5zY2FsZS5ub3Rlcy5tYXAobiA9PiBuLnNlbWl0b25lKS5pbmRleE9mKHJpY2hOb3RlLmNob3JkLm5vdGVzWzBdLnNlbWl0b25lKTtcbiAgICBjb25zdCBudW1iZXJUb1JvbWFuID0gWydJJywgJ0lJJywgJ0lJSScsICdJVicsICdWJywgJ1ZJJywgJ1ZJSSddO1xuICAgIGxldCByb21hbk51bWVyYWwgPSBudW1iZXJUb1JvbWFuW3JvbWFuXTtcbiAgICBpZiAocmljaE5vdGUuY2hvcmQuY2hvcmRUeXBlID09ICdtaW4nKSB7XG4gICAgICByb21hbk51bWVyYWwgPSByb21hbk51bWVyYWwudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKHJpY2hOb3RlLmNob3JkLmNob3JkVHlwZSA9PSAnZGltJykge1xuICAgICAgcm9tYW5OdW1lcmFsID0gcm9tYW5OdW1lcmFsLnRvTG93ZXJDYXNlKCkgKyAnwrAnO1xuICAgIH1cbiAgICBpZiAocmljaE5vdGUuY2hvcmQuY2hvcmRUeXBlID09ICdkb203Jykge1xuICAgICAgcm9tYW5OdW1lcmFsID0gcm9tYW5OdW1lcmFsICsgJzcnO1xuICAgIH1cbiAgICBpZiAocmljaE5vdGUuaW52ZXJzaW9uTmFtZSkge1xuICAgICAgaWYgKHJpY2hOb3RlLmludmVyc2lvbk5hbWUuc3RhcnRzV2l0aCgnZmlyc3QnKSkge1xuICAgICAgICByb21hbk51bWVyYWwgPSByb21hbk51bWVyYWwgKyAnNic7XG4gICAgICB9XG4gICAgICBpZiAocmljaE5vdGUuaW52ZXJzaW9uTmFtZS5zdGFydHNXaXRoKCdzZWNvbmQnKSkge1xuICAgICAgICByb21hbk51bWVyYWwgPSByb21hbk51bWVyYWwgKyAnNjQnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGx5cmljID0geyAndGV4dCc6IHsgJyN0ZXh0Jzogcm9tYW5OdW1lcmFsIH0gfVxuICB9XG5cbiAgY29uc3QgYXR0cnMgPSAge1xuICAgICdjaG9yZCc6ICFmaXJzdE5vdGVJbkNob3JkID8ge30gOiB1bmRlZmluZWQsXG4gICAgJ3BpdGNoJzogbm90ZVRvUGl0Y2gocmljaE5vdGUpLFxuICAgICdkdXJhdGlvbic6IGR1cmF0aW9uLmR1cmF0aW9uLFxuICAgICd2b2ljZSc6IHZvaWNlLFxuICAgICdzdGVtJzogeyAnI3RleHQnOiB2b2ljZSA9PSAwID8gJ3VwJyA6ICdkb3duJywgJ0BkZWZhdWx0LXknOiB2b2ljZSA9PSAwID8gNSA6IC00NSB9LFxuICAgICd0eXBlJzogZHVyYXRpb24udHlwZSxcbiAgICAnc3RhZmYnOiBzdGFmZixcbiAgICAnYmVhbSc6IHJpY2hOb3RlLmJlYW0gPyB7ICdAbnVtYmVyJzogYmVhbU51bWJlciwgJyN0ZXh0JzogcmljaE5vdGUuYmVhbSB9IDogdW5kZWZpbmVkLFxuICAgICd0aWUnOiByaWNoTm90ZS50aWUgPyB7ICdAdHlwZSc6IHJpY2hOb3RlLnRpZSB9IDogdW5kZWZpbmVkLFxuICAgICdseXJpYyc6IGx5cmljLFxuICAgICdub3RhdGlvbnMnOiBub3RhdGlvbnMsXG4gIH07XG4gIGlmICh3cml0ZUNob3JkICYmIHJpY2hOb3RlLmNob3JkICYmIHN0YWZmID09IDEpIHtcbiAgICBsZXQgY2hvcmRUeXBlOiBzdHJpbmcgPSAnbWFqb3InO1xuICAgIGNvbnN0IGNob3JkVGVtcGxhdGVLZXkgPSByaWNoTm90ZS5jaG9yZC5jaG9yZFR5cGU7XG5cbiAgICBsZXQga2luZFRleHQgPSBjaG9yZFRlbXBsYXRlS2V5O1xuICAgIGNvbnNvbGUubG9nKFwiQ2hvcmQgdGVtcGxhdGUga2V5OiBcIiArIGNob3JkVGVtcGxhdGVLZXkpO1xuICAgIGlmIChjaG9yZFRlbXBsYXRlS2V5ID09IFwibWFqXCIpIHtcbiAgICAgIGNob3JkVHlwZSA9ICdtYWpvcic7XG4gICAgICBraW5kVGV4dCA9ICcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaG9yZFRlbXBsYXRlS2V5ID09IFwibWluXCIpIHtcbiAgICAgIGNob3JkVHlwZSA9ICdtaW5vcic7XG4gICAgICBraW5kVGV4dCA9ICdtJztcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hvcmRUZW1wbGF0ZUtleSA9PSBcImRpbVwiKSB7XG4gICAgICBjaG9yZFR5cGUgPSAnZGltaW5pc2hlZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNob3JkVGVtcGxhdGVLZXkgPT0gXCJhdWdcIikge1xuICAgICAgY2hvcmRUeXBlID0gJ2F1Z21lbnRlZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNob3JkVGVtcGxhdGVLZXkgPT0gXCJkb203XCIpIHtcbiAgICAgIGNob3JkVHlwZSA9ICdkb21pbmFudCc7XG4gICAgICBraW5kVGV4dCA9IFwiN1wiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaG9yZFRlbXBsYXRlS2V5ID09IFwibWFqN1wiKSB7XG4gICAgICBjaG9yZFR5cGUgPSAnbWFqb3Itc2V2ZW50aCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNob3JkVGVtcGxhdGVLZXkgPT0gXCJtaW43XCIpIHtcbiAgICAgIGNob3JkVHlwZSA9ICdtaW5vci1zZXZlbnRoJztcbiAgICAgIGtpbmRUZXh0ID0gXCJtN1wiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaG9yZFRlbXBsYXRlS2V5ID09IFwic3VzMlwiKSB7XG4gICAgICBjaG9yZFR5cGUgPSAnc3VzcGVuZGVkLXNlY29uZCc7XG4gICAgICBraW5kVGV4dCA9IFwic3VzMlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaG9yZFRlbXBsYXRlS2V5ID09IFwic3VzNFwiKSB7XG4gICAgICBjaG9yZFR5cGUgPSAnc3VzcGVuZGVkLWZvdXJ0aCc7XG4gICAgICBraW5kVGV4dCA9IFwic3VzNFwiO1xuICAgIH1cblxuICAgIGNvbnN0IHNjb3JlU2NhbGUgPSBuZXcgU2NhbGUoe2tleTogMCwgb2N0YXZlOiA0LCB0ZW1wbGF0ZTogU2NhbGVUZW1wbGF0ZXMubWFqb3J9KVxuICAgIGxldCBkaXJlY3Rpb24gPSAnc2hhcnAnO1xuICAgIGlmIChyaWNoTm90ZS5zY2FsZSkge1xuICAgICAgY29uc3QgYmFzZSA9IHJpY2hOb3RlLnNjYWxlLm5vdGVzWzBdLnNlbWl0b25lO1xuICAgICAgaWYgKGZsYXRTY2FsZVNlbWl0b25lcy5oYXMoYmFzZSkpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gJ2ZsYXQnO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwaXRjaCA9IHNlbWl0b25lVG9QaXRjaChyaWNoTm90ZS5jaG9yZC5ub3Rlc1swXS5zZW1pdG9uZSwgc2NvcmVTY2FsZSwgZGlyZWN0aW9uKTtcblxuICAgIG1lYXN1cmUuZWxlKHsgJ2hhcm1vbnknOiB7XG4gICAgICAgICdyb290Jzoge1xuICAgICAgICAgICdyb290LXN0ZXAnOiB7ICcjdGV4dCc6IHBpdGNoLm5vdGVOYW1lIH0sXG4gICAgICAgICAgJ3Jvb3QtYWx0ZXInOiBwaXRjaC5hbHRlcixcbiAgICAgICAgfSxcbiAgICAgICAgJ2tpbmQnOiB7XG4gICAgICAgICAgJ0BoYWxpZ24nOiAnY2VudGVyJyxcbiAgICAgICAgICAnQHRleHQnOiBraW5kVGV4dCxcbiAgICAgICAgICAnI3RleHQnOiBjaG9yZFR5cGUsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGlmIChrZXljaGFuZ2UpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gbWVhc3VyZS5lbGUoJ2F0dHJpYnV0ZXMnKTtcbiAgICBhdHRyaWJ1dGVzLmVsZSh7ICdrZXknOiB7XG4gICAgICAgICdjYW5jZWwnOiB7ICcjdGV4dCc6IGtleWNoYW5nZS5jYW5jZWwgfSxcbiAgICAgICAgJ2ZpZnRocyc6IHsgJyN0ZXh0Jzoga2V5Y2hhbmdlLmZpZnRocyB9LFxuICAgICAgICAnbW9kZSc6IHsgJyN0ZXh0Jzoga2V5Y2hhbmdlLm1vZGUgfSxcbiAgICB9fSlcbiAgfVxuICBtZWFzdXJlLmVsZSh7ICdub3RlJzogYXR0cnMgfSk7XG59XG5cbmZ1bmN0aW9uIGZpcnN0TWVhc3VyZUluaXQodm9pY2VQYXJ0SW5kZXg6IG51bWJlciwgbWVhc3VyZTogYnVpbGRlci5YTUxFbGVtZW50LCBwYXJhbXM6IE11c2ljUGFyYW1zKSB7XG4gIGxldCBjbGVmO1xuICBjb25zdCBzZW1pdG9uZXMgPSBbXG4gICAgZ2xvYmFsU2VtaXRvbmUobmV3IE5vdGUocGFyYW1zLnBhcnRzWzBdLm5vdGUgfHwgXCJGNFwiKSksXG4gICAgZ2xvYmFsU2VtaXRvbmUobmV3IE5vdGUocGFyYW1zLnBhcnRzWzFdLm5vdGUgfHwgXCJDNFwiKSksXG4gICAgZ2xvYmFsU2VtaXRvbmUobmV3IE5vdGUocGFyYW1zLnBhcnRzWzJdLm5vdGUgfHwgXCJBM1wiKSksXG4gICAgZ2xvYmFsU2VtaXRvbmUobmV3IE5vdGUocGFyYW1zLnBhcnRzWzNdLm5vdGUgfHwgXCJDM1wiKSksXG4gIF1cblxuICBsZXQgY2xlZlNlbWl0b25lSW5kZXg7XG4gIGlmICh2b2ljZVBhcnRJbmRleCA8PSAxKSB7XG4gICAgY2xlZlNlbWl0b25lSW5kZXggPSAxO1xuICB9XG4gIGVsc2Uge1xuICAgIGNsZWZTZW1pdG9uZUluZGV4ID0gMztcbiAgfVxuICBjb25zdCBteVNlbWl0b25lID0gc2VtaXRvbmVzW2NsZWZTZW1pdG9uZUluZGV4XTtcbiAgaWYgKG15U2VtaXRvbmUgPCA0NSkge1xuICAgIGNsZWYgPSB7XG4gICAgICAnQG51bWJlcic6IDEsXG4gICAgICAnc2lnbic6ICdGJyxcbiAgICAgICdsaW5lJzogNCxcbiAgICB9O1xuICB9IGVsc2UgaWYgKG15U2VtaXRvbmUgPCA1MCkge1xuICAgIGNsZWYgPSB7XG4gICAgICAnQG51bWJlcic6IDEsXG4gICAgICAnc2lnbic6ICdHJyxcbiAgICAgICdsaW5lJzogMixcbiAgICAgICdjbGVmLW9jdGF2ZS1jaGFuZ2UnOiB7XG4gICAgICAgICcjdGV4dCc6ICctMSdcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGNsZWYgPSB7XG4gICAgICAnQG51bWJlcic6IDEsXG4gICAgICAnc2lnbic6ICdHJyxcbiAgICAgICdsaW5lJzogMixcbiAgICB9O1xuICB9XG5cbiAgbWVhc3VyZS5lbGUoeyAnYXR0cmlidXRlcyc6IHtcbiAgICAnZGl2aXNpb25zJzogeyAnI3RleHQnOiBgJHtCRUFUX0xFTkdUSH1gIH0sXG4gICAgJ2tleSc6IHtcbiAgICAgICdmaWZ0aHMnOiB7ICcjdGV4dCc6ICcwJyB9XG4gICAgfSxcbiAgICAndGltZSc6IHtcbiAgICAgICdiZWF0cyc6IHsgJyN0ZXh0JzogcGFyYW1zLmJlYXRzUGVyQmFyIH0sXG4gICAgICAnYmVhdC10eXBlJzogeyAnI3RleHQnOiAnNCcgfVxuICAgIH0sXG4gICAgJ3N0YXZlcyc6IDEsXG4gICAgY2xlZjogW1xuICAgICAgY2xlZlxuICAgIF1cbiAgfSxcbiAgJ2RpcmVjdGlvbic6IHtcbiAgICAnQHBsYWNlbWVudCc6ICdhYm92ZScsXG4gICAgJ2RpcmVjdGlvbi10eXBlJzoge1xuICAgICAgJ21ldHJvbm9tZSc6IHtcbiAgICAgICAgJ2JlYXQtdW5pdCc6ICdxdWFydGVyJyxcbiAgICAgICAgJ3Blci1taW51dGUnOiBgJHtwYXJhbXMudGVtcG8gfHwgNDB9YFxuICAgICAgfVxuICAgIH0sXG4gICAgJ3NvdW5kJzoge1xuICAgICAgJ0B0ZW1wbyc6IGAke3BhcmFtcy50ZW1wbyB8fCA0MH1gXG4gICAgfVxuICB9XG59KTtcbn1cblxuXG5jb25zdCBnZXRTY2FsZVNoYXJwQ291bnQgPSAoc2NhbGU6IFNjYWxlKSA9PiB7XG4gIGxldCBzaGFycENvdW50ID0gMDtcbiAgY29uc3Qgc2VtaXRvbmUgPSBzY2FsZS5rZXk7XG4gIGNvbnN0IGJhc2VUb25lcyA9IFswLCAyLCA0LCA1LCA3LCA5LCAxMV07XG4gIGlmIChzZW1pdG9uZSA9PSAwIHx8IHNlbWl0b25lID09IDIgfHwgc2VtaXRvbmUgPT0gNCB8fCBzZW1pdG9uZSA9PSA3IHx8IHNlbWl0b25lID09IDkgfHwgc2VtaXRvbmUgPT0gMTEpIHtcbiAgICAvLyBBZGQgc2hhcnBzIHRvIHRoZSBzY2FsZVxuICAgIGZvciAoY29uc3Qgbm90ZSBvZiBzY2FsZS5ub3Rlcykge1xuICAgICAgaWYgKCFiYXNlVG9uZXMuaW5jbHVkZXMobm90ZS5zZW1pdG9uZSkpIHtcbiAgICAgICAgc2hhcnBDb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hhcnBDb3VudDtcbiAgfSBlbHNlIHtcbiAgICAvLyBBZGQgZmxhdHMgdG8gdGhlIHNjYWxlXG4gICAgZm9yIChjb25zdCBub3RlIG9mIHNjYWxlLm5vdGVzKSB7XG4gICAgICBpZiAoIWJhc2VUb25lcy5pbmNsdWRlcyhub3RlLnNlbWl0b25lKSkge1xuICAgICAgICBzaGFycENvdW50LS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaGFycENvdW50O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1htbChkaXZpc2lvbmVkTm90ZXM6IERpdmlzaW9uZWRSaWNobm90ZXMsIG1haW5QYXJhbXM6IE1haW5NdXNpY1BhcmFtcyk6IHN0cmluZyB7XG4gIGNvbnN0IHJvb3QgPSBidWlsZGVyLmNyZWF0ZSh7ICdzY29yZS1wYXJ0d2lzZScgOiB7ICdAdmVyc2lvbic6IDMuMSB9fSxcbiAgICB7IHZlcnNpb246ICcxLjAnLCBlbmNvZGluZzogJ1VURi04Jywgc3RhbmRhbG9uZTogZmFsc2V9LFxuICAgIHtcbiAgICAgIHB1YklEOiAnLS8vUmVjb3JkYXJlLy9EVEQgTXVzaWNYTUwgMy4xIFBhcnR3aXNlLy9FTicsXG4gICAgICBzeXNJRDogJ2h0dHA6Ly93d3cubXVzaWN4bWwub3JnL2R0ZHMvcGFydHdpc2UuZHRkJ1xuICAgIH1cbiAgKTtcbiAgcm9vdC5lbGUoeyAnd29yayc6IHsgJ3dvcmstdGl0bGUnOiBcIk15IHNvbmdcIiB9fSk7XG4gIGNvbnN0IGZpcnN0UGFyYW1zID0gbWFpblBhcmFtcy5jdXJyZW50Q2FkZW5jZVBhcmFtcygwKTtcbiAgY29uc3QgcGFydExpc3QgPSByb290LmVsZSh7ICdwYXJ0LWxpc3QnOiB7fX0pO1xuICBwYXJ0TGlzdC5lbGUoe1xuICAgICdzY29yZS1wYXJ0Jzoge1xuICAgICAgJ0BpZCc6ICdQMScsXG4gICAgICAnZ3JvdXAnOiB7XG4gICAgICAgICcjdGV4dCc6ICdzY29yZSdcbiAgICAgIH0sXG4gICAgICAncGFydC1uYW1lJzoge1xuICAgICAgICAnI3RleHQnOiAnUDEnXG4gICAgICB9LFxuICAgICAgJ3Njb3JlLWluc3RydW1lbnQnOiB7XG4gICAgICAgICdAaWQnOiAnUDEtSTEnLFxuICAgICAgICAnaW5zdHJ1bWVudC1uYW1lJzoge1xuICAgICAgICAgICcjdGV4dCc6IGAke2ZpcnN0UGFyYW1zLnBhcnRzWzBdLnZvaWNlfWBcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICAnbWlkaS1pbnN0cnVtZW50Jzoge1xuICAgICAgICAnQGlkJzogJ1AxLUkxJyxcbiAgICAgICAgJ21pZGktY2hhbm5lbCc6IDEsXG4gICAgICAgICdtaWRpLXByb2dyYW0nOiBmaXJzdFBhcmFtcy5wYXJ0c1swXS52b2ljZSxcbiAgICAgICAgJ3ZvbHVtZSc6IDEwMCxcbiAgICAgICAgJ3Bhbic6IDBcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBwYXJ0TGlzdC5lbGUoe1xuICAgICdzY29yZS1wYXJ0Jzoge1xuICAgICAgJ0BpZCc6ICdQMicsXG4gICAgICAnZ3JvdXAnOiB7XG4gICAgICAgICcjdGV4dCc6ICdzY29yZSdcbiAgICAgIH0sXG4gICAgICAncGFydC1uYW1lJzoge1xuICAgICAgICAnI3RleHQnOiAnUDInXG4gICAgICB9LFxuICAgICAgJ3Njb3JlLWluc3RydW1lbnQnOiB7XG4gICAgICAgICdAaWQnOiAnUDItSTEnLFxuICAgICAgICAnaW5zdHJ1bWVudC1uYW1lJzoge1xuICAgICAgICAgICcjdGV4dCc6IGAke2ZpcnN0UGFyYW1zLnBhcnRzWzNdLnZvaWNlfWBcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICAnbWlkaS1pbnN0cnVtZW50Jzoge1xuICAgICAgICAnQGlkJzogJ1AyLUkxJyxcbiAgICAgICAgJ21pZGktY2hhbm5lbCc6IDEsXG4gICAgICAgICdtaWRpLXByb2dyYW0nOiBmaXJzdFBhcmFtcy5wYXJ0c1szXS52b2ljZSxcbiAgICAgICAgJ3ZvbHVtZSc6IDEwMCxcbiAgICAgICAgJ3Bhbic6IDBcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHBhcnRzID0gW1xuICAgIHJvb3QuZWxlKHsgJ3BhcnQnOiB7ICdAaWQnOiAnUDEnIH19KSxcbiAgICByb290LmVsZSh7ICdwYXJ0JzogeyAnQGlkJzogJ1AyJyB9fSksXG4gIF07XG5cbiAgY29uc3QgbWVhc3VyZXM6IEFycmF5PEFycmF5PGJ1aWxkZXIuWE1MRWxlbWVudD4+ID0gW1xuICAgIFtdLFxuICAgIFtdLFxuICBdXG5cbiAgLy8gKDAgKyAxKSArICgoMCArIDEpICogMikgPSAxICsgMiA9IDNcbiAgLy8gMCArIDAgPSAwXG4gIC8vIDAgKyAxID0gMVxuICAvLyAxICsgMCA9IDJcbiAgLy8gMSArIDEgPSAzXG5cbiAgY29uc3QgbWF4RGl2aXNpb24gPSBNYXRoLm1heCguLi5PYmplY3Qua2V5cyhkaXZpc2lvbmVkTm90ZXMpLm1hcCgoaykgPT4gcGFyc2VJbnQoaykpKVxuICBsZXQgZGl2aXNpb24gPSAwO1xuICBsZXQgY3VycmVudFNjYWxlID0gbmV3IFNjYWxlKHsga2V5OiAwIH0pO1xuICB3aGlsZSAoZGl2aXNpb24gPD0gbWF4RGl2aXNpb24pIHtcbiAgICBjb25zdCBwYXJhbXMgPSBtYWluUGFyYW1zLmN1cnJlbnRDYWRlbmNlUGFyYW1zKGRpdmlzaW9uKTtcbiAgICBsZXQgbWVhc3VyZUluZGV4ID0gTWF0aC5mbG9vcihkaXZpc2lvbiAvIChwYXJhbXMuYmVhdHNQZXJCYXIgKiBCRUFUX0xFTkdUSCkpXG4gICAgZm9yIChsZXQgcGFydEluZGV4PTA7IHBhcnRJbmRleDw0OyBwYXJ0SW5kZXgrKykge1xuICAgICAgbGV0IHN0YWZmID0gcGFydEluZGV4IDw9IDEgPyAwIDogMTtcbiAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tzdGFmZl07XG4gICAgICBjb25zdCB2b2ljZVBhcnRJbmRleCA9IHBhcnRJbmRleDtcbiAgICAgIGlmIChkaXZpc2lvbiA9PSAwICYmIHBhcnRJbmRleCAlIDIgPT0gMCkge1xuICAgICAgICBtZWFzdXJlc1tzdGFmZl0ucHVzaChwYXJ0LmVsZSh7ICdtZWFzdXJlJzogeyAnQG51bWJlcic6IDEgfX0pKTtcbiAgICAgICAgZmlyc3RNZWFzdXJlSW5pdCh2b2ljZVBhcnRJbmRleCwgbWVhc3VyZXNbc3RhZmZdW21lYXN1cmVzW3N0YWZmXS5sZW5ndGggLSAxXSwgZmlyc3RQYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0SW5kZXggJSAyID09IDApIHtcbiAgICAgICAgbWVhc3VyZXNbc3RhZmZdLnB1c2goXG4gICAgICAgICAgcGFydC5lbGUoeyAnbWVhc3VyZSc6IHsgJ0BudW1iZXInOiBgJHsobWVhc3VyZUluZGV4KSArIDF9YCB9IH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBsZXQgY3VycmVudE1lYXN1cmUgPSBtZWFzdXJlc1tzdGFmZl1bbWVhc3VyZUluZGV4XVxuXG4gICAgICAvLyBNb3ZlIHNlY29uZCB2b2ljZSBiYWNrd2FyZHMgYnkgYSBmdWxsIG1lYXN1cmVcbiAgICAgIGlmIChwYXJ0SW5kZXggJSAyICE9IDApIHtcbiAgICAgICAgbWVhc3VyZXNbc3RhZmZdW21lYXN1cmVzW3N0YWZmXS5sZW5ndGggLSAxXS5lbGUoe1xuICAgICAgICAgICdiYWNrdXAnOiB7XG4gICAgICAgICAgICAnZHVyYXRpb24nOiB7XG4gICAgICAgICAgICAgIFwiI3RleHRcIjogYCR7cGFyYW1zLmJlYXRzUGVyQmFyICogQkVBVF9MRU5HVEh9YCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgYWxsIHJpY2hOb3RlcyBmb3IgdGhpcyBwYXJ0IGZvciB0aGlzIG1lYXN1cmVcblxuICAgICAgZm9yIChsZXQgdG1wRGl2aXNpb249MDsgdG1wRGl2aXNpb24gPHBhcmFtcy5iZWF0c1BlckJhciAqIEJFQVRfTEVOR1RIOyB0bXBEaXZpc2lvbisrKSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVEaXZpc2lvbiA9IGRpdmlzaW9uICsgdG1wRGl2aXNpb247XG4gICAgICAgIGNvbnN0IHJpY2hOb3RlcyA9IChkaXZpc2lvbmVkTm90ZXNbbWVhc3VyZURpdmlzaW9uXSB8fCBbXSkuZmlsdGVyKChybikgPT4gcm4ucGFydEluZGV4ID09IHBhcnRJbmRleCk7XG4gICAgICAgIGlmICghcmljaE5vdGVzIHx8IHJpY2hOb3Rlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJpY2hOb3RlID0gcmljaE5vdGVzWzBdO1xuICAgICAgICAvLyBsZXQga2V5Q2hhbmdlOiBLZXlDaGFuZ2UgfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgICAgICAgLy8gaWYgKGRpdmlzaW9uICUgKHBhcmFtcy5iZWF0c1BlckJhciAqIEJFQVRfTEVOR1RIKSA9PSAwICYmIHJpY2hOb3RlLnNjYWxlLmtleSAhPSBjdXJyZW50U2NhbGUua2V5KSB7XG4gICAgICAgIC8vICAgY29uc3QgcHJldlNoYXJwQ291bnQgPSBnZXRTY2FsZVNoYXJwQ291bnQoY3VycmVudFNjYWxlKTtcbiAgICAgICAgLy8gICBjb25zdCBuZXdTaGFycENvdW50ID0gZ2V0U2NhbGVTaGFycENvdW50KHJpY2hOb3RlLnNjYWxlKTtcbiAgICAgICAgLy8gICBsZXQgZmlmdGhzID0gMDtcbiAgICAgICAgLy8gICBsZXQgY2FuY2VsID0gMDtcbiAgICAgICAgLy8gICBpZiAocHJldlNoYXJwQ291bnQgPj0gMCAmJiBuZXdTaGFycENvdW50ID4gcHJldlNoYXJwQ291bnQpIHtcbiAgICAgICAgLy8gICAgIC8vIFRoZXJlIHdlcmUgc2hhcnBzLCBhbmQgbm93IHRoZXJlIGFyZSBtb3JlIHNoYXJwc1xuICAgICAgICAvLyAgICAgZmlmdGhzID0gbmV3U2hhcnBDb3VudCAtIHByZXZTaGFycENvdW50O1xuICAgICAgICAvLyAgIH0gZWxzZSBpZiAocHJldlNoYXJwQ291bnQgPD0gMCAmJiBuZXdTaGFycENvdW50IDwgcHJldlNoYXJwQ291bnQpIHtcbiAgICAgICAgLy8gICAgIC8vIFRoZXJlIHdlcmUgZmxhdHMsIGFuZCBub3cgdGhlcmUgYXJlIG1vcmUgZmxhdHNcbiAgICAgICAgLy8gICAgIGZpZnRocyA9IG5ld1NoYXJwQ291bnQgLSBwcmV2U2hhcnBDb3VudDtcbiAgICAgICAgLy8gICB9IGVsc2UgaWYgKHByZXZTaGFycENvdW50ID49IDAgJiYgbmV3U2hhcnBDb3VudCA8IHByZXZTaGFycENvdW50KSB7XG4gICAgICAgIC8vICAgICAvLyBUaGVyZSB3ZXJlIHNoYXJwcywgYW5kIG5vdyB0aGVyZSBhcmUgZmV3ZXIgc2hhcnBzIChtYXliZSBldmVuIGZsYXRzKVxuICAgICAgICAvLyAgICAgZm9yIChsZXQgaT1wcmV2U2hhcnBDb3VudDsgaT5uZXdTaGFycENvdW50OyBpLS0pIHtcbiAgICAgICAgLy8gICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIC8vICAgICAgICAgLy8gVHVybiB0aGVzZSBmaWZ0aHMgaW50byBjYW5jZWxzXG4gICAgICAgIC8vICAgICAgICAgY2FuY2VsKys7XG4gICAgICAgIC8vICAgICAgICAgZmlmdGhzLS07XG4gICAgICAgIC8vICAgICAgIH1cbiAgICAgICAgLy8gICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIC8vICAgICAgICAgZmlmdGhzLS07XG4gICAgICAgIC8vICAgICAgIH1cbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIC8vVE9ET1xuICAgICAgICAvLyAgIH0gZWxzZSBpZiAocHJldlNoYXJwQ291bnQgPD0gMCAmJiBuZXdTaGFycENvdW50ID4gcHJldlNoYXJwQ291bnQpIHtcbiAgICAgICAgLy8gICAgIC8vIFRoZXJlIHdlcmUgZmxhdHMsIGFuZCBub3cgdGhlcmUgYXJlIGZld2VyIGZsYXRzIChtYXliZSBldmVuIHNoYXJwcylcbiAgICAgICAgLy8gICAgIC8vVE9ET1xuICAgICAgICAvLyAgICAgZm9yIChsZXQgaT1wcmV2U2hhcnBDb3VudDsgaT5uZXdTaGFycENvdW50OyBpKyspIHtcbiAgICAgICAgLy8gICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIC8vICAgICAgICAgLy8gVHVybiB0aGVzZSBmbGF0cyBpbnRvIGNhbmNlbHNcbiAgICAgICAgLy8gICAgICAgICBjYW5jZWwrKztcbiAgICAgICAgLy8gICAgICAgICBmaWZ0aHMtLTtcbiAgICAgICAgLy8gICAgICAgfVxuICAgICAgICAvLyAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgLy8gICAgICAgICBmaWZ0aHMrKztcbiAgICAgICAgLy8gICAgICAgfVxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gICBjb25zb2xlLmxvZyhgcHJldlNoYXJwQ291bnQ6ICR7cHJldlNoYXJwQ291bnR9LCBuZXdTaGFycENvdW50OiAke25ld1NoYXJwQ291bnR9LCBmaWZ0aHM6ICR7ZmlmdGhzfSwgY2FuY2VsOiAke2NhbmNlbH1gKTtcbiAgICAgICAgLy8gICBrZXlDaGFuZ2UgPSB7XG4gICAgICAgIC8vICAgICBmaWZ0aHM6IGZpZnRocyxcbiAgICAgICAgLy8gICAgIGNhbmNlbDogY2FuY2VsLFxuICAgICAgICAvLyAgIH0gYXMgS2V5Q2hhbmdlXG4gICAgICAgIC8vIH1cbiAgICAgICAgYWRkUmljaE5vdGVUb01lYXN1cmUoXG4gICAgICAgICAgcmljaE5vdGUsXG4gICAgICAgICAgY3VycmVudE1lYXN1cmUsXG4gICAgICAgICAgc3RhZmYsXG4gICAgICAgICAgcGFydEluZGV4ICUgMixcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIG1lYXN1cmVEaXZpc2lvbiAlIEJFQVRfTEVOR1RIID09IDAsXG4gICAgICAgICAgdW5kZWZpbmVkLCAvL2tleUNoYW5nZSxcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGRpdmlzaW9uICs9IHBhcmFtcy5iZWF0c1BlckJhciAqIEJFQVRfTEVOR1RIO1xuICB9XG5cbiAgY29uc3QgcmV0ID0gcm9vdC5lbmQoeyBwcmV0dHk6IHRydWV9KTtcbiAgY29uc29sZS5sb2cocmV0KVxuICByZXR1cm4gcmV0O1xufSIsImNvbnN0IHByaW50Q2hpbGRNZXNzYWdlcyA9IChjaGlsZExvZ2dlcjogTG9nZ2VyKSA9PiB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZExvZ2dlci5jaGlsZHJlbikge1xuICAgICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKC4uLmNoaWxkLnRpdGxlKTtcbiAgICAgICAgcHJpbnRDaGlsZE1lc3NhZ2VzKGNoaWxkKTtcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIGNoaWxkLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyguLi5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgTG9nZ2VyIHtcbiAgICB0aXRsZTogYW55W10gPSBbXTtcbiAgICBtZXNzYWdlczogQXJyYXk8YW55W10+ID0gW107XG4gICAgcGFyZW50OiBMb2dnZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgY2hpbGRyZW46IExvZ2dlcltdID0gW107XG4gICAgY2xlYXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IocGFyZW50OiBMb2dnZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9nKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMucHVzaChhcmdzKTtcbiAgICB9XG5cbiAgICBwcmludCguLi5hcmdzOiBhbnlbXSkge1xuICAgICAgICBpZiAodGhpcy5jbGVhcmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAvLyBMZXQgcGFyZW50IGhhbmRsZSBtZVxuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGl0bGUgPSBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoLi4uYXJncylcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgdG9wIGxvZ2dlci4gUHJpbnQgZXZlcnl0aGluZy5cbiAgICAgICAgcHJpbnRDaGlsZE1lc3NhZ2VzKHRoaXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKC4uLnRoaXMubWVzc2FnZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4gPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gY2hpbGQgIT09IHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJlZCA9IHRydWU7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgeyBTY2FsZSB9IGZyb20gXCJtdXNpY3RoZW9yeWpzXCI7XG5pbXBvcnQgeyBDaG9yZCwgY2hvcmRUZW1wbGF0ZXMsIE11c2ljUGFyYW1zIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuZXhwb3J0IGNsYXNzIFJhbmRvbUNob3JkR2VuZXJhdG9yIHtcbiAgICBwcml2YXRlIGNob3JkVHlwZXM6IHN0cmluZ1tdO1xuICAgIHByaXZhdGUgYXZhaWxhYmxlQ2hvcmRzOiBBcnJheTxzdHJpbmc+O1xuICAgIHByaXZhdGUgdXNlZENob3JkczogU2V0PHN0cmluZz47XG4gICAgcHJpdmF0ZSBjdXJyZW50U2NhbGU6IFNjYWxlO1xuXG4gICAgY29uc3RydWN0b3IocGFyYW1zOiBNdXNpY1BhcmFtcywgc2NhbGU6IFNjYWxlKSB7XG4gICAgICAgIGNvbnN0IGNob3JkVHlwZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjaG9yZFR5cGUgaW4gcGFyYW1zLmNob3JkU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuY2hvcmRTZXR0aW5nc1tjaG9yZFR5cGVdLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBjaG9yZFR5cGVzLnB1c2goY2hvcmRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNob3JkVHlwZXMgPSBjaG9yZFR5cGVzO1xuICAgICAgICB0aGlzLnVzZWRDaG9yZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuY3VycmVudFNjYWxlID0gc2NhbGU7XG4gICAgICAgIHRoaXMuYnVpbGRBdmFpbGFibGVDaG9yZHMoKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBidWlsZEF2YWlsYWJsZUNob3JkcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVzZWRDaG9yZHMpIHtcbiAgICAgICAgICAgIHRoaXMudXNlZENob3JkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF2YWlsYWJsZUNob3JkcyA9ICh0aGlzLmF2YWlsYWJsZUNob3JkcyB8fCBbXSkuZmlsdGVyKGNob3JkID0+ICF0aGlzLnVzZWRDaG9yZHMuaGFzKGNob3JkKSk7XG4gICAgICAgIC8vIEZpcnN0IHRyeSB0byBhZGQgdGhlIHNpbXBsZXN0IGNob3Jkc1xuICAgICAgICBmb3IgKGNvbnN0IHNpbXBsZUNob3JkVHlwZSBvZiB0aGlzLmNob3JkVHlwZXMuZmlsdGVyKGNob3JkVHlwZSA9PiBbXCJtYWpcIiwgXCJtaW5cIl0uaW5jbHVkZXMoY2hvcmRUeXBlKSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJhbmRvbVJvb3Q9MDsgcmFuZG9tUm9vdDwxMjsgcmFuZG9tUm9vdCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnVzZWRDaG9yZHMuaGFzKHJhbmRvbVJvb3QgKyBzaW1wbGVDaG9yZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlQ2hvcmRzLnB1c2gocmFuZG9tUm9vdCArIHNpbXBsZUNob3JkVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYXZhaWxhYmxlQ2hvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwxMDA7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcmFuZG9tVHlwZSA9IHRoaXMuY2hvcmRUeXBlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLmNob3JkVHlwZXMubGVuZ3RoKV07XG4gICAgICAgICAgICBjb25zdCByYW5kb21Sb290ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTIpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnVzZWRDaG9yZHMuaGFzKHJhbmRvbVJvb3QgKyByYW5kb21UeXBlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlQ2hvcmRzLnB1c2gocmFuZG9tUm9vdCArIHJhbmRvbVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHB1YmxpYyBjbGVhblVwKCkge1xuICAgICAgICBpZiAodGhpcy51c2VkQ2hvcmRzKSB7XG4gICAgICAgICAgICB0aGlzLnVzZWRDaG9yZHMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF2YWlsYWJsZUNob3JkcyA9IFtdO1xuICAgICAgICBkZWxldGUgdGhpcy51c2VkQ2hvcmRzO1xuICAgICAgICBkZWxldGUgdGhpcy5hdmFpbGFibGVDaG9yZHM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldENob3JkKCkge1xuICAgICAgICBpZiAoIXRoaXMuYXZhaWxhYmxlQ2hvcmRzIHx8IHRoaXMuYXZhaWxhYmxlQ2hvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEF2YWlsYWJsZUNob3JkcygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpdGVyYXRpb25zID0gMDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChpdGVyYXRpb25zKysgPiAxMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmF2YWlsYWJsZUNob3Jkcy5sZW5ndGggLSAzID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNob3JkVHlwZSA9IHRoaXMuYXZhaWxhYmxlQ2hvcmRzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMuYXZhaWxhYmxlQ2hvcmRzLmxlbmd0aCldO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy51c2VkQ2hvcmRzLmhhcyhjaG9yZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXNlZENob3Jkcy5hZGQoY2hvcmRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVDaG9yZHMgPSB0aGlzLmF2YWlsYWJsZUNob3Jkcy5maWx0ZXIoY2hvcmQgPT4gY2hvcmQgIT09IGNob3JkVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hvcmQoY2hvcmRUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1aWxkQXZhaWxhYmxlQ2hvcmRzKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBOb3RlLCBTY2FsZSB9IGZyb20gXCJtdXNpY3RoZW9yeWpzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi9teWxvZ2dlclwiO1xuaW1wb3J0IHsgQkVBVF9MRU5HVEgsIERpdmlzaW9uZWRSaWNobm90ZXMsIGdsb2JhbFNlbWl0b25lLCBnVG9uZVN0cmluZywgbWFqU2NhbGVEaWZmZXJlbmNlLCBNdXNpY1BhcmFtcywgTnVsbGFibGUsIHNlbWl0b25lRGlzdGFuY2UgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5leHBvcnQgY29uc3QgZ2V0VGVuc2lvbiA9IChkaXZpc2lvbmVkTm90ZXM6IERpdmlzaW9uZWRSaWNobm90ZXMsIHRvTm90ZXM6IEFycmF5PE5vdGU+LCBjdXJyZW50U2NhbGU6IFNjYWxlLCBiZWF0c1VudGlsTGFzdENob3JkSW5DYWRlbmNlOiBudW1iZXIsIHBhcmFtczogTXVzaWNQYXJhbXMsIGxvZ2dlcjogTG9nZ2VyLCBiZWF0c1VudGlsTGFzdENob3JkSW5Tb25nOiBudW1iZXIsIGludmVyc2lvbk5hbWU6IHN0cmluZywgcHJldkludmVyc2lvbk5hbWU6IFN0cmluZykgPT4ge1xuICAgIC8qXG4gICAgKiAgIEdldCB0aGUgdGVuc2lvbiBiZXR3ZWVuIHR3byBjaG9yZHNcbiAgICAqICAgQHBhcmFtIGZyb21DaG9yZDogQ2hvcmRcbiAgICAqICAgQHBhcmFtIHRvQ2hvcmQ6IENob3JkXG4gICAgKiAgIEByZXR1cm46IHRlbnNpb24gdmFsdWUgYmV0d2VlbiAtMSBhbmQgMVxuICAgICovXG4gICAgbGV0IHdhbnRlZEZ1bmN0aW9uID0gbnVsbDtcbiAgICBpZiAoYmVhdHNVbnRpbExhc3RDaG9yZEluQ2FkZW5jZSA9PSA0KSB7XG4gICAgICAgIHdhbnRlZEZ1bmN0aW9uID0gXCJzdWItZG9taW5hbnRcIjtcbiAgICB9XG4gICAgaWYgKGJlYXRzVW50aWxMYXN0Q2hvcmRJbkNhZGVuY2UgPT0gMykge1xuICAgICAgICB3YW50ZWRGdW5jdGlvbiA9IFwiZG9taW5hbnRcIjtcbiAgICB9XG4gICAgaWYgKGJlYXRzVW50aWxMYXN0Q2hvcmRJbkNhZGVuY2UgPCAzKSB7XG4gICAgICAgIHdhbnRlZEZ1bmN0aW9uID0gXCJ0b25pY1wiO1xuICAgICAgICBpZiAoIWludmVyc2lvbk5hbWUuc3RhcnRzV2l0aCgncm9vdCcpKSB7XG4gICAgICAgICAgICByZXR1cm4ge3RlbnNpb246IDEwMCwgd2FudGVkRnVuY3Rpb259O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbGF0ZXN0RGl2aXNpb24gPSBNYXRoLm1heCguLi5PYmplY3Qua2V5cyhkaXZpc2lvbmVkTm90ZXMpLm1hcCgoeCkgPT4gcGFyc2VJbnQoeCwgMTApKSk7XG4gICAgbGV0IHRtcCA6IEFycmF5PE5vdGUgfCBudWxsPiA9IFtudWxsLCBudWxsLCBudWxsLCBudWxsXTtcbiAgICBmb3IgKGNvbnN0IHJpY2hOb3RlIG9mIChkaXZpc2lvbmVkTm90ZXNbbGF0ZXN0RGl2aXNpb25dIHx8IFtdKSkge1xuICAgICAgICB0bXBbcmljaE5vdGUucGFydEluZGV4XSA9IHJpY2hOb3RlLm5vdGU7XG4gICAgfVxuICAgIGNvbnN0IHBhc3NlZEZyb21Ob3RlcyA9IFsuLi50bXBdLmZpbHRlcihCb29sZWFuKTtcbiAgICB0bXAgPSBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgZm9yIChjb25zdCByaWNoTm90ZSBvZiAoZGl2aXNpb25lZE5vdGVzW2xhdGVzdERpdmlzaW9uIC0gQkVBVF9MRU5HVEhdIHx8IFtdKSkge1xuICAgICAgICB0bXBbcmljaE5vdGUucGFydEluZGV4XSA9IHJpY2hOb3RlLm5vdGU7XG4gICAgfVxuICAgIGNvbnN0IHByZXZQYXNzZWRGcm9tTm90ZXMgPSBbLi4udG1wXS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICBsZXQgZnJvbU5vdGVzO1xuICAgIGlmIChwYXNzZWRGcm9tTm90ZXMubGVuZ3RoIDwgNCkge1xuICAgICAgICBmcm9tTm90ZXMgPSB0b05vdGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb21Ob3RlcyA9IHBhc3NlZEZyb21Ob3RlcztcbiAgICB9XG4gICAgY29uc3QgdG9DaG9yZFN0cmluZyA9IHRvTm90ZXMubWFwKG4gPT4gbi50b1N0cmluZygpKS5qb2luKCcsICcpO1xuICAgIGNvbnN0IGZyb21DaG9yZFN0cmluZyA9IGZyb21Ob3Rlcy5tYXAobiA9PiBuLnRvU3RyaW5nKCkpLmpvaW4oJywgJyk7XG5cbiAgICBjb25zdCBub3RlQ291bnQgPSBNYXRoLm1heChmcm9tTm90ZXMubGVuZ3RoLCB0b05vdGVzLmxlbmd0aCk7XG4gICAgLy8gQ29tcGFyZSB0aGUgbm90ZXMuIEVhY2ggZGlmZmVyaW5nIG5vdGUgaW5jcmVhc2VzIHRoZSB0ZW5zaW9uIGEgYml0XG4gICAgbGV0IHRlbnNpb24gPSAwO1xuICAgIGNvbnN0IGZyb21TZW1pdG9uZXMgPSBmcm9tTm90ZXMubWFwKG5vdGUgPT4gbm90ZS5zZW1pdG9uZSk7XG4gICAgY29uc3QgdG9TZW1pdG9uZXMgPSB0b05vdGVzLm1hcChub3RlID0+IG5vdGUuc2VtaXRvbmUpO1xuICAgIGNvbnN0IGZyb21HbG9iYWxTZW1pdG9uZXMgPSBmcm9tTm90ZXMubWFwKG5vdGUgPT4gZ2xvYmFsU2VtaXRvbmUobm90ZSkpO1xuICAgIGNvbnN0IHRvR2xvYmFsU2VtaXRvbmVzID0gdG9Ob3Rlcy5tYXAobm90ZSA9PiBnbG9iYWxTZW1pdG9uZShub3RlKSk7XG4gICAgY29uc3QgZGlmZmVyaW5nTm90ZXMgPSB0b1NlbWl0b25lcy5maWx0ZXIoc2VtaXRvbmUgPT4gIWZyb21TZW1pdG9uZXMuaW5jbHVkZXMoc2VtaXRvbmUpKTtcbiAgICBjb25zdCBzYW1lTm90ZXMgPSB0b1NlbWl0b25lcy5maWx0ZXIoc2VtaXRvbmUgPT4gZnJvbVNlbWl0b25lcy5pbmNsdWRlcyhzZW1pdG9uZSkpO1xuXG4gICAgbG9nZ2VyLmxvZyhcImZyb21HbG9iYWxTZW1pdG9uZXM6IFwiLCBmcm9tR2xvYmFsU2VtaXRvbmVzLm1hcChzID0+IGdUb25lU3RyaW5nKHMpKSk7XG4gICAgbG9nZ2VyLmxvZyhcInRvR2xvYmFsU2VtaXRvbmVzOiBcIiwgdG9HbG9iYWxTZW1pdG9uZXMubWFwKHMgPT4gZ1RvbmVTdHJpbmcocykpKTtcblxuICAgIC8vIHRlbnNpb24gKz0gc2FtZU5vdGVzLmxlbmd0aCAqICgxIC8gbm90ZUNvdW50KSAqIC0wLjU7XG4gICAgbG9nZ2VyLmxvZyhcInRlbnNpb246IFwiLCB0ZW5zaW9uKTtcblxuICAgIC8vIElmIHRoZSBub3RlcyBhcmUgbm90IGluIHRoZSBjdXJyZW50IHNjYWxlLCBpbmNyZWFzZSB0aGUgdGVuc2lvblxuICAgIGxldCBub3Rlc05vdEluU2NhbGU6IEFycmF5PG51bWJlcj4gPSBbXVxuICAgIGxldCBuZXdTY2FsZTogTnVsbGFibGU8U2NhbGU+ID0gbnVsbDtcbiAgICBpZiAoY3VycmVudFNjYWxlKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlU2VtaXRvbmVzID0gY3VycmVudFNjYWxlLm5vdGVzLm1hcChub3RlID0+IG5vdGUuc2VtaXRvbmUpO1xuICAgICAgICBub3Rlc05vdEluU2NhbGUgPSB0b1NlbWl0b25lcy5maWx0ZXIoc2VtaXRvbmUgPT4gIXNjYWxlU2VtaXRvbmVzLmluY2x1ZGVzKHNlbWl0b25lKSk7XG4gICAgICAgIGlmIChub3Rlc05vdEluU2NhbGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gUXVpY2sgcmV0dXJuLCB0aGlzIGNob3JkIHN1Y2tzXG4gICAgICAgICAgICByZXR1cm4geyB0ZW5zaW9uLCBuZXdTY2FsZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvZ2dlci5sb2coXCJ0ZW5zaW9uOiBcIiwgdGVuc2lvbik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvR2xvYmFsU2VtaXRvbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgdG9HbG9iYWxTZW1pdG9uZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gTWF0aC5hYnModG9HbG9iYWxTZW1pdG9uZXNbaV0gLSB0b0dsb2JhbFNlbWl0b25lc1tqXSk7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0ZW5zaW9uICs9IDI7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcImludGVydmFsIDEgY2F1c2luZyB0ZW5zaW9uXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPT09IDIpIHtcbiAgICAgICAgICAgICAgICB0ZW5zaW9uICs9IDAuNTtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiaW50ZXJ2YWwgMiBjYXVzaW5nIHRlbnNpb25cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnRlcnZhbCA9PT0gNikge1xuICAgICAgICAgICAgICAgIHRlbnNpb24gKz0gMS41O1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJpbnRlcnZhbCA2IGNhdXNpbmcgdGVuc2lvblwiKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxvZ2dlci5sb2coXCJ0ZW5zaW9uOiBcIiwgdGVuc2lvbik7XG5cbiAgICBpZiAocGFzc2VkRnJvbU5vdGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHRlbnNpb24sIG5ld1NjYWxlIH07XG4gICAgfVxuXG4gICAgaWYgKGludmVyc2lvbk5hbWUuc3RhcnRzV2l0aCgnc2Vjb25kJykgfHwgcHJldkludmVyc2lvbk5hbWUuc3RhcnRzV2l0aCgnc2Vjb25kJykpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGZyb21HbG9iYWxTZW1pdG9uZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb21TZW1pdG9uZSA9IGZyb21HbG9iYWxTZW1pdG9uZXNbaV07XG4gICAgICAgICAgICBjb25zdCB0b1NlbWl0b25lID0gdG9HbG9iYWxTZW1pdG9uZXNbaV07XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZnJvbVNlbWl0b25lIC0gdG9TZW1pdG9uZSkgPiAyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIkNhbid0IGhhdmUgYSBqdW1wIGluIHNlY29uZCBpbnZlcnNpb25cIik7XG4gICAgICAgICAgICAgICAgdGVuc2lvbiArPSAxMDA7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcInRlbnNpb246IFwiLCB0ZW5zaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlbWl0b25lU2NhbGVJbmRleDogeyBba2V5OiBudW1iZXJdOiBudW1iZXIgfSA9IHtcbiAgICAgICAgW2N1cnJlbnRTY2FsZS5ub3Rlc1swXS5zZW1pdG9uZV06IDAsXG4gICAgICAgIFtjdXJyZW50U2NhbGUubm90ZXNbMV0uc2VtaXRvbmVdOiAxLFxuICAgICAgICBbY3VycmVudFNjYWxlLm5vdGVzWzJdLnNlbWl0b25lXTogMixcbiAgICAgICAgW2N1cnJlbnRTY2FsZS5ub3Rlc1szXS5zZW1pdG9uZV06IDMsXG4gICAgICAgIFtjdXJyZW50U2NhbGUubm90ZXNbNF0uc2VtaXRvbmVdOiA0LFxuICAgICAgICBbY3VycmVudFNjYWxlLm5vdGVzWzVdLnNlbWl0b25lXTogNSxcbiAgICAgICAgW2N1cnJlbnRTY2FsZS5ub3Rlc1s2XS5zZW1pdG9uZV06IDYsXG4gICAgfVxuXG5cbiAgICAvLyBNYWpvciAvIE1pbm9yXG4gICAgLy8gQyAwOiBUb25pY1xuICAgIC8vIEQgMTogU3ViRG9taW5hbnRcbiAgICAvLyBFIDI6IFRvbmljXG4gICAgLy8gRiAzOiBTdWJEb21pbmFudFxuICAgIC8vIEcgNDogRG9taW5hbnRcbiAgICAvLyBBIDU6IFRvbmljXG4gICAgLy8gQiA2OiBEb21pbmFudFxuXG4gICAgLy8gSSBub3RlczpcbiAgICAvLyAwLCAyLCA0XG4gICAgLy8gaWkgbm90ZXM6XG4gICAgLy8gMSwgMywgNVxuICAgIC8vIGlpaSBub3RlczpcbiAgICAvLyAyLCA0LCA2XG4gICAgLy8gSVYgbm90ZXM6XG4gICAgLy8gMywgNSwgMFxuICAgIC8vIFYgbm90ZXM6XG4gICAgLy8gNCwgNiwgMVxuICAgIC8vIHZpIG5vdGVzOlxuICAgIC8vIDUsIDAsIDJcbiAgICAvLyB2aWlvIG5vdGVzOlxuICAgIC8vIDYsIDEsIDNcblxuICAgIC8vIC0+IFRvbmljIG5vdGVzID0gICAgICAgMCwgICAgMiwgICAgNFxuICAgIC8vIC0+IFN1YkRvbWluYW50IG5vdGVzID0gMCwgMSwgICAgMywgICAgNVxuICAgIC8vIC0+IERvbWluYW50IG5vdGVzID0gICAgICAgMSwgICAgMywgNCwgICA2XG5cbiAgICAvLyBVc2UgcmVsYXRpdmUgZGlmZnMgaGVyZSBmb3IgZWFzeSBjb21wYXJpc29uXG4gICAgbGV0IGNob3JkTGVhZHM6IHsgW2tleTogbnVtYmVyXTogeyBba2V5OiBudW1iZXJdOiBudW1iZXIgfSB9ID0ge1xuICAgICAgICAwOiB7ICAvLyBDXG4gICAgICAgICAgICBbLTFdOiAwLFxuICAgICAgICAgICAgMDogMSxcbiAgICAgICAgICAgIDE6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIDE6IHsgIC8vIERcbiAgICAgICAgICAgIFstMV06IDEsXG4gICAgICAgICAgICAwOiAtMC41LFxuICAgICAgICAgICAgMTogMC41LFxuICAgICAgICB9LFxuICAgICAgICAyOiB7ICAvLyBFXG4gICAgICAgICAgICBbLTFdOiAwLFxuICAgICAgICAgICAgMDogMSxcbiAgICAgICAgICAgIDE6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIDM6IHsgIC8vIEZcbiAgICAgICAgICAgIFstMV06IDEsXG4gICAgICAgICAgICAwOiAtMC41LFxuICAgICAgICAgICAgMTogMC41LFxuICAgICAgICB9LFxuICAgICAgICA0OiB7ICAvLyBHXG4gICAgICAgICAgICBbLTFdOiAwLFxuICAgICAgICAgICAgMDogMSxcbiAgICAgICAgICAgIDE6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIDU6IHsgIC8vIEFcbiAgICAgICAgICAgIFstMV06IDEsXG4gICAgICAgICAgICAwOiAtMC41LFxuICAgICAgICAgICAgMTogMCxcbiAgICAgICAgfSxcbiAgICAgICAgNjogeyAgLy8gQlxuICAgICAgICAgICAgWy0xXTogMCxcbiAgICAgICAgICAgIDA6IC0xLFxuICAgICAgICAgICAgMTogMixcbiAgICAgICAgfSxcbiAgICB9XG5cbiAgICBsZXQgdGVuc2lvbkJlZm9yZWxlYWQgPSB0ZW5zaW9uO1xuICAgIGNvbnN0IHJlc29sdmVkTGVhZHM6IHsgW2tleTogbnVtYmVyXTogbnVtYmVyIH0gPSB7fTtcbiAgICBsZXQgYXZhaWxhYmxlTGVhZHM6IHsgW2tleTogbnVtYmVyXTogeyBba2V5OiBudW1iZXJdOiBudW1iZXIgfSB9ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGZyb21HbG9iYWxTZW1pdG9uZSBvZiBmcm9tR2xvYmFsU2VtaXRvbmVzKSB7XG4gICAgICAgIC8vIEVhY2ggbm90ZSBtYXkgYmUgXCJsZWFkaW5nXCIgc29tZXdoZXJlLlxuICAgICAgICBjb25zdCBmcm9tU2VtaXRvbmUgPSAoZnJvbUdsb2JhbFNlbWl0b25lICsgMTIpICUgMTI7XG4gICAgICAgIGNvbnN0IHNjYWxlSW5kZXg6IG51bWJlciA9IHNlbWl0b25lU2NhbGVJbmRleFtmcm9tU2VtaXRvbmVdO1xuICAgICAgICBpZiAoc2NhbGVJbmRleCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE91dCBvZiBzY2FsZS4gVGhpcyBub3RlIGxlYWRzIHRvIDEgc2VtaXRvbmUgdXAgb3IgZG93blxuICAgICAgICAgICAgcmVzb2x2ZWRMZWFkc1tmcm9tR2xvYmFsU2VtaXRvbmUgKyAxXSA9IDE7XG4gICAgICAgICAgICByZXNvbHZlZExlYWRzW2Zyb21HbG9iYWxTZW1pdG9uZSAtIDFdID0gMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlYWRzVG86IHsgW2tleTogbnVtYmVyXTogbnVtYmVyIH0gPSAgY2hvcmRMZWFkc1tzY2FsZUluZGV4XTtcbiAgICAgICAgYXZhaWxhYmxlTGVhZHNbc2NhbGVJbmRleF0gPSBjaG9yZExlYWRzW3NjYWxlSW5kZXhdO1xuXG4gICAgICAgIGZvciAoY29uc3QgcmVsYXRpdmVEaWZmIGluIGxlYWRzVG8pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlRGlmZk51bSA9IHBhcnNlSW50KHJlbGF0aXZlRGlmZik7XG4gICAgICAgICAgICBjb25zdCBuZXh0U2NhbGVJbmRleCA9IChzY2FsZUluZGV4ICsgcmVsYXRpdmVEaWZmTnVtICsgNykgJSA3O1xuICAgICAgICAgICAgbGV0IHNlbWl0b25lRGlmZiA9IHNlbWl0b25lRGlzdGFuY2UoY3VycmVudFNjYWxlLm5vdGVzW25leHRTY2FsZUluZGV4XS5zZW1pdG9uZSwgZnJvbVNlbWl0b25lKTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZURpZmZOdW0gPCAwKSB7XG4gICAgICAgICAgICAgICAgc2VtaXRvbmVEaWZmID0gLXNlbWl0b25lRGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHRHVG9uZSA9IGZyb21HbG9iYWxTZW1pdG9uZSArIHNlbWl0b25lRGlmZlxuICAgICAgICAgICAgcmVzb2x2ZWRMZWFkc1tuZXh0R1RvbmVdID0gcmVzb2x2ZWRMZWFkc1tuZXh0R1RvbmVdIHx8IDBcbiAgICAgICAgICAgIHJlc29sdmVkTGVhZHNbbmV4dEdUb25lXSArPSBsZWFkc1RvW3JlbGF0aXZlRGlmZl07XG5cbiAgICAgICAgICAgIC8vIC8vIEFkZCBsZWFkcyB0byBhbGwgb2N0YXZlc1xuICAgICAgICAgICAgLy8gZm9yIChsZXQgaT0tMTIqNTsgaTwxMio1OyBpKz0xMikge1xuICAgICAgICAgICAgLy8gICAgIHJlc29sdmVkTGVhZHNbbmV4dEdUb25lK2ldID0gcmVzb2x2ZWRMZWFkc1tuZXh0R1RvbmUraV0gfHwgMFxuICAgICAgICAgICAgLy8gICAgIHJlc29sdmVkTGVhZHNbbmV4dEdUb25lK2ldICs9IGxlYWRzVG9bcmVsYXRpdmVEaWZmXTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvZ2dlci5sb2coXG4gICAgICAgIFwiYXZhaWxhYmxlTGVhZHM6IFwiLCBhdmFpbGFibGVMZWFkcyxcbiAgICAgICAgXCJjaG9yZHM6IFwiLCBmcm9tU2VtaXRvbmVzLm1hcChzID0+IHNlbWl0b25lU2NhbGVJbmRleFtzXSksIFwiIC0gXCIsXG4gICAgICAgIHRvU2VtaXRvbmVzLm1hcChzID0+IHNlbWl0b25lU2NhbGVJbmRleFtzXSksXG4gICAgICAgIFwiIC0gcmVzb2x2ZWRMZWFkczogXCIsIHJlc29sdmVkTGVhZHMsXG4gICAgKVxuXG4gICAgY29uc3QgaGFuZGxlZFNlbWl0b25lczogbnVtYmVyW10gPSBbXVxuICAgIGZvciAoY29uc3QgdG9HbG9iYWxTZW1pdG9uZSBvZiB0b0dsb2JhbFNlbWl0b25lcykge1xuICAgICAgICBjb25zdCB0b1NlbWl0b25lID0gKHRvR2xvYmFsU2VtaXRvbmUgKyAxMikgJSAxMjtcbiAgICAgICAgaWYgKGhhbmRsZWRTZW1pdG9uZXMuaW5jbHVkZXModG9TZW1pdG9uZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZWRTZW1pdG9uZXMucHVzaCh0b1NlbWl0b25lKTtcblxuICAgICAgICBjb25zdCBzY2FsZUluZGV4OiBudW1iZXIgPSBzZW1pdG9uZVNjYWxlSW5kZXhbdG9TZW1pdG9uZV07XG5cbiAgICAgICAgaWYgKHdhbnRlZEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgd2FudGVkU2NhbGVJbmRleGVzO1xuICAgICAgICAgICAgaWYgKHdhbnRlZEZ1bmN0aW9uID09IFwic3ViLWRvbWluYW50XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBNb2RpZnkgd2VpZ2h0cyBzbyB0aGF0IGFsbCBsZWFkIHRvIHN1YmRvbWluYW50cyAoMCwgMSwgMywgNSlcbiAgICAgICAgICAgICAgICB3YW50ZWRTY2FsZUluZGV4ZXMgPSBbMCwgMSwgMywgNV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FudGVkRnVuY3Rpb24gPT0gXCJkb21pbmFudFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gTW9kaWZ5IHdlaWdodHMgc28gdGhhdCBhbGwgbGVhZCB0byBkb21pbmFudHMgKDEsIDMsIDQsIDYpXG4gICAgICAgICAgICAgICAgd2FudGVkU2NhbGVJbmRleGVzID0gWzEsIDMsIDQsIDZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdhbnRlZEZ1bmN0aW9uID09IFwidG9uaWNcIikge1xuICAgICAgICAgICAgICAgIC8vIE1vZGlmeSB3ZWlnaHRzIHNvIHRoYXQgYWxsIGxlYWQgdG8gdG9uaWMgKDAsIDIsIDQpXG4gICAgICAgICAgICAgICAgd2FudGVkU2NhbGVJbmRleGVzID0gWzAsIDIsIDRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAod2FudGVkU2NhbGVJbmRleGVzLmluZGV4T2YocGFyc2VJbnQoc2NhbGVJbmRleCBhcyBhbnkpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0ZW5zaW9uICs9IDI7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlRlbnNpb24gZnJvbSB3YW50ZWQgZnVuY3Rpb246IFwiLCBzY2FsZUluZGV4LCBcIiA6IFwiLCB3YW50ZWRGdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGJlYXRzVW50aWxMYXN0Q2hvcmRJblNvbmcgPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbnNpb24gKz0gNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbnNpb24gLT0gMTtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiUmVkdWNlZCB0ZW5zaW9uIGZyb20gd2FudGVkIGZ1bmN0aW9uOiBcIiwgc2NhbGVJbmRleCwgXCIgOiBcIiwgd2FudGVkRnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGVhZHNUbzogeyBba2V5OiBudW1iZXJdOiBudW1iZXIgfSA9IGF2YWlsYWJsZUxlYWRzW3NjYWxlSW5kZXhdO1xuICAgICAgICBpZiAobGVhZHNUbyAmJiBsZWFkc1RvWzBdKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG5vdGUgaXMgbGVhZGluZyB0byBpdHNlbGYsIHdpdGggc29tZSB0ZW5zaW9uLlxuICAgICAgICAgICAgdGVuc2lvbiAtPSBsZWFkc1RvWzBdO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlRlbnNpb24gZnJvbSBsZWFkIHRvIGl0c2VsZjogXCIsIHNjYWxlSW5kZXgsIC1sZWFkc1RvWzBdLCBcIiA6IFwiLCB3YW50ZWRGdW5jdGlvbik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNvbHZlZExlYWRzW3RvR2xvYmFsU2VtaXRvbmVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRlbnNpb24gLT0gcmVzb2x2ZWRMZWFkc1t0b0dsb2JhbFNlbWl0b25lXSAqIHBhcmFtcy5sZWFkaW5nV2VpZ2h0O1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlRlbnNpb24gZnJvbSBsZWFkOiBcIiwgdG9HbG9iYWxTZW1pdG9uZSwgLXJlc29sdmVkTGVhZHNbdG9HbG9iYWxTZW1pdG9uZV0sIFwiIDogXCIsIHdhbnRlZEZ1bmN0aW9uKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gICAgbG9nZ2VyLmxvZyhcInRlbnNpb246IFwiLCB0ZW5zaW9uKTtcbiAgICBjb25zdCBsZWFkaW5nVG9uZVNlbWl0b25lID0gY3VycmVudFNjYWxlLm5vdGVzWzBdLnNlbWl0b25lICsgMTE7XG4gICAgZm9yIChsZXQgaT0wOyBpPGZyb21HbG9iYWxTZW1pdG9uZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZnJvbUdsb2JhbFNlbWl0b25lID0gZnJvbUdsb2JhbFNlbWl0b25lc1tpXTtcbiAgICAgICAgaWYgKGZyb21HbG9iYWxTZW1pdG9uZSAlIDEyID09IGxlYWRpbmdUb25lU2VtaXRvbmUpIHtcbiAgICAgICAgICAgIGlmICh0b0dsb2JhbFNlbWl0b25lc1tpXSAhPSBmcm9tR2xvYmFsU2VtaXRvbmUgKyAxKSB7XG4gICAgICAgICAgICAgICAgdGVuc2lvbiArPSAxMDtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAxIHx8IGkgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3QgYXMgYmFkXG4gICAgICAgICAgICAgICAgICAgIHRlbnNpb24gLT0gNztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIkxlYWRpbmcgdG9uZSBub3QgaGFuZGxlZCwgaW5jcmVhc2luZyB0ZW5zaW9uOiBwYXJ0IFwiLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2dnZXIubG9nKFwidGVuc2lvbjogXCIsIHRlbnNpb24pO1xuXG4gICAgbGV0IGxlYWRpbmdUb25lQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgdG9HbG9iYWxTZW1pdG9uZSBvZiB0b0dsb2JhbFNlbWl0b25lcykge1xuICAgICAgICBjb25zdCBzY2FsZUluZGV4OiBudW1iZXIgPSBzZW1pdG9uZVNjYWxlSW5kZXhbKHRvR2xvYmFsU2VtaXRvbmUgKyAxMikgJSAxMl07XG4gICAgICAgIGlmIChzY2FsZUluZGV4ID09IDYpIHtcbiAgICAgICAgICAgIGxlYWRpbmdUb25lQ291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVhZGluZ1RvbmVDb3VudCA+IDEpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIk11bHRpcGxlIGxlYWRpbmcgdG9uZXMsIGluY3JlYXNpbmcgdGVuc2lvbjogXCIsIGxlYWRpbmdUb25lQ291bnQpO1xuICAgICAgICB0ZW5zaW9uICs9IDEwO1xuICAgIH1cblxuICAgIGlmICh0ZW5zaW9uID4gMTApIHtcbiAgICAgICAgcmV0dXJuIHt0ZW5zaW9uLCBjdXJyZW50U2NhbGV9XG4gICAgfVxuXG4gICAgY29uc3QgZGlyZWN0aW9uVGVuc2lvbldlaWdodCA9IHdhbnRlZEZ1bmN0aW9uID09IG51bGwgPyAxOiAwLjE7XG4gICAgLy8gQ2hlY2sgZGlyZWN0aW9uc1xuICAgIGNvbnN0IGRpcmVjdGlvbkNvdW50cyA9IHtcbiAgICAgICAgXCJ1cFwiOiAwLFxuICAgICAgICBcImRvd25cIjogMCxcbiAgICAgICAgXCJzYW1lXCI6IDAsXG4gICAgfVxuICAgIGxldCByb290QmFzc0RpcmVjdGlvbiA9IG51bGw7XG4gICAgZm9yIChsZXQgaT0wOyBpPGZyb21HbG9iYWxTZW1pdG9uZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZnJvbVNlbWl0b25lID0gZnJvbUdsb2JhbFNlbWl0b25lc1tpXTtcbiAgICAgICAgY29uc3QgdG9TZW1pdG9uZSA9IHRvR2xvYmFsU2VtaXRvbmVzW2ldO1xuICAgICAgICBjb25zdCBkaWZmID0gdG9TZW1pdG9uZSAtIGZyb21TZW1pdG9uZTtcbiAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb25Db3VudHMudXAgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbkNvdW50cy5kb3duICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpZmYgPT0gMCkge1xuICAgICAgICAgICAgZGlyZWN0aW9uQ291bnRzLnNhbWUgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlmZiAhPSAwICYmIGludmVyc2lvbk5hbWUuc3RhcnRzV2l0aCgncm9vdCcpKSB7XG4gICAgICAgICAgICByb290QmFzc0RpcmVjdGlvbiA9IGRpZmYgPiAwID8gJ3VwJyA6ICdkb3duJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSb290IGJhc3MgbWFrZXMgdXAgZm9yIG9uZSB1cC9kb3duXG4gICAgaWYgKHJvb3RCYXNzRGlyZWN0aW9uID09IFwidXBcIiAmJiBkaXJlY3Rpb25Db3VudHMuZG93biA+IDApIHtcbiAgICAgICAgZGlyZWN0aW9uQ291bnRzLmRvd24gLT0gMTtcbiAgICB9XG4gICAgaWYgKHJvb3RCYXNzRGlyZWN0aW9uID09IFwiZG93blwiICYmIGRpcmVjdGlvbkNvdW50cy51cCA+IDApIHtcbiAgICAgICAgZGlyZWN0aW9uQ291bnRzLnVwIC09IDE7XG4gICAgfVxuICAgIGxvZ2dlci5sb2coXCJyb290QmFzc0RpcmVjdGlvbjogXCIsIHJvb3RCYXNzRGlyZWN0aW9uLCBcIiAtIGRpcmVjdGlvbkNvdW50czogXCIsIGRpcmVjdGlvbkNvdW50cyk7XG4gICAgaWYgKGRpcmVjdGlvbkNvdW50cy51cCA+IDIgJiYgZGlyZWN0aW9uQ291bnRzLmRvd24gPCAxKSB7XG4gICAgICAgIHRlbnNpb24gKz0gMTAgKiBkaXJlY3Rpb25UZW5zaW9uV2VpZ2h0O1xuICAgICAgICBsb2dnZXIubG9nKFwiVGVuc2lvbiBmcm9tIGRpcmVjdGlvbiB1cDogXCIsIGRpcmVjdGlvbkNvdW50cyk7XG4gICAgICAgIGxvZ2dlci5sb2coXCJ0ZW5zaW9uOiBcIiwgdGVuc2lvbik7XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb25Db3VudHMuZG93biA+IDIgJiYgZGlyZWN0aW9uQ291bnRzLnVwIDwgMSkge1xuICAgICAgICB0ZW5zaW9uICs9IDEwICogZGlyZWN0aW9uVGVuc2lvbldlaWdodDtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIlRlbnNpb24gZnJvbSBkaXJlY3Rpb24gZG93bjogXCIsIGRpcmVjdGlvbkNvdW50cyk7XG4gICAgICAgIGxvZ2dlci5sb2coXCJ0ZW5zaW9uOiBcIiwgdGVuc2lvbik7XG4gICAgfVxuXG4gICAgaWYgKHRlbnNpb24gPiAxMCkge1xuICAgICAgICByZXR1cm4ge3RlbnNpb24sIGN1cnJlbnRTY2FsZX1cbiAgICB9XG5cblxuICAgIC8vIFBhcmFsbGVsIG1vdGlvbiBhbmQgaGlkZGVuIGZpZnRoc1xuICAgIGZvciAobGV0IGk9MDsgaTx0b0dsb2JhbFNlbWl0b25lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqPWkrMTsgajx0b0dsb2JhbFNlbWl0b25lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGZyb21HbG9iYWxTZW1pdG9uZXNbaV0gPT0gdG9HbG9iYWxTZW1pdG9uZXNbaV0gJiYgZnJvbUdsb2JhbFNlbWl0b25lc1tqXSA9PSB0b0dsb2JhbFNlbWl0b25lc1tqXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBNYXRoLmFicyh0b0dsb2JhbFNlbWl0b25lc1tpXSAtIHRvR2xvYmFsU2VtaXRvbmVzW2pdKTtcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsRnJvbSA9IE1hdGguYWJzKGZyb21HbG9iYWxTZW1pdG9uZXNbaV0gLSBmcm9tR2xvYmFsU2VtaXRvbmVzW2pdKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnZhbCA8IDIwICYmIGludGVydmFsICUgMTIgPT0gNyB8fCBpbnRlcnZhbCAlIDEyID09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBQb3NzaWJseSBhIHBhcmFsbGVsLCBjb250cmFyeSBvciBoaWRkZW4gZmlmdGgvb2N0YXZlXG4gICAgICAgICAgICAgICAgaWYgKGludGVydmFsID09IGludGVydmFsRnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uICs9IDEwO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiVGVuc2lvbiBmcm9tIHBhcmFsbGVsIG1vdGlvbjogXCIsIGludGVydmFsLCBcIiBwYXJ0IFwiLCBpLCBcIiBhbmQgXCIsIGopO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwidGVuc2lvbjogXCIsIHRlbnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGludGVydmFsIGlzIGhpZGRlblxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRJRGlyZWN0aW9uID0gZnJvbUdsb2JhbFNlbWl0b25lc1tpXSAtIHRvR2xvYmFsU2VtaXRvbmVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRKRGlyZWN0aW9uID0gZnJvbUdsb2JhbFNlbWl0b25lc1tqXSAtIHRvR2xvYmFsU2VtaXRvbmVzW2pdO1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhwYXJ0SkRpcmVjdGlvbikgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwcGVyIHBhcnQgaXMgbWFraW5nIGEganVtcFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydElEaXJlY3Rpb24gPCAwICYmIHBhcnRKRGlyZWN0aW9uIDwgMCB8fCBwYXJ0SURpcmVjdGlvbiA+IDAgJiYgcGFydEpEaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uICs9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlRlbnNpb24gZnJvbSBoaWRkZW4gZmlmdGg6IFwiLCBpbnRlcnZhbCwgXCIgcGFydCBcIiwgaSwgXCIgYW5kIFwiLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJ0ZW5zaW9uOiBcIiwgdGVuc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVuc2lvbiA+IDEwKSB7XG4gICAgICAgIHJldHVybiB7dGVuc2lvbiwgY3VycmVudFNjYWxlfVxuICAgIH1cblxuXG4gICAgLy8gU3BhY2luZyBlcnJvcnNcbiAgICBjb25zdCBwYXJ0MFRvUGFydDEgPSBNYXRoLmFicyh0b0dsb2JhbFNlbWl0b25lc1swXSAtIHRvR2xvYmFsU2VtaXRvbmVzWzFdKTtcbiAgICBjb25zdCBwYXJ0MVRvUGFydDIgPSBNYXRoLmFicyh0b0dsb2JhbFNlbWl0b25lc1sxXSAtIHRvR2xvYmFsU2VtaXRvbmVzWzJdKTtcbiAgICBjb25zdCBwYXJ0MlRvUGFydDMgPSBNYXRoLmFicyh0b0dsb2JhbFNlbWl0b25lc1syXSAtIHRvR2xvYmFsU2VtaXRvbmVzWzNdKTtcbiAgICBpZiAocGFydDFUb1BhcnQyID4gMTIgfHwgcGFydDBUb1BhcnQxID4gMTIgfHwgcGFydDJUb1BhcnQzID4gKDEyICsgNykpIHtcbiAgICAgICAgdGVuc2lvbiArPSAxMDtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIlRlbnNpb24gZnJvbSBzcGFjaW5nIGVycm9yOiBcIiwgcGFydDBUb1BhcnQxLCBwYXJ0MVRvUGFydDIsIHBhcnQyVG9QYXJ0Myk7XG4gICAgICAgIGxvZ2dlci5sb2coXCJ0ZW5zaW9uOiBcIiwgdGVuc2lvbik7XG4gICAgfVxuICAgIGlmICh0ZW5zaW9uID4gMTApIHtcbiAgICAgICAgcmV0dXJuIHt0ZW5zaW9uLCBjdXJyZW50U2NhbGV9XG4gICAgfVxuXG4gICAgLy8gT3ZlcmxhcHBpbmcgZXJyb3JcbiAgICBmb3IgKGxldCBpPTA7IGk8ZnJvbUdsb2JhbFNlbWl0b25lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmcm9tR2xvYmFsU2VtaXRvbmUgPSBmcm9tR2xvYmFsU2VtaXRvbmVzW2ldO1xuICAgICAgICBjb25zdCB1cHBlclBhcnRUb0dsb2JhbFNlbWl0b25lID0gdG9HbG9iYWxTZW1pdG9uZXNbaS0xXTtcbiAgICAgICAgY29uc3QgbG93ZXJQYXJ0VG9HbG9iYWxTZW1pdG9uZSA9IHRvR2xvYmFsU2VtaXRvbmVzW2krMV07XG4gICAgICAgIGlmICh1cHBlclBhcnRUb0dsb2JhbFNlbWl0b25lICE9IHVuZGVmaW5lZCAmJiBmcm9tR2xvYmFsU2VtaXRvbmUgPiB1cHBlclBhcnRUb0dsb2JhbFNlbWl0b25lKSB7XG4gICAgICAgICAgICAvLyBVcHBlciBwYXJ0IGlzIG1vdmluZyBsb3dlciB0aGFuIHdoZXJlIGxvd2VyIHBhcnQgdXNlZCB0byBiZVxuICAgICAgICAgICAgdGVuc2lvbiArPSAxMDtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJUZW5zaW9uIGZyb20gb3ZlcmxhcHBpbmcgZXJyb3I6IFwiLCBnVG9uZVN0cmluZyhmcm9tR2xvYmFsU2VtaXRvbmUpLCBnVG9uZVN0cmluZyh1cHBlclBhcnRUb0dsb2JhbFNlbWl0b25lKSk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwidGVuc2lvbjogXCIsIHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dlclBhcnRUb0dsb2JhbFNlbWl0b25lICE9IHVuZGVmaW5lZCAmJiBmcm9tR2xvYmFsU2VtaXRvbmUgPCBsb3dlclBhcnRUb0dsb2JhbFNlbWl0b25lKSB7XG4gICAgICAgICAgICAvLyBMb3dlciBwYXJ0IGlzIG1vdmluZyBoaWdoZXIgdGhhbiB3aGVyZSB1cHBlciBwYXJ0IHVzZWQgdG8gYmVcbiAgICAgICAgICAgIHRlbnNpb24gKz0gMTA7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiVGVuc2lvbiBmcm9tIG92ZXJsYXBwaW5nIGVycm9yOiBcIiwgZ1RvbmVTdHJpbmcoZnJvbUdsb2JhbFNlbWl0b25lKSwgZ1RvbmVTdHJpbmcobG93ZXJQYXJ0VG9HbG9iYWxTZW1pdG9uZSkpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcInRlbnNpb246IFwiLCB0ZW5zaW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTWVsb2R5IHRlbnNpb25cbiAgICAvLyBBdm9pZCBqdW1wcyB0aGF0IGFyZSBhdWcgb3IgN3RoIG9yIGhpZ2hlclxuICAgIGZvciAobGV0IGk9MDsgaTxmcm9tR2xvYmFsU2VtaXRvbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGludGVydmFsID0gTWF0aC5hYnMoZnJvbUdsb2JhbFNlbWl0b25lc1tpXSAtIHRvR2xvYmFsU2VtaXRvbmVzW2ldKTtcbiAgICAgICAgaWYgKGludGVydmFsID49IDMpIHtcbiAgICAgICAgICAgIHRlbnNpb24gKz0gMC4yO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlRlbnNpb24gZnJvbSBtZWxvZHkganVtcDogXCIsIGludGVydmFsKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJ0ZW5zaW9uOiBcIiwgdGVuc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVydmFsID49IDEwKSB7ICAvLyA3dGggPT0gMTBcbiAgICAgICAgICAgIHRlbnNpb24gKz0gMTA7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiVGVuc2lvbiBmcm9tIG1lbG9keSBpbnRlcnZhbDogXCIsIGludGVydmFsKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJ0ZW5zaW9uOiBcIiwgdGVuc2lvbik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJ2YWwgPT0gNiB8fCBpbnRlcnZhbCA9PSA4KSAvLyB0cml0b25lIChhdWcgNHRoKSBvciBhdWcgNXRoXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRlbnNpb24gKz0gNTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJUZW5zaW9uIGZyb20gbWVsb2R5IGludGVydmFsOiBcIiwgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcInRlbnNpb246IFwiLCB0ZW5zaW9uKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnZhbCA9PSA3KSB7XG4gICAgICAgICAgICB0ZW5zaW9uICs9IDE7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiVGVuc2lvbiBmcm9tIG1lbG9keSBpbnRlcnZhbDogXCIsIGludGVydmFsKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJ0ZW5zaW9uOiBcIiwgdGVuc2lvbik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJ2YWwgPT0gOSkge1xuICAgICAgICAgICAgdGVuc2lvbiArPSAyO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlRlbnNpb24gZnJvbSBtZWxvZHkgaW50ZXJ2YWw6IFwiLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwidGVuc2lvbjogXCIsIHRlbnNpb24pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlbnNpb24gPiAxMCkge1xuICAgICAgICByZXR1cm4ge3RlbnNpb24sIGN1cnJlbnRTY2FsZX1cbiAgICB9XG5cblxuICAgIC8vIDAgcHJpaW1pXG4gICAgLy8gMSBwaWVuaSBzZWt1bnRpXG4gICAgLy8gMiBzdXVyaSBzZWt1bnRpXG4gICAgLy8gMyBwaWVuaSB0ZXJzc2lcbiAgICAvLyA0IHN1dXJpIHRlcnNzaVxuICAgIC8vIDUga3ZhcnR0aVxuICAgIC8vIDYgdHJpdG9udXNcbiAgICAvLyA3IGt2aW50dGlcbiAgICAvLyA4IHBpZW5pIHNla3N0aVxuICAgIC8vIDkgc3V1cmkgc2Vrc3RpXG4gICAgLy8gMTAgcGllbmkgc2VwdGltaVxuICAgIC8vIDExIHN1dXJpIHNlcHRpbWlcbiAgICAvLyAxMiBva3RhYXZpXG5cbiAgICAvLyBXYXMgdGhlcmUgYSBqdW1wIGJlZm9yZT9cbiAgICBpZiAocHJldlBhc3NlZEZyb21Ob3RlcyAmJiBwcmV2UGFzc2VkRnJvbU5vdGVzLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgIGNvbnN0IHByZXZGcm9tR2xvYmFsU2VtaXRvbmVzID0gcHJldlBhc3NlZEZyb21Ob3Rlcy5tYXAoKG4pID0+IGdsb2JhbFNlbWl0b25lKG4pKTtcbiAgICAgICAgbG9nZ2VyLmxvZyhcInByZXZGcm9tR2xvYmFsU2VtaXRvbmVzOlwiLCBwcmV2RnJvbUdsb2JhbFNlbWl0b25lcy5tYXAoKHMpID0+IGdUb25lU3RyaW5nKHMpKSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxmcm9tR2xvYmFsU2VtaXRvbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbCA9IE1hdGguYWJzKHByZXZGcm9tR2xvYmFsU2VtaXRvbmVzW2ldIC0gZnJvbUdsb2JhbFNlbWl0b25lc1tpXSk7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPj0gMykge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIHdhcyBhIGp1bXAuIFdFIE1VU1QgR08gQkFDSyFcbiAgICAgICAgICAgICAgICAvLyBCYXNpY2FsbHkgdGhlIHRvR2xvYmFsU2VtaXRvbmUgbXVzdCBiZSBiZXR3ZWVuIHRoZSBwcmV2RnJvbUdsb2JhbFNlbWl0b25lIGFuZCB0aGUgZnJvbUdsb2JhbFNlbWl0b25lXG4gICAgICAgICAgICAgICAgLy8gVU5MRVNTIHdlJ3JlIG91dGxpbmluZyBhIHRyaWFkLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgd291bGQgbWVhbiB0aGF0IGFmdGVyIGEgNHRoIHVwLCB3ZSBuZWVkIHRvIGdvIHVwIGFub3RoZXIgM3JkXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkZyb21TZW1pdG9uZSA9IHByZXZGcm9tR2xvYmFsU2VtaXRvbmVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyb21TZW1pdG9uZSA9IGZyb21HbG9iYWxTZW1pdG9uZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgdG9TZW1pdG9uZSA9IHRvR2xvYmFsU2VtaXRvbmVzW2ldO1xuICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbk11bHRpcGxpZXIgPSBmcm9tU2VtaXRvbmUgPiBwcmV2RnJvbVNlbWl0b25lID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJbnRlcnZhbCA9IGRpcmVjdGlvbk11bHRpcGxpZXIgKiAodG9TZW1pdG9uZSAtIGZyb21TZW1pdG9uZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEludGVydmFsID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pbm9yIDNyZCB1cCwgdGhlbiBtYWogdGhpcmQgdXAuIFRoYXQncyBhIHJvb3QgaW52ZXJzaW9uIG1pbm9yIGNob3JkIVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRJbnRlcnZhbCA9PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtaW5vciAzcmQgdXAsIHRoZW4gcGVyZmVjdCA0dGggdXAuIFRoYXQncyBhIGZpcnN0IGludmVyc2lvbiBtYWpvciBjaG9yZCFcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnZhbCA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0SW50ZXJ2YWwgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFqb3IgM3JkIHVwLCB0aGVuIG1pbm9yIDNyZCB1cC4gVGhhdCdzIGEgcm9vdCBpbnZlcnNpb24gbWFqb3IgY2hvcmQhXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEludGVydmFsID09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ham9yIDNyZCB1cCwgdGhlbiBwZXJmZWN0IDR0aCB1cC4gVGhhdCdzIGEgZmlyc3QgaW52ZXJzaW9uIG1pbm9yIGNob3JkIVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGludGVydmFsID09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRJbnRlcnZhbCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwZXJmZWN0IDR0aCB1cCwgdGhlbiBtaW5vciAzcmQgdXAuIFRoYXQncyBhIHNlY29uZCBpbnZlcnNpb24gbWlub3IgY2hvcmQhXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEludGVydmFsID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBlcmZlY3QgNHRoIHVwLCB0aGVuIG1ham9yIDNyZCB1cC4gVGhhdCdzIGEgc2Vjb25kIGludmVyc2lvbiBtYWpvciBjaG9yZCFcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSGlnaGVyIHRoYW4gdGhhdCwgbm8gdHJpYWQgaXMgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgaWYgKChmcm9tU2VtaXRvbmUgPj0gcHJldkZyb21TZW1pdG9uZSAmJiB0b1NlbWl0b25lID49IGZyb21TZW1pdG9uZSkgfHwgKGZyb21TZW1pdG9uZSA8PSBwcmV2RnJvbVNlbWl0b25lICYmIHRvU2VtaXRvbmUgPD0gZnJvbVNlbWl0b25lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgZ29pbmYgYmFjayBkb3duL3VwLi4uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnZhbCA8PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uICs9IDAuMjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnRlcnZhbCA8PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uICs9IDE7ICAvLyBOb3QgYXMgYmFkXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uICs9IDEwOyAgLy8gVGVycmlibGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiVGVuc2lvbiBmcm9tIGp1bXAgYW5kIG5vIGJhY2s6IFwiLCBpbnRlcnZhbCwgXCIgcGFydCBcIiwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJ0ZW5zaW9uOiBcIiwgdGVuc2lvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR29pbmcgYmFjayBkb3duL3VwLi4uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhY2tJbnRlcnZhbCA9IE1hdGguYWJzKHRvU2VtaXRvbmUgLSBmcm9tU2VtaXRvbmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFja0ludGVydmFsID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR29pbmcgYmFjayB0b28gZmFyLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPD0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNpb24gKz0gMC4yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlICBpZiAoaW50ZXJ2YWwgPD0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbnNpb24gKz0gMTsgIC8vIE5vdCBhcyBiYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVuc2lvbiArPSAxMDsgIC8vIFRlcnJpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiVGVuc2lvbiBmcm9tIGp1bXAgYW5kIHRvbyBmYXIgYmFjazogXCIsIGludGVydmFsLCBcIiBwYXJ0IFwiLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJ0ZW5zaW9uOiBcIiwgdGVuc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlbnNpb24gPiAxMCkge1xuICAgICAgICByZXR1cm4ge3RlbnNpb24sIGN1cnJlbnRTY2FsZX1cbiAgICB9XG5cblxuICAgIGZvciAobGV0IGk9MDsgaTx0b0dsb2JhbFNlbWl0b25lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmcm9tR2xvYmFsU2VtaXRvbmUgPSBmcm9tR2xvYmFsU2VtaXRvbmVzW2ldO1xuICAgICAgICBjb25zdCB0b0dsb2JhbFNlbWl0b25lID0gdG9HbG9iYWxTZW1pdG9uZXNbaV07XG4gICAgICAgIGxldCBkaXJlY3Rpb24gPSB0b0dsb2JhbFNlbWl0b25lIC0gZnJvbUdsb2JhbFNlbWl0b25lO1xuICAgICAgICBjb25zdCBiYXNlTm90ZSA9IHBhcmFtcy5wYXJ0c1tpXS5ub3RlIHx8IFwiRjRcIjtcbiAgICAgICAgY29uc3Qgc3RhcnRpbmdHbG9iYWxTZW1pdG9uZSA9IGdsb2JhbFNlbWl0b25lKG5ldyBOb3RlKGJhc2VOb3RlKSlcbiAgICAgICAgY29uc3Qgc2VtaXRvbmVMaW1pdCA9IFtzdGFydGluZ0dsb2JhbFNlbWl0b25lICsgLTEyLCBzdGFydGluZ0dsb2JhbFNlbWl0b25lICsgMTJdXG5cbiAgICAgICAgbGV0IHRhcmdldE5vdGUgPSBzZW1pdG9uZUxpbWl0WzFdIC0gNDtcbiAgICAgICAgdGFyZ2V0Tm90ZSAtPSBpICogMjtcblxuICAgICAgICBsZXQgdGFyZ2V0Tm90ZVJlYWNoZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBkaXZpc2lvbiBpbiBkaXZpc2lvbmVkTm90ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdGVzID0gZGl2aXNpb25lZE5vdGVzW2RpdmlzaW9uXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJldk5vdGUgb2Ygbm90ZXMuZmlsdGVyKHJpY2hOb3RlID0+IHJpY2hOb3RlLnBhcnRJbmRleCA9PSBpKSkge1xuICAgICAgICAgICAgICAgIGlmIChnbG9iYWxTZW1pdG9uZShwcmV2Tm90ZS5ub3RlKSA9PSB0YXJnZXROb3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vdGVSZWFjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldE5vdGVSZWFjaGVkKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModG9HbG9iYWxTZW1pdG9uZSAtIHRhcmdldE5vdGUpIDwgMikge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGNsb3NlIHRvIHRoZSB0YXJnZXQgbm90ZSwgbGV0J3MgTk9UIGdvIHRoZXJlIGFueSBtb3JlXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGVuc2lvbiArPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlRlbnNpb24gZnJvbSBhbHJlYWR5IHJlYWNoaW5nIHRhcmdldCBub3RlOiBcIiwgZGlyZWN0aW9uLCBcIiBwYXJ0IFwiLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcInRlbnNpb246IFwiLCB0ZW5zaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbG9nZ2VyLmxvZyhcInRlbnNpb246IFwiLCB0ZW5zaW9uKTtcbiAgICBpZiAodGVuc2lvbiA+IDEwMCkge1xuICAgICAgICAvLyBEb24ndCBldmVuIGxvZyB0aGlzIGNyYXBweSBpbnZlcnNpb25cbiAgICAgICAgbG9nZ2VyLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdGVuc2lvbiwgbmV3U2NhbGUgfTtcbn1cbiIsImltcG9ydCB7IE5vdGUgfSBmcm9tIFwibXVzaWN0aGVvcnlqc1wiO1xuaW1wb3J0IHsgQkVBVF9MRU5HVEgsIERpdmlzaW9uZWRSaWNobm90ZXMsIGdsb2JhbFNlbWl0b25lLCBNYWluTXVzaWNQYXJhbXMsIE11c2ljUGFyYW1zLCBOdWxsYWJsZSB9IGZyb20gXCIuL3V0aWxzXCI7XG5cblxuY29uc3QgYWRkTm90ZUJldHdlZW4gPSAoZGl2aXNpb246IG51bWJlciwgbmV4dERpdmlzaW9uOiBudW1iZXIsIHBhcnRJbmRleDogbnVtYmVyLCBkaXZpc2lvbmVkTm90ZXM6IERpdmlzaW9uZWRSaWNobm90ZXMpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCBkaXZpc2lvbkRpZmYgPSBuZXh0RGl2aXNpb24gLSBkaXZpc2lvbjtcbiAgICBjb25zdCBiZWF0UmljaE5vdGUgPSAoZGl2aXNpb25lZE5vdGVzW2RpdmlzaW9uXSB8fCBbXSkuZmlsdGVyKG5vdGUgPT4gbm90ZS5wYXJ0SW5kZXggPT0gcGFydEluZGV4KVswXTtcbiAgICBpZiAoIWJlYXRSaWNoTm90ZSB8fCAhYmVhdFJpY2hOb3RlLm5vdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZTY2FsZVRvbmVzID0gYmVhdFJpY2hOb3RlLnNjYWxlLm5vdGVzLm1hcChuID0+IG4uc2VtaXRvbmUpO1xuICAgIGNvbnN0IG5leHRCZWF0UmljaE5vdGUgPSAoZGl2aXNpb25lZE5vdGVzW25leHREaXZpc2lvbl0gfHwgW10pLmZpbHRlcihub3RlID0+IG5vdGUucGFydEluZGV4ID09IHBhcnRJbmRleClbMF07XG4gICAgaWYgKCFuZXh0QmVhdFJpY2hOb3RlIHx8ICFuZXh0QmVhdFJpY2hOb3RlLm5vdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZVRvbmVzID0gbmV4dEJlYXRSaWNoTm90ZS5zY2FsZS5ub3Rlcy5tYXAobiA9PiBuLnNlbWl0b25lKS5maWx0ZXIobiA9PiBwcmV2U2NhbGVUb25lcy5pbmNsdWRlcyhuKSk7XG4gICAgY29uc3QgY3VycmVudEdUb25lID0gZ2xvYmFsU2VtaXRvbmUoYmVhdFJpY2hOb3RlLm5vdGUpXG4gICAgY29uc3QgbmV4dEdUb25lID0gZ2xvYmFsU2VtaXRvbmUobmV4dEJlYXRSaWNoTm90ZS5ub3RlKTtcbiAgICBjb25zdCByYW5kb21Ob3RlID0gYmVhdFJpY2hOb3RlLm5vdGUuY29weSgpO1xuXG4gICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKGN1cnJlbnRHVG9uZSAtIG5leHRHVG9uZSk7XG4gICAgaWYgKGRpZmYgPCAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudEdUb25lICE9IG5leHRHVG9uZSkge1xuICAgICAgICBjb25zdCBhdmFpbGFibGVHVG9uZXMgPSBbXVxuICAgICAgICBmb3IgKGxldCBnVG9uZT1jdXJyZW50R1RvbmU7IGdUb25lICE9IG5leHRHVG9uZTsgZ1RvbmUgKz0gKGN1cnJlbnRHVG9uZSA8IG5leHRHVG9uZSA/IDEgOiAtMSkpIHtcbiAgICAgICAgICAgIGlmIChnVG9uZSA9PSBjdXJyZW50R1RvbmUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlbWl0b25lID0gZ1RvbmUgJSAxMjtcbiAgICAgICAgICAgIGlmICghc2NhbGVUb25lcy5pbmNsdWRlcyhzZW1pdG9uZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF2YWlsYWJsZUdUb25lcy5wdXNoKGdUb25lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXZhaWxhYmxlR1RvbmVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBhdmFpbGFibGVHVG9uZXMucHVzaChjdXJyZW50R1RvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKGN1cnJlbnRHVG9uZSwgXCIgLT4gXCIsIG5leHRHVG9uZSwgXCIsIGF2YWlsYWJsZUdUb25lczogXCIsIGF2YWlsYWJsZUdUb25lcywgXCIsIHNjYWxlVG9uZXM6IFwiLCBzY2FsZVRvbmVzKTtcbiAgICAgICAgY29uc3QgcmFuZG9tR1RvbmUgPSBhdmFpbGFibGVHVG9uZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXZhaWxhYmxlR1RvbmVzLmxlbmd0aCldO1xuICAgICAgICByYW5kb21Ob3RlLnNlbWl0b25lID0gcmFuZG9tR1RvbmUgJSAxMjtcbiAgICAgICAgcmFuZG9tTm90ZS5vY3RhdmUgPSBNYXRoLmZsb29yKHJhbmRvbUdUb25lIC8gMTIpO1xuICAgIH1cblxuICAgIGJlYXRSaWNoTm90ZS5kdXJhdGlvbiA9IGRpdmlzaW9uRGlmZiAvIDI7XG4gICAgZGl2aXNpb25lZE5vdGVzW2RpdmlzaW9uICsgZGl2aXNpb25EaWZmIC8gMl0gPSBkaXZpc2lvbmVkTm90ZXNbZGl2aXNpb24gKyBkaXZpc2lvbkRpZmYgLyAyXSB8fCBbXTtcbiAgICBjb25zdCBuZXdSYW5kb21SaWNoTm90ZSA9IHtcbiAgICAgICAgbm90ZTogcmFuZG9tTm90ZSxcbiAgICAgICAgZHVyYXRpb246IGRpdmlzaW9uRGlmZiAvIDIsXG4gICAgICAgIGNob3JkOiBiZWF0UmljaE5vdGUuY2hvcmQsXG4gICAgICAgIHNjYWxlOiBiZWF0UmljaE5vdGUuc2NhbGUsXG4gICAgICAgIHBhcnRJbmRleDogcGFydEluZGV4LFxuICAgIH1cbiAgICBkaXZpc2lvbmVkTm90ZXNbZGl2aXNpb24gKyBkaXZpc2lvbkRpZmYgLyAyXS5wdXNoKG5ld1JhbmRvbVJpY2hOb3RlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuXG5leHBvcnQgY29uc3QgYnVpbGRUb3BNZWxvZHkgPSAoZGl2aXNpb25lZE5vdGVzOiBEaXZpc2lvbmVkUmljaG5vdGVzLCBtYWluUGFyYW1zOiBNYWluTXVzaWNQYXJhbXMpID0+IHtcbiAgICAvLyBDb252ZXJ0IDR0aCBub3RlcyBpbiBwYXJ0IDEgdG8gOHRoIG5vdGVzLiBBZGQgcmFuZG9tIDh0aCBhbmQgMTZ0aCBub3RlcyBiZXR3ZWVuIHRoZW0uIChhbmQgcGF1c2VzPylcbiAgICBjb25zdCBsYXN0RGl2aXNpb24gPSBCRUFUX0xFTkdUSCAqIG1haW5QYXJhbXMuZ2V0TWF4QmVhdHMoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdERpdmlzaW9uIC0gQkVBVF9MRU5HVEg7IGkgKz0gQkVBVF9MRU5HVEgpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbWFpblBhcmFtcy5jdXJyZW50Q2FkZW5jZVBhcmFtcyhpKTtcbiAgICAgICAgY29uc3QgZWlnaHRzVGhpc0JlYXQgPSBNYXRoLnJhbmRvbSgpIDwgcGFyYW1zLmVpZ2h0aE5vdGVzO1xuICAgICAgICBjb25zdCBzaXh0ZWVudGhzVGhpc0JlYXQgPSBNYXRoLnJhbmRvbSgpIDwgcGFyYW1zLnNpeHRlZW50aE5vdGVzO1xuXG4gICAgICAgIGlmICghZWlnaHRzVGhpc0JlYXQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGFzdEJlYXRJbkNhZGVuY2UgPSBwYXJhbXMuYmVhdHNVbnRpbENhZGVuY2VFbmQgPCAyXG4gICAgICAgIGlmIChsYXN0QmVhdEluQ2FkZW5jZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBwYXJ0SW5kZXggPSAwOyBwYXJ0SW5kZXggPCA0OyBwYXJ0SW5kZXgrKykge1xuICAgICAgICAgICAgLy8gSXMgdGhpcyBhIGdvb2QgcGFydCB0byBhZGQgZWlnaHRocz9cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGFkZE5vdGVCZXR3ZWVuKGksIGkgKyBCRUFUX0xFTkdUSCwgcGFydEluZGV4LCBkaXZpc2lvbmVkTm90ZXMpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgcGFyYW1zLnNpeHRlZW50aE5vdGVzKSB7XG4gICAgICAgICAgICAgICAgYWRkTm90ZUJldHdlZW4oaSwgaSArIEJFQVRfTEVOR1RIIC8gMiwgcGFydEluZGV4LCBkaXZpc2lvbmVkTm90ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCBwYXJhbXMuc2l4dGVlbnRoTm90ZXMpIHtcbiAgICAgICAgICAgICAgICBhZGROb3RlQmV0d2VlbihpICsgQkVBVF9MRU5HVEggLyAyLCBpICsgQkVBVF9MRU5HVEgsIHBhcnRJbmRleCwgZGl2aXNpb25lZE5vdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgeyBOb3RlLCBTY2FsZSwgU2VtaXRvbmUgfSBmcm9tIFwibXVzaWN0aGVvcnlqc1wiO1xuXG5leHBvcnQgY29uc3QgQkVBVF9MRU5HVEggPSAxMjtcblxuXG5leHBvcnQgY29uc3QgZ1RvbmVTdHJpbmcgPSAoZ1RvbmU6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIG5ldyBOb3RlKHtcbiAgICAgICAgc2VtaXRvbmU6IGdUb25lICUgMTIsXG4gICAgICAgIG9jdGF2ZTogTWF0aC5mbG9vcihnVG9uZSAvIDEyKSxcbiAgICB9KS50b1N0cmluZygpXG59XG5cblxuZXhwb3J0IGNvbnN0IGFycmF5T3JkZXJCeSA9IGZ1bmN0aW9uIChhcnJheTogQXJyYXk8YW55Piwgc2VsZWN0b3I6IENhbGxhYmxlRnVuY3Rpb24sIGRlc2MgPSBmYWxzZSkge1xuICAgIHJldHVybiBbLi4uYXJyYXldLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgYSA9IHNlbGVjdG9yKGEpO1xuICAgICAgICBiID0gc2VsZWN0b3IoYik7XG5cbiAgICAgICAgaWYgKGEgPT0gYikgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiAoZGVzYyA/IGEgPiBiIDogYSA8IGIpID8gLTEgOiAxO1xuICAgIH0pO1xufVxuXG5cbmV4cG9ydCBjb25zdCBjaG9yZFRlbXBsYXRlczogeyBba2V5OiBzdHJpbmddOiBBcnJheTxudW1iZXI+IH0gPSB7XG4gICAgbWFqOiBbMCwgNCwgN10sXG4gICAgbWluOiBbMCwgMywgN10sXG4gICAgZGltOiBbMCwgMywgNl0sXG4gICAgYXVnOiBbMCwgNCwgOF0sXG4gICAgbWFqNzogWzAsIDQsIDcsIDExXSxcbiAgICBtaW43OiBbMCwgMywgNywgMTBdLFxuICAgIGRvbTc6IFswLCA0LCA3LCAxMF0sXG4gICAgc3VzMjogWzAsIDIsIDddLFxuICAgIHN1czQ6IFswLCA1LCA3XSxcbn1cblxuXG5leHBvcnQgY2xhc3MgQ2hvcmQge1xuICAgIHB1YmxpYyBub3RlczogQXJyYXk8Tm90ZT47XG4gICAgcHVibGljIGNob3JkVHlwZTogc3RyaW5nO1xuICAgIHB1YmxpYyB0b1N0cmluZygpIHtcbiAgICAgICAgLy8gRmluZCBjb3JyZWN0IFNlbWl0b25lIGtleVxuICAgICAgICBjb25zdCBzZW1pdG9uZUtleXMgPSBPYmplY3Qua2V5cyhTZW1pdG9uZSkuZmlsdGVyKGtleSA9PiAoU2VtaXRvbmUgYXMgYW55KVtrZXldIGFzIG51bWJlciA9PT0gdGhpcy5ub3Rlc1swXS5zZW1pdG9uZSk7XG4gICAgICAgIGlmIChzZW1pdG9uZUtleXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vdGVzLm1hcChub3RlID0+IG5vdGUudG9TdHJpbmcoKSkuam9pbihcIiwgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZW1pdG9uZUtleSA9IHNlbWl0b25lS2V5cy5maWx0ZXIoa2V5ID0+IGtleS5pbmRleE9mKCdiJykgPT0gLTEgJiYga2V5LmluZGV4T2YoJ3MnKSA9PSAtMSlbMF0gfHwgc2VtaXRvbmVLZXlzWzBdO1xuICAgICAgICBzZW1pdG9uZUtleSA9IHNlbWl0b25lS2V5LnJlcGxhY2UoJ3MnLCAnIycpO1xuICAgICAgICByZXR1cm4gc2VtaXRvbmVLZXkgKyB0aGlzLmNob3JkVHlwZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2VtaXRvbmVPck5hbWU6IG51bWJlciB8IHN0cmluZywgY2hvcmRUeXBlOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHNlbWl0b25lO1xuICAgICAgICBpZiAodHlwZW9mIHNlbWl0b25lT3JOYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBzZW1pdG9uZSA9IHNlbWl0b25lT3JOYW1lLm1hdGNoKC9eXFxkKy8pO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHNlbWl0b25lT3JOYW1lLm1hdGNoKC9eXFxkKyguKikvKTtcbiAgICAgICAgICAgIGlmIChzZW1pdG9uZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGNob3JkIG5hbWUgXCIgKyBzZW1pdG9uZU9yTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZWRUeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgY2hvcmQgbmFtZSBcIiArIHNlbWl0b25lT3JOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VtaXRvbmUgPSBwYXJzZUludChzZW1pdG9uZVswXSk7XG4gICAgICAgICAgICBjaG9yZFR5cGUgPSBjaG9yZFR5cGUgfHwgcGFyc2VkVHlwZVsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbWl0b25lID0gc2VtaXRvbmVPck5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaG9yZFR5cGUgPSBjaG9yZFR5cGU7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gY2hvcmRUZW1wbGF0ZXNbY2hvcmRUeXBlXTtcbiAgICAgICAgaWYgKHRlbXBsYXRlID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgXCJVbmtub3duIGNob3JkIHR5cGU6IFwiICsgY2hvcmRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbm90ZSBvZiB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ub3Rlcy5wdXNoKG5ldyBOb3RlKHtzZW1pdG9uZTogKHNlbWl0b25lICsgbm90ZSkgJSAxMiwgb2N0YXZlOiAxfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbmV4cG9ydCB0eXBlIE51bGxhYmxlPFQ+ID0gVCB8IG51bGxcblxuZXhwb3J0IGNsYXNzIE1haW5NdXNpY1BhcmFtcyB7XG4gICAgYmVhdHNQZXJCYXI/OiBudW1iZXIgPSA0O1xuICAgIGNhZGVuY2VDb3VudD86IG51bWJlciA9IDJcbiAgICBjYWRlbmNlczogQXJyYXk8TXVzaWNQYXJhbXM+ID0gW107XG4gICAgdGVzdE1vZGU/OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJhbXM6IFBhcnRpYWw8TWFpbk11c2ljUGFyYW1zPiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgKHRoaXMgYXMgYW55KVtrZXldID0gKHBhcmFtcyBhcyBhbnkpW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50Q2FkZW5jZVBhcmFtcyhkaXZpc2lvbjogbnVtYmVyKTogTXVzaWNQYXJhbXMge1xuICAgICAgICBjb25zdCBiZWF0ID0gTWF0aC5mbG9vcihkaXZpc2lvbiAvIEJFQVRfTEVOR1RIKTtcbiAgICAgICAgY29uc3QgYmFyID0gTWF0aC5mbG9vcihiZWF0IC8gdGhpcy5iZWF0c1BlckJhcik7XG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBjYWRlbmNlUGFyYW1zIG9mIHRoaXMuY2FkZW5jZXMpIHtcbiAgICAgICAgICAgIGNvdW50ZXIgKz0gY2FkZW5jZVBhcmFtcy5iYXJzUGVyQ2FkZW5jZTtcbiAgICAgICAgICAgIGlmIChiYXIgPCBjb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgY2FkZW5jZVBhcmFtcy5iZWF0c1VudGlsQ2FkZW5jZUVuZCA9IGNvdW50ZXIgKiB0aGlzLmJlYXRzUGVyQmFyIC0gYmVhdDtcbiAgICAgICAgICAgICAgICBjYWRlbmNlUGFyYW1zLmJlYXRzVW50aWxTb25nRW5kID0gdGhpcy5jYWRlbmNlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLmJhcnNQZXJDYWRlbmNlLCAwKSAqIHRoaXMuYmVhdHNQZXJCYXIgLSBiZWF0O1xuICAgICAgICAgICAgICAgIGNhZGVuY2VQYXJhbXMuYmVhdHNQZXJCYXIgPSB0aGlzLmJlYXRzUGVyQmFyO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWRlbmNlUGFyYW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0TWF4QmVhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhZGVuY2VzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIuYmFyc1BlckNhZGVuY2UsIDApICogdGhpcy5iZWF0c1BlckJhcjtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNdXNpY1BhcmFtcyB7XG4gICAgYmVhdHNVbnRpbENhZGVuY2VFbmQ6IG51bWJlciA9IDA7XG4gICAgYmVhdHNVbnRpbFNvbmdFbmQ6IG51bWJlciA9IDA7XG4gICAgYmVhdHNQZXJCYXI6IG51bWJlciA9IDQ7XG5cbiAgICBiYXNlVGVuc2lvbj86IG51bWJlciA9IDAuMztcbiAgICBiYXJzUGVyQ2FkZW5jZT86IG51bWJlciA9IDRcbiAgICB0ZW1wbz86IG51bWJlciA9IDQwO1xuICAgIGhhbGZOb3Rlcz86IGJvb2xlYW4gPSB0cnVlO1xuICAgIHNpeHRlZW50aE5vdGVzPzogbnVtYmVyID0gMC4yO1xuICAgIGVpZ2h0aE5vdGVzPzogbnVtYmVyID0gMC40O1xuICAgIG1vZHVsYXRpb25XZWlnaHQ/OiBudW1iZXIgPSAwLjU7XG4gICAgbGVhZGluZ1dlaWdodD86IG51bWJlciA9IDI7XG4gICAgcGFydHM6IEFycmF5PHtcbiAgICAgICAgdm9pY2U6IHN0cmluZyxcbiAgICAgICAgbm90ZTogc3RyaW5nLFxuICAgIH0+ID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICB2b2ljZTogXCIxXCIsXG4gICAgICAgICAgICBub3RlOiBcIkM1XCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZvaWNlOiBcIjFcIixcbiAgICAgICAgICAgIG5vdGU6IFwiQTRcIixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdm9pY2U6IFwiMVwiLFxuICAgICAgICAgICAgbm90ZTogXCJDNFwiLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB2b2ljZTogXCIxXCIsXG4gICAgICAgICAgICBub3RlOiBcIkUzXCIsXG4gICAgICAgIH1cbiAgICBdO1xuICAgIGJlYXRTZXR0aW5nczogQXJyYXk8e1xuICAgICAgICB0ZW5zaW9uOiBudW1iZXIsXG4gICAgfT4gPSBbXTtcbiAgICBjaG9yZFNldHRpbmdzOiB7W2tleTogc3RyaW5nXToge1xuICAgICAgICBlbmFibGVkOiBib29sZWFuLFxuICAgICAgICB3ZWlnaHQ6IG51bWJlcixcbiAgICB9fSA9IHtcbiAgICAgICAgbWFqOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgd2VpZ2h0OiAwLFxuICAgICAgICB9LFxuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB3ZWlnaHQ6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIGRpbToge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB3ZWlnaHQ6IC0xLFxuICAgICAgICB9LFxuICAgICAgICBhdWc6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgd2VpZ2h0OiAtMSxcbiAgICAgICAgfSxcbiAgICAgICAgbWFqNzoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB3ZWlnaHQ6IC0xLFxuICAgICAgICB9LFxuICAgICAgICBkb203OiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHdlaWdodDogLTEsXG4gICAgICAgIH0sXG4gICAgICAgIHN1czI6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgd2VpZ2h0OiAtMSxcbiAgICAgICAgfSxcbiAgICAgICAgc3VzNDoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB3ZWlnaHQ6IC0xLFxuICAgICAgICB9LFxuICAgIH1cbiAgICBzY2FsZVNldHRpbmdzOiB7XG4gICAgICAgIFtrZXk6IHN0cmluZ106IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGJvb2xlYW4sXG4gICAgICAgICAgICB3ZWlnaHQ6IG51bWJlclxuICAgICAgICB9XG4gICAgfSA9IHtcbiAgICAgICAgbWFqb3I6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB3ZWlnaHQ6IDAsXG4gICAgICAgIH0sXG4gICAgICAgIG1pbm9yOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgd2VpZ2h0OiAwLFxuICAgICAgICB9LFxuICAgICAgICBoYXJtb25pY01pbm9yOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHdlaWdodDogLTAuNSxcbiAgICAgICAgfSxcbiAgICAgICAgbWVsb2RpY01pbm9yQXNjZW5kaW5nOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHdlaWdodDogLTAuNSxcbiAgICAgICAgfSxcbiAgICAgICAgbWVsb2RpY01pbm9yRGVzY2VuZGluZzoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB3ZWlnaHQ6IC0wLjUsXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBtZWxvZHlTZXR0aW5nczoge1xuICAgICAgICBcInVwXCI6IG51bWJlcixcbiAgICAgICAgXCJkb3duXCI6IG51bWJlcixcbiAgICAgICAgXCJzYW1lXCI6IG51bWJlcixcbiAgICB9ID0ge1xuICAgICAgICBcInVwXCI6IDAsXG4gICAgICAgIFwiZG93blwiOiAwLFxuICAgICAgICBcInNhbWVcIjogMCxcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihwYXJhbXM6IFBhcnRpYWw8TXVzaWNQYXJhbXM+IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAodGhpcyBhcyBhbnkpW2tleV0gPSAocGFyYW1zIGFzIGFueSlba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUJlYXRTZXR0aW5ncygpO1xuICAgIH1cblxuICAgIHVwZGF0ZUJlYXRTZXR0aW5ncygpIHtcbiAgICAgICAgY29uc3QgYmVhdENvdW50ID0gdGhpcy5iZWF0c1BlckJhciAqIHRoaXMuYmFyc1BlckNhZGVuY2U7XG4gICAgICAgIGlmICh0aGlzLmJlYXRTZXR0aW5ncy5sZW5ndGggPCBiZWF0Q291bnQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmJlYXRTZXR0aW5ncy5sZW5ndGg7IGkgPCBiZWF0Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYmVhdFNldHRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uOiB0aGlzLmJhc2VUZW5zaW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5iZWF0U2V0dGluZ3MubGVuZ3RoID4gYmVhdENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmJlYXRTZXR0aW5ncyA9IHRoaXMuYmVhdFNldHRpbmdzLnNsaWNlKDAsIGJlYXRDb3VudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0IHR5cGUgTXVzaWNSZXN1bHQgPSB7XG4gICAgY2hvcmQ6IENob3JkLFxuICAgIHRlbnNpb246IG51bWJlcixcbiAgICBzY2FsZTogU2NhbGUsXG59XG5cbmV4cG9ydCB0eXBlIFJpY2hOb3RlID0ge1xuICAgIG5vdGU6IE5vdGUsXG4gICAgZHVyYXRpb246IG51bWJlcixcbiAgICBmcmVxPzogbnVtYmVyLFxuICAgIGNob3JkPzogQ2hvcmQsXG4gICAgcGFydEluZGV4PzogbnVtYmVyLFxuICAgIHNjYWxlPzogU2NhbGUsXG4gICAgYmVhbT86IHN0cmluZyxcbiAgICB0aWU/OiBzdHJpbmcsXG4gICAgdGVuc2lvbj86IG51bWJlcixcbiAgICBpbnZlcnNpb25OYW1lPzogc3RyaW5nLFxufVxuXG5leHBvcnQgdHlwZSBEaXZpc2lvbmVkUmljaG5vdGVzID0ge1xuICAgIFtrZXk6IG51bWJlcl06IEFycmF5PFJpY2hOb3RlPixcbn1cblxuZXhwb3J0IGNvbnN0IGdsb2JhbFNlbWl0b25lID0gKG5vdGU6IE5vdGUpID0+IHtcbiAgICByZXR1cm4gbm90ZS5zZW1pdG9uZSArICgobm90ZS5vY3RhdmUpICogMTIpO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0Q2xvc2VzdE9jdGF2ZSA9IChub3RlOiBOb3RlLCB0YXJnZXROb3RlOiBOdWxsYWJsZTxOb3RlPiA9IG51bGwsIHRhcmdldFNlbWl0b25lOiBOdWxsYWJsZTxudW1iZXI+ID0gbnVsbCkgPT4ge1xuICAgIC8vIFxuICAgIGxldCBzZW1pdG9uZSA9IGdsb2JhbFNlbWl0b25lKG5vdGUpO1xuICAgIHRhcmdldFNlbWl0b25lID0gdGFyZ2V0U2VtaXRvbmUgfHwgZ2xvYmFsU2VtaXRvbmUodGFyZ2V0Tm90ZSk7XG4gICAgY29uc29sZS5sb2coXCJDbG9zZXN0IG9jdGF2ZTogXCIsIHNlbWl0b25lLCB0YXJnZXRTZW1pdG9uZSk7XG4gICAgLy8gVXNpbmcgbW9kdWxvIGhlcmUgLT4gLTcgJSAxMiA9IC03XG4gICAgLy8gLTEzICUgMTIgPSAtMVxuICAgIGlmIChzZW1pdG9uZSA9PSB0YXJnZXRTZW1pdG9uZSkge1xuICAgICAgICByZXR1cm4gbm90ZS5vY3RhdmU7XG4gICAgfVxuICAgIGNvbnN0IGRlbHRhOiBudW1iZXIgPSB0YXJnZXRTZW1pdG9uZSA+IHNlbWl0b25lID8gMTIgOiAtMTI7XG4gICAgbGV0IHJldCA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IGNsZWFuT2N0YXZlID0gKG9jdGF2ZTogbnVtYmVyKSA9PiB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChvY3RhdmUsIDIpLCA2KTtcbiAgICB9XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBpZiAoaSA+IDEwMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluZmluaXRlIGxvb3BcIik7XG4gICAgICAgIH1cbiAgICAgICAgc2VtaXRvbmUgKz0gZGVsdGE7XG4gICAgICAgIHJldCArPSBkZWx0YSAvIDEyOyAgLy8gSG93IG1hbnkgb2N0YXZlcyB3ZSBjaGFuZ2VkXG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIGlmIChzZW1pdG9uZSA+PSB0YXJnZXRTZW1pdG9uZSkge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzZW1pdG9uZSAtIHRhcmdldFNlbWl0b25lKSA+IE1hdGguYWJzKHNlbWl0b25lIC0gMTIgLSB0YXJnZXRTZW1pdG9uZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2VudCB0b28gZmFyLCBnbyBvbmUgYmFja1xuICAgICAgICAgICAgICAgICAgICByZXQgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDbG9zZXN0IG9jdGF2ZSByZXM6IFwiLCBjbGVhbk9jdGF2ZShub3RlLm9jdGF2ZSArIHJldCksIHJldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFuT2N0YXZlKG5vdGUub2N0YXZlICsgcmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZW1pdG9uZSA8PSB0YXJnZXRTZW1pdG9uZSkge1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzZW1pdG9uZSAtIHRhcmdldFNlbWl0b25lKSA+IE1hdGguYWJzKHNlbWl0b25lICsgMTIgLSB0YXJnZXRTZW1pdG9uZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2VudCB0b28gZmFyLCBnbyBvbmUgYmFja1xuICAgICAgICAgICAgICAgICAgICByZXQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDbG9zZXN0IG9jdGF2ZSByZXM6IFwiLCBjbGVhbk9jdGF2ZShub3RlLm9jdGF2ZSArIHJldCksIHJldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFuT2N0YXZlKG5vdGUub2N0YXZlICsgcmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1halNjYWxlQ2lyY2xlOiB7IFtrZXk6IG51bWJlcl06IEFycmF5PG51bWJlcj4gfSA9IHt9XG5tYWpTY2FsZUNpcmNsZVtTZW1pdG9uZS5DXSA9IFtTZW1pdG9uZS5HLCBTZW1pdG9uZS5GXVxubWFqU2NhbGVDaXJjbGVbU2VtaXRvbmUuR10gPSBbU2VtaXRvbmUuRCwgU2VtaXRvbmUuQ11cbm1halNjYWxlQ2lyY2xlW1NlbWl0b25lLkRdID0gW1NlbWl0b25lLkEsIFNlbWl0b25lLkddXG5tYWpTY2FsZUNpcmNsZVtTZW1pdG9uZS5BXSA9IFtTZW1pdG9uZS5FLCBTZW1pdG9uZS5EXVxubWFqU2NhbGVDaXJjbGVbU2VtaXRvbmUuRV0gPSBbU2VtaXRvbmUuQiwgU2VtaXRvbmUuQV1cbm1halNjYWxlQ2lyY2xlW1NlbWl0b25lLkJdID0gW1NlbWl0b25lLkZzLCBTZW1pdG9uZS5FXVxuXG5tYWpTY2FsZUNpcmNsZVtTZW1pdG9uZS5GXSA9IFtTZW1pdG9uZS5DLCBTZW1pdG9uZS5CYl1cbm1halNjYWxlQ2lyY2xlW1NlbWl0b25lLkJiXSA9IFtTZW1pdG9uZS5GLCBTZW1pdG9uZS5FYl1cbm1halNjYWxlQ2lyY2xlW1NlbWl0b25lLkViXSA9IFtTZW1pdG9uZS5CYiwgU2VtaXRvbmUuQWJdXG5tYWpTY2FsZUNpcmNsZVtTZW1pdG9uZS5BYl0gPSBbU2VtaXRvbmUuRWIsIFNlbWl0b25lLkRiXVxubWFqU2NhbGVDaXJjbGVbU2VtaXRvbmUuRGJdID0gW1NlbWl0b25lLkFiLCBTZW1pdG9uZS5HYl1cbm1halNjYWxlQ2lyY2xlW1NlbWl0b25lLkdiXSA9IFtTZW1pdG9uZS5EYiwgU2VtaXRvbmUuQ2JdXG5tYWpTY2FsZUNpcmNsZVtTZW1pdG9uZS5DYl0gPSBbU2VtaXRvbmUuR2IsIFNlbWl0b25lLkZiXVxuXG5cbmV4cG9ydCBjb25zdCBtYWpTY2FsZURpZmZlcmVuY2UgPSAoc2VtaXRvbmUxOiBudW1iZXIsIHNlbWl0b25lMjogbnVtYmVyKSA9PiB7XG4gICAgLy8gR2l2ZW4gdHdvIG1ham9yIHNjYWxlcywgcmV0dXJuIGhvdyBjbG9zZWx5IHJlbGF0ZWQgdGhleSBhcmVcbiAgICAvLyAwID0gc2FtZSBzY2FsZVxuICAgIC8vIDEgPSBFLkcuIEMgYW5kIEYgb3IgQyBhbmQgR1xuICAgIGxldCBjdXJyZW50VmFsID0gbWFqU2NhbGVDaXJjbGVbc2VtaXRvbmUxXTtcbiAgICBpZiAoc2VtaXRvbmUxID09IHNlbWl0b25lMikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIGlmIChjdXJyZW50VmFsLmluY2x1ZGVzKHNlbWl0b25lMikpIHtcbiAgICAgICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdDdXJyZW50VmFsID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHNlbWl0b25lIG9mIGN1cnJlbnRWYWwpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmV3U2VtaXRvbmUgb2YgbWFqU2NhbGVDaXJjbGVbc2VtaXRvbmVdKSB7XG4gICAgICAgICAgICAgICAgbmV3Q3VycmVudFZhbC5hZGQobmV3U2VtaXRvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRWYWwgPSBbLi4ubmV3Q3VycmVudFZhbF0gYXMgQXJyYXk8bnVtYmVyPjtcbiAgICB9XG4gICAgcmV0dXJuIDEyO1xufVxuXG5cbmV4cG9ydCBjb25zdCBzZW1pdG9uZURpc3RhbmNlID0gKHRvbmUxOiBudW1iZXIsIHRvbmUyOiBudW1iZXIpID0+IHtcbiAgICAvLyBkaXN0YW5jZSBmcm9tIDAgdG8gMTEgc2hvdWxkIGJlIDFcbiAgICAvLyAwIC0gMTEgKyAxMiA9PiAxXG4gICAgLy8gMTEgLSAwICsgMTIgPT4gMjMgPT4gMTFcblxuICAgIC8vIDAgLSA2ICsgMTIgPT4gNlxuICAgIC8vIDYgLSAwICsgMTIgPT4gMTggPT4gNlxuXG4gICAgLy8gMCArIDYgLSAzICsgNiA9IDYgLSA5ID0gLTNcbiAgICAvLyA2ICsgNiAtIDkgKyA2ID0gMTIgLSAxNSA9IDAgLSAzID0gLTNcbiAgICAvLyAxMSArIDYgLSAwICsgNiA9IDE3IC0gNiA9IDUgLSA2ID0gLTFcbiAgICAvLyAwICsgNiAtIDExICsgNiA9IDYgLSAxNyA9IDYgLSA1ID0gMVxuXG4gICAgcmV0dXJuIE1hdGguYWJzKCh0b25lMSArIDYpICUgMTIgLSAodG9uZTIgKyA2KSAlIDEyKTtcbn1cbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi40LjFcbihmdW5jdGlvbigpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRGlzY29ubmVjdGVkOiAxLFxuICAgIFByZWNlZGluZzogMixcbiAgICBGb2xsb3dpbmc6IDQsXG4gICAgQ29udGFpbnM6IDgsXG4gICAgQ29udGFpbmVkQnk6IDE2LFxuICAgIEltcGxlbWVudGF0aW9uU3BlY2lmaWM6IDMyXG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuNC4xXG4oZnVuY3Rpb24oKSB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIEVsZW1lbnQ6IDEsXG4gICAgQXR0cmlidXRlOiAyLFxuICAgIFRleHQ6IDMsXG4gICAgQ0RhdGE6IDQsXG4gICAgRW50aXR5UmVmZXJlbmNlOiA1LFxuICAgIEVudGl0eURlY2xhcmF0aW9uOiA2LFxuICAgIFByb2Nlc3NpbmdJbnN0cnVjdGlvbjogNyxcbiAgICBDb21tZW50OiA4LFxuICAgIERvY3VtZW50OiA5LFxuICAgIERvY1R5cGU6IDEwLFxuICAgIERvY3VtZW50RnJhZ21lbnQ6IDExLFxuICAgIE5vdGF0aW9uRGVjbGFyYXRpb246IDEyLFxuICAgIC8vIE51bWVyaWMgY29kZXMgdXAgdG8gMjAwIGFyZSByZXNlcnZlZCB0byBXM0MgZm9yIHBvc3NpYmxlIGZ1dHVyZSB1c2UuXG4gICAgLy8gRm9sbG93aW5nIGFyZSB0eXBlcyBpbnRlcm5hbCB0byB0aGlzIGxpYnJhcnk6XG4gICAgRGVjbGFyYXRpb246IDIwMSxcbiAgICBSYXc6IDIwMixcbiAgICBBdHRyaWJ1dGVEZWNsYXJhdGlvbjogMjAzLFxuICAgIEVsZW1lbnREZWNsYXJhdGlvbjogMjA0LFxuICAgIER1bW15OiAyMDVcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi40LjFcbihmdW5jdGlvbigpIHtcbiAgLy8gQ29waWVzIGFsbCBlbnVtZXJhYmxlIG93biBwcm9wZXJ0aWVzIGZyb20gYHNvdXJjZXNgIHRvIGB0YXJnZXRgXG4gIHZhciBhc3NpZ24sIGdldFZhbHVlLCBpc0FycmF5LCBpc0VtcHR5LCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNQbGFpbk9iamVjdCxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgYXNzaWduID0gZnVuY3Rpb24odGFyZ2V0LCAuLi5zb3VyY2VzKSB7XG4gICAgdmFyIGksIGtleSwgbGVuLCBzb3VyY2U7XG4gICAgaWYgKGlzRnVuY3Rpb24oT2JqZWN0LmFzc2lnbikpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIC8vIERldGVybWluZXMgaWYgYHZhbGAgaXMgYSBGdW5jdGlvbiBvYmplY3RcbiAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAhIXZhbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgfTtcblxuICAvLyBEZXRlcm1pbmVzIGlmIGB2YWxgIGlzIGFuIE9iamVjdFxuICBpc09iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciByZWY7XG4gICAgcmV0dXJuICEhdmFsICYmICgocmVmID0gdHlwZW9mIHZhbCkgPT09ICdmdW5jdGlvbicgfHwgcmVmID09PSAnb2JqZWN0Jyk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lcyBpZiBgdmFsYCBpcyBhbiBBcnJheVxuICBpc0FycmF5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oQXJyYXkuaXNBcnJheSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lcyBpZiBgdmFsYCBpcyBhbiBlbXB0eSBBcnJheSBvciBhbiBPYmplY3Qgd2l0aCBubyBvd24gcHJvcGVydGllc1xuICBpc0VtcHR5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXR1cm4gIXZhbC5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoa2V5IGluIHZhbCkge1xuICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbCh2YWwsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lcyBpZiBgdmFsYCBpcyBhIHBsYWluIE9iamVjdFxuICBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIGN0b3IsIHByb3RvO1xuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmIChwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpKSAmJiAoY3RvciA9IHByb3RvLmNvbnN0cnVjdG9yKSAmJiAodHlwZW9mIGN0b3IgPT09ICdmdW5jdGlvbicpICYmIChjdG9yIGluc3RhbmNlb2YgY3RvcikgJiYgKEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGN0b3IpID09PSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChPYmplY3QpKTtcbiAgfTtcblxuICAvLyBHZXRzIHRoZSBwcmltaXRpdmUgdmFsdWUgb2YgYW4gb2JqZWN0XG4gIGdldFZhbHVlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24ob2JqLnZhbHVlT2YpKSB7XG4gICAgICByZXR1cm4gb2JqLnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuYXNzaWduID0gYXNzaWduO1xuXG4gIG1vZHVsZS5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG4gIG1vZHVsZS5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbiAgbW9kdWxlLmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbiAgbW9kdWxlLmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XG5cbiAgbW9kdWxlLmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG5cbiAgbW9kdWxlLmV4cG9ydHMuZ2V0VmFsdWUgPSBnZXRWYWx1ZTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi40LjFcbihmdW5jdGlvbigpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTm9uZTogMCxcbiAgICBPcGVuVGFnOiAxLFxuICAgIEluc2lkZVRhZzogMixcbiAgICBDbG9zZVRhZzogM1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjQuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgTm9kZVR5cGUsIFhNTEF0dHJpYnV0ZSwgWE1MTm9kZTtcblxuICBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vTm9kZVR5cGUnKTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgLy8gUmVwcmVzZW50cyBhbiBhdHRyaWJ1dGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxBdHRyaWJ1dGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgWE1MQXR0cmlidXRlIHtcbiAgICAgIC8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIGBYTUxBdHRyaWJ1dGVgXG5cbiAgICAgIC8vIGBwYXJlbnRgIHRoZSBwYXJlbnQgbm9kZVxuICAgICAgLy8gYG5hbWVgIGF0dHJpYnV0ZSB0YXJnZXRcbiAgICAgIC8vIGB2YWx1ZWAgYXR0cmlidXRlIHZhbHVlXG4gICAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLnBhcmVudC5vcHRpb25zO1xuICAgICAgICAgIHRoaXMuc3RyaW5naWZ5ID0gdGhpcy5wYXJlbnQuc3RyaW5naWZ5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZSBuYW1lLiBcIiArIHRoaXMuZGVidWdJbmZvKG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLnN0cmluZ2lmeS5uYW1lKG5hbWUpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5zdHJpbmdpZnkuYXR0VmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLnR5cGUgPSBOb2RlVHlwZS5BdHRyaWJ1dGU7XG4gICAgICAgIC8vIERPTSBsZXZlbCAzXG4gICAgICAgIHRoaXMuaXNJZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjaGVtYVR5cGVJbmZvID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGRlZXAgY2xvbmUgb2YgYHRoaXNgXG4gICAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnZlcnRzIHRoZSBYTUwgZnJhZ21lbnQgdG8gc3RyaW5nXG5cbiAgICAgIC8vIGBvcHRpb25zLnByZXR0eWAgcHJldHR5IHByaW50cyB0aGUgcmVzdWx0XG4gICAgICAvLyBgb3B0aW9ucy5pbmRlbnRgIGluZGVudGF0aW9uIGZvciBwcmV0dHkgcHJpbnRcbiAgICAgIC8vIGBvcHRpb25zLm9mZnNldGAgaG93IG1hbnkgaW5kZW50YXRpb25zIHRvIGFkZCB0byBldmVyeSBsaW5lIGZvciBwcmV0dHkgcHJpbnRcbiAgICAgIC8vIGBvcHRpb25zLm5ld2xpbmVgIG5ld2xpbmUgc2VxdWVuY2UgZm9yIHByZXR0eSBwcmludFxuICAgICAgdG9TdHJpbmcob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5hdHRyaWJ1dGUodGhpcywgdGhpcy5vcHRpb25zLndyaXRlci5maWx0ZXJPcHRpb25zKG9wdGlvbnMpKTtcbiAgICAgIH1cblxuICAgICAgXG4gICAgICAvLyBSZXR1cm5zIGRlYnVnIHN0cmluZyBmb3IgdGhpcyBub2RlXG4gICAgICBkZWJ1Z0luZm8obmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZSB8fCB0aGlzLm5hbWU7XG4gICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gXCJwYXJlbnQ6IDxcIiArIHRoaXMucGFyZW50Lm5hbWUgKyBcIj5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gXCJhdHRyaWJ1dGU6IHtcIiArIG5hbWUgKyBcIn0sIHBhcmVudDogPFwiICsgdGhpcy5wYXJlbnQubmFtZSArIFwiPlwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlzRXF1YWxOb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubmFtZXNwYWNlVVJJICE9PSB0aGlzLm5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5wcmVmaXggIT09IHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmxvY2FsTmFtZSAhPT0gdGhpcy5sb2NhbE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgLy8gRE9NIGxldmVsIDFcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MQXR0cmlidXRlLnByb3RvdHlwZSwgJ25vZGVUeXBlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxBdHRyaWJ1dGUucHJvdG90eXBlLCAnb3duZXJFbGVtZW50Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRE9NIGxldmVsIDNcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MQXR0cmlidXRlLnByb3RvdHlwZSwgJ3RleHRDb250ZW50Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9IHZhbHVlIHx8ICcnO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRE9NIGxldmVsIDRcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MQXR0cmlidXRlLnByb3RvdHlwZSwgJ25hbWVzcGFjZVVSSScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxBdHRyaWJ1dGUucHJvdG90eXBlLCAncHJlZml4Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTEF0dHJpYnV0ZS5wcm90b3R5cGUsICdsb2NhbE5hbWUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTEF0dHJpYnV0ZS5wcm90b3R5cGUsICdzcGVjaWZpZWQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBYTUxBdHRyaWJ1dGU7XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi40LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIE5vZGVUeXBlLCBYTUxDRGF0YSwgWE1MQ2hhcmFjdGVyRGF0YTtcblxuICBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vTm9kZVR5cGUnKTtcblxuICBYTUxDaGFyYWN0ZXJEYXRhID0gcmVxdWlyZSgnLi9YTUxDaGFyYWN0ZXJEYXRhJyk7XG5cbiAgLy8gUmVwcmVzZW50cyBhICBDREFUQSBub2RlXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MQ0RhdGEgPSBjbGFzcyBYTUxDRGF0YSBleHRlbmRzIFhNTENoYXJhY3RlckRhdGEge1xuICAgIC8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIGBYTUxDRGF0YWBcblxuICAgIC8vIGB0ZXh0YCBDREFUQSB0ZXh0XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB0ZXh0KSB7XG4gICAgICBzdXBlcihwYXJlbnQpO1xuICAgICAgaWYgKHRleHQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIENEQVRBIHRleHQuIFwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG4gICAgICB0aGlzLm5hbWUgPSBcIiNjZGF0YS1zZWN0aW9uXCI7XG4gICAgICB0aGlzLnR5cGUgPSBOb2RlVHlwZS5DRGF0YTtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5jZGF0YSh0ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGEgZGVlcCBjbG9uZSBvZiBgdGhpc2BcbiAgICBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnRzIHRoZSBYTUwgZnJhZ21lbnQgdG8gc3RyaW5nXG5cbiAgICAvLyBgb3B0aW9ucy5wcmV0dHlgIHByZXR0eSBwcmludHMgdGhlIHJlc3VsdFxuICAgIC8vIGBvcHRpb25zLmluZGVudGAgaW5kZW50YXRpb24gZm9yIHByZXR0eSBwcmludFxuICAgIC8vIGBvcHRpb25zLm9mZnNldGAgaG93IG1hbnkgaW5kZW50YXRpb25zIHRvIGFkZCB0byBldmVyeSBsaW5lIGZvciBwcmV0dHkgcHJpbnRcbiAgICAvLyBgb3B0aW9ucy5uZXdsaW5lYCBuZXdsaW5lIHNlcXVlbmNlIGZvciBwcmV0dHkgcHJpbnRcbiAgICB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5jZGF0YSh0aGlzLCB0aGlzLm9wdGlvbnMud3JpdGVyLmZpbHRlck9wdGlvbnMob3B0aW9ucykpO1xuICAgIH1cblxuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjQuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQ2hhcmFjdGVyRGF0YSwgWE1MTm9kZTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgLy8gUmVwcmVzZW50cyBhIGNoYXJhY3RlciBkYXRhIG5vZGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxDaGFyYWN0ZXJEYXRhID0gKGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzIFhNTENoYXJhY3RlckRhdGEgZXh0ZW5kcyBYTUxOb2RlIHtcbiAgICAgIC8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIGBYTUxDaGFyYWN0ZXJEYXRhYFxuXG4gICAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50KTtcbiAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZXMgYW5kIHJldHVybnMgYSBkZWVwIGNsb25lIG9mIGB0aGlzYFxuICAgICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBET00gbGV2ZWwgMSBmdW5jdGlvbnMgdG8gYmUgaW1wbGVtZW50ZWQgbGF0ZXJcbiAgICAgIHN1YnN0cmluZ0RhdGEob2Zmc2V0LCBjb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGFwcGVuZERhdGEoYXJnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgaW5zZXJ0RGF0YShvZmZzZXQsIGFyZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZURhdGEob2Zmc2V0LCBjb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIHJlcGxhY2VEYXRhKG9mZnNldCwgY291bnQsIGFyZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGlzRXF1YWxOb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKCFzdXBlci5pc0VxdWFsTm9kZShub2RlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5kYXRhICE9PSB0aGlzLmRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgLy8gRE9NIGxldmVsIDFcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MQ2hhcmFjdGVyRGF0YS5wcm90b3R5cGUsICdkYXRhJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9IHZhbHVlIHx8ICcnO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTENoYXJhY3RlckRhdGEucHJvdG90eXBlLCAnbGVuZ3RoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRE9NIGxldmVsIDNcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MQ2hhcmFjdGVyRGF0YS5wcm90b3R5cGUsICd0ZXh0Q29udGVudCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPSB2YWx1ZSB8fCAnJztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBYTUxDaGFyYWN0ZXJEYXRhO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuNC4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBOb2RlVHlwZSwgWE1MQ2hhcmFjdGVyRGF0YSwgWE1MQ29tbWVudDtcblxuICBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vTm9kZVR5cGUnKTtcblxuICBYTUxDaGFyYWN0ZXJEYXRhID0gcmVxdWlyZSgnLi9YTUxDaGFyYWN0ZXJEYXRhJyk7XG5cbiAgLy8gUmVwcmVzZW50cyBhIGNvbW1lbnQgbm9kZVxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTENvbW1lbnQgPSBjbGFzcyBYTUxDb21tZW50IGV4dGVuZHMgWE1MQ2hhcmFjdGVyRGF0YSB7XG4gICAgLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYFhNTENvbW1lbnRgXG5cbiAgICAvLyBgdGV4dGAgY29tbWVudCB0ZXh0XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB0ZXh0KSB7XG4gICAgICBzdXBlcihwYXJlbnQpO1xuICAgICAgaWYgKHRleHQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGNvbW1lbnQgdGV4dC4gXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmFtZSA9IFwiI2NvbW1lbnRcIjtcbiAgICAgIHRoaXMudHlwZSA9IE5vZGVUeXBlLkNvbW1lbnQ7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5zdHJpbmdpZnkuY29tbWVudCh0ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGEgZGVlcCBjbG9uZSBvZiBgdGhpc2BcbiAgICBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnRzIHRoZSBYTUwgZnJhZ21lbnQgdG8gc3RyaW5nXG5cbiAgICAvLyBgb3B0aW9ucy5wcmV0dHlgIHByZXR0eSBwcmludHMgdGhlIHJlc3VsdFxuICAgIC8vIGBvcHRpb25zLmluZGVudGAgaW5kZW50YXRpb24gZm9yIHByZXR0eSBwcmludFxuICAgIC8vIGBvcHRpb25zLm9mZnNldGAgaG93IG1hbnkgaW5kZW50YXRpb25zIHRvIGFkZCB0byBldmVyeSBsaW5lIGZvciBwcmV0dHkgcHJpbnRcbiAgICAvLyBgb3B0aW9ucy5uZXdsaW5lYCBuZXdsaW5lIHNlcXVlbmNlIGZvciBwcmV0dHkgcHJpbnRcbiAgICB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5jb21tZW50KHRoaXMsIHRoaXMub3B0aW9ucy53cml0ZXIuZmlsdGVyT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgfVxuXG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuNC4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxET01Db25maWd1cmF0aW9uLCBYTUxET01FcnJvckhhbmRsZXIsIFhNTERPTVN0cmluZ0xpc3Q7XG5cbiAgWE1MRE9NRXJyb3JIYW5kbGVyID0gcmVxdWlyZSgnLi9YTUxET01FcnJvckhhbmRsZXInKTtcblxuICBYTUxET01TdHJpbmdMaXN0ID0gcmVxdWlyZSgnLi9YTUxET01TdHJpbmdMaXN0Jyk7XG5cbiAgLy8gSW1wbGVtZW50cyB0aGUgRE9NQ29uZmlndXJhdGlvbiBpbnRlcmZhY2VcbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxET01Db25maWd1cmF0aW9uID0gKGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzIFhNTERPTUNvbmZpZ3VyYXRpb24ge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHZhciBjbG9uZWRTZWxmO1xuICAgICAgICB0aGlzLmRlZmF1bHRQYXJhbXMgPSB7XG4gICAgICAgICAgXCJjYW5vbmljYWwtZm9ybVwiOiBmYWxzZSxcbiAgICAgICAgICBcImNkYXRhLXNlY3Rpb25zXCI6IGZhbHNlLFxuICAgICAgICAgIFwiY29tbWVudHNcIjogZmFsc2UsXG4gICAgICAgICAgXCJkYXRhdHlwZS1ub3JtYWxpemF0aW9uXCI6IGZhbHNlLFxuICAgICAgICAgIFwiZWxlbWVudC1jb250ZW50LXdoaXRlc3BhY2VcIjogdHJ1ZSxcbiAgICAgICAgICBcImVudGl0aWVzXCI6IHRydWUsXG4gICAgICAgICAgXCJlcnJvci1oYW5kbGVyXCI6IG5ldyBYTUxET01FcnJvckhhbmRsZXIoKSxcbiAgICAgICAgICBcImluZm9zZXRcIjogdHJ1ZSxcbiAgICAgICAgICBcInZhbGlkYXRlLWlmLXNjaGVtYVwiOiBmYWxzZSxcbiAgICAgICAgICBcIm5hbWVzcGFjZXNcIjogdHJ1ZSxcbiAgICAgICAgICBcIm5hbWVzcGFjZS1kZWNsYXJhdGlvbnNcIjogdHJ1ZSxcbiAgICAgICAgICBcIm5vcm1hbGl6ZS1jaGFyYWN0ZXJzXCI6IGZhbHNlLFxuICAgICAgICAgIFwic2NoZW1hLWxvY2F0aW9uXCI6ICcnLFxuICAgICAgICAgIFwic2NoZW1hLXR5cGVcIjogJycsXG4gICAgICAgICAgXCJzcGxpdC1jZGF0YS1zZWN0aW9uc1wiOiB0cnVlLFxuICAgICAgICAgIFwidmFsaWRhdGVcIjogZmFsc2UsXG4gICAgICAgICAgXCJ3ZWxsLWZvcm1lZFwiOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGFyYW1zID0gY2xvbmVkU2VsZiA9IE9iamVjdC5jcmVhdGUodGhpcy5kZWZhdWx0UGFyYW1zKTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0cyB0aGUgdmFsdWUgb2YgYSBwYXJhbWV0ZXIuXG5cbiAgICAgIC8vIGBuYW1lYCBuYW1lIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgIGdldFBhcmFtZXRlcihuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVja3MgaWYgc2V0dGluZyBhIHBhcmFtZXRlciB0byBhIHNwZWNpZmljIHZhbHVlIGlzIHN1cHBvcnRlZC5cblxuICAgICAgLy8gYG5hbWVgIG5hbWUgb2YgdGhlIHBhcmFtZXRlclxuICAgICAgLy8gYHZhbHVlYCBwYXJhbWV0ZXIgdmFsdWVcbiAgICAgIGNhblNldFBhcmFtZXRlcihuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0cyB0aGUgdmFsdWUgb2YgYSBwYXJhbWV0ZXIuXG5cbiAgICAgIC8vIGBuYW1lYCBuYW1lIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICAgIC8vIGB2YWx1ZWAgbmV3IHZhbHVlIG9yIG51bGwgaWYgdGhlIHVzZXIgd2lzaGVzIHRvIHVuc2V0IHRoZSBwYXJhbWV0ZXJcbiAgICAgIHNldFBhcmFtZXRlcihuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWxldGUgdGhpcy5wYXJhbXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIHRoZSBsaXN0IG9mIHBhcmFtZXRlciBuYW1lc1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxET01Db25maWd1cmF0aW9uLnByb3RvdHlwZSwgJ3BhcmFtZXRlck5hbWVzJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYTUxET01TdHJpbmdMaXN0KE9iamVjdC5rZXlzKHRoaXMuZGVmYXVsdFBhcmFtcykpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFhNTERPTUNvbmZpZ3VyYXRpb247XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi40LjFcbihmdW5jdGlvbigpIHtcbiAgLy8gUmVwcmVzZW50cyB0aGUgZXJyb3IgaGFuZGxlciBmb3IgRE9NIG9wZXJhdGlvbnNcbiAgdmFyIFhNTERPTUVycm9ySGFuZGxlcjtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERPTUVycm9ySGFuZGxlciA9IGNsYXNzIFhNTERPTUVycm9ySGFuZGxlciB7XG4gICAgLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYFhNTERPTUVycm9ySGFuZGxlcmBcblxuICAgIGNvbnN0cnVjdG9yKCkge31cblxuICAgIC8vIENhbGxlZCBvbiB0aGUgZXJyb3IgaGFuZGxlciB3aGVuIGFuIGVycm9yIG9jY3Vycy5cblxuICAgIC8vIGBlcnJvcmAgdGhlIGVycm9yIG1lc3NhZ2UgYXMgYSBzdHJpbmdcbiAgICBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi40LjFcbihmdW5jdGlvbigpIHtcbiAgLy8gSW1wbGVtZW50cyB0aGUgRE9NSW1wbGVtZW50YXRpb24gaW50ZXJmYWNlXG4gIHZhciBYTUxET01JbXBsZW1lbnRhdGlvbjtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERPTUltcGxlbWVudGF0aW9uID0gY2xhc3MgWE1MRE9NSW1wbGVtZW50YXRpb24ge1xuICAgIC8vIFRlc3RzIGlmIHRoZSBET00gaW1wbGVtZW50YXRpb24gaW1wbGVtZW50cyBhIHNwZWNpZmljIGZlYXR1cmUuXG5cbiAgICAvLyBgZmVhdHVyZWAgcGFja2FnZSBuYW1lIG9mIHRoZSBmZWF0dXJlIHRvIHRlc3QuIEluIExldmVsIDEsIHRoZVxuICAgIC8vICAgICAgICAgICBsZWdhbCB2YWx1ZXMgYXJlIFwiSFRNTFwiIGFuZCBcIlhNTFwiIChjYXNlLWluc2Vuc2l0aXZlKS5cbiAgICAvLyBgdmVyc2lvbmAgdmVyc2lvbiBudW1iZXIgb2YgdGhlIHBhY2thZ2UgbmFtZSB0byB0ZXN0LiBcbiAgICAvLyAgICAgICAgICAgSW4gTGV2ZWwgMSwgdGhpcyBpcyB0aGUgc3RyaW5nIFwiMS4wXCIuIElmIHRoZSB2ZXJzaW9uIGlzIFxuICAgIC8vICAgICAgICAgICBub3Qgc3BlY2lmaWVkLCBzdXBwb3J0aW5nIGFueSB2ZXJzaW9uIG9mIHRoZSBmZWF0dXJlIHdpbGwgXG4gICAgLy8gICAgICAgICAgIGNhdXNlIHRoZSBtZXRob2QgdG8gcmV0dXJuIHRydWUuXG4gICAgaGFzRmVhdHVyZShmZWF0dXJlLCB2ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGVzIGEgbmV3IGRvY3VtZW50IHR5cGUgZGVjbGFyYXRpb24uXG5cbiAgICAvLyBgcXVhbGlmaWVkTmFtZWAgcXVhbGlmaWVkIG5hbWUgb2YgdGhlIGRvY3VtZW50IHR5cGUgdG8gYmUgY3JlYXRlZFxuICAgIC8vIGBwdWJsaWNJZGAgcHVibGljIGlkZW50aWZpZXIgb2YgdGhlIGV4dGVybmFsIHN1YnNldFxuICAgIC8vIGBzeXN0ZW1JZGAgc3lzdGVtIGlkZW50aWZpZXIgb2YgdGhlIGV4dGVybmFsIHN1YnNldFxuICAgIGNyZWF0ZURvY3VtZW50VHlwZShxdWFsaWZpZWROYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQuXG5cbiAgICAvLyBgbmFtZXNwYWNlVVJJYCBuYW1lc3BhY2UgVVJJIG9mIHRoZSBkb2N1bWVudCBlbGVtZW50IHRvIGNyZWF0ZVxuICAgIC8vIGBxdWFsaWZpZWROYW1lYCB0aGUgcXVhbGlmaWVkIG5hbWUgb2YgdGhlIGRvY3VtZW50IHRvIGJlIGNyZWF0ZWRcbiAgICAvLyBgZG9jdHlwZWAgdGhlIHR5cGUgb2YgZG9jdW1lbnQgdG8gYmUgY3JlYXRlZCBvciBudWxsXG4gICAgY3JlYXRlRG9jdW1lbnQobmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lLCBkb2N0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGVzIGEgbmV3IEhUTUwgZG9jdW1lbnQuXG5cbiAgICAvLyBgdGl0bGVgIGRvY3VtZW50IHRpdGxlXG4gICAgY3JlYXRlSFRNTERvY3VtZW50KHRpdGxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGEgc3BlY2lhbGl6ZWQgb2JqZWN0IHdoaWNoIGltcGxlbWVudHMgdGhlIHNwZWNpYWxpemVkIEFQSXMgXG4gICAgLy8gb2YgdGhlIHNwZWNpZmllZCBmZWF0dXJlIGFuZCB2ZXJzaW9uLlxuXG4gICAgLy8gYGZlYXR1cmVgIG5hbWUgb2YgdGhlIGZlYXR1cmUgcmVxdWVzdGVkLlxuICAgIC8vIGB2ZXJzaW9uYCB2ZXJzaW9uIG51bWJlciBvZiB0aGUgZmVhdHVyZSB0byB0ZXN0XG4gICAgZ2V0RmVhdHVyZShmZWF0dXJlLCB2ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG5cbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi40LjFcbihmdW5jdGlvbigpIHtcbiAgLy8gUmVwcmVzZW50cyBhIGxpc3Qgb2Ygc3RyaW5nIGVudHJpZXNcbiAgdmFyIFhNTERPTVN0cmluZ0xpc3Q7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxET01TdHJpbmdMaXN0ID0gKGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzIFhNTERPTVN0cmluZ0xpc3Qge1xuICAgICAgLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYFhNTERPTVN0cmluZ0xpc3RgXG4gICAgICAvLyBUaGlzIGlzIGp1c3QgYSB3cmFwcGVyIGFyb3VuZCBhbiBvcmRpbmFyeVxuICAgICAgLy8gSlMgYXJyYXkuXG5cbiAgICAgIC8vIGBhcnJgIHRoZSBhcnJheSBvZiBzdHJpbmcgdmFsdWVzXG4gICAgICBjb25zdHJ1Y3RvcihhcnIpIHtcbiAgICAgICAgdGhpcy5hcnIgPSBhcnIgfHwgW107XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybnMgdGhlIGluZGV4dGggaXRlbSBpbiB0aGUgY29sbGVjdGlvbi5cblxuICAgICAgLy8gYGluZGV4YCBpbmRleCBpbnRvIHRoZSBjb2xsZWN0aW9uXG4gICAgICBpdGVtKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycltpbmRleF0gfHwgbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gVGVzdCBpZiBhIHN0cmluZyBpcyBwYXJ0IG9mIHRoaXMgRE9NU3RyaW5nTGlzdC5cblxuICAgICAgLy8gYHN0cmAgdGhlIHN0cmluZyB0byBsb29rIGZvclxuICAgICAgY29udGFpbnMoc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyci5pbmRleE9mKHN0cikgIT09IC0xO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBzdHJpbmdzIGluIHRoZSBsaXN0LlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxET01TdHJpbmdMaXN0LnByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyci5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gWE1MRE9NU3RyaW5nTGlzdDtcblxuICB9KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjQuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgTm9kZVR5cGUsIFhNTERUREF0dExpc3QsIFhNTE5vZGU7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9Ob2RlVHlwZScpO1xuXG4gIC8vIFJlcHJlc2VudHMgYW4gYXR0cmlidXRlIGxpc3RcbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEVERBdHRMaXN0ID0gY2xhc3MgWE1MRFREQXR0TGlzdCBleHRlbmRzIFhNTE5vZGUge1xuICAgIC8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIGBYTUxEVERBdHRMaXN0YFxuXG4gICAgLy8gYHBhcmVudGAgdGhlIHBhcmVudCBgWE1MRG9jVHlwZWAgZWxlbWVudFxuICAgIC8vIGBlbGVtZW50TmFtZWAgdGhlIG5hbWUgb2YgdGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGlzIGF0dHJpYnV0ZVxuICAgIC8vIGBhdHRyaWJ1dGVOYW1lYCBhdHRyaWJ1dGUgbmFtZVxuICAgIC8vIGBhdHRyaWJ1dGVUeXBlYCB0eXBlIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAvLyBgZGVmYXVsdFZhbHVlVHlwZWAgZGVmYXVsdCB2YWx1ZSB0eXBlIChlaXRoZXIgI1JFUVVJUkVELCAjSU1QTElFRCxcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgI0ZJWEVEIG9yICNERUZBVUxUKVxuICAgIC8vIGBkZWZhdWx0VmFsdWVgIGRlZmF1bHQgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgIC8vICAgICAgICAgICAgICAgIChvbmx5IHVzZWQgZm9yICNGSVhFRCBvciAjREVGQVVMVClcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBkZWZhdWx0VmFsdWVUeXBlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHN1cGVyKHBhcmVudCk7XG4gICAgICBpZiAoZWxlbWVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIERURCBlbGVtZW50IG5hbWUuIFwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGF0dHJpYnV0ZSBuYW1lLiBcIiArIHRoaXMuZGVidWdJbmZvKGVsZW1lbnROYW1lKSk7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHJpYnV0ZVR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBEVEQgYXR0cmlidXRlIHR5cGUuIFwiICsgdGhpcy5kZWJ1Z0luZm8oZWxlbWVudE5hbWUpKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGVmYXVsdFZhbHVlVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIERURCBhdHRyaWJ1dGUgZGVmYXVsdC4gXCIgKyB0aGlzLmRlYnVnSW5mbyhlbGVtZW50TmFtZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZVR5cGUuaW5kZXhPZignIycpICE9PSAwKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZVR5cGUgPSAnIycgKyBkZWZhdWx0VmFsdWVUeXBlO1xuICAgICAgfVxuICAgICAgaWYgKCFkZWZhdWx0VmFsdWVUeXBlLm1hdGNoKC9eKCNSRVFVSVJFRHwjSU1QTElFRHwjRklYRUR8I0RFRkFVTFQpJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGVmYXVsdCB2YWx1ZSB0eXBlOyBleHBlY3RlZDogI1JFUVVJUkVELCAjSU1QTElFRCwgI0ZJWEVEIG9yICNERUZBVUxULiBcIiArIHRoaXMuZGVidWdJbmZvKGVsZW1lbnROYW1lKSk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlICYmICFkZWZhdWx0VmFsdWVUeXBlLm1hdGNoKC9eKCNGSVhFRHwjREVGQVVMVCkkLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmYXVsdCB2YWx1ZSBvbmx5IGFwcGxpZXMgdG8gI0ZJWEVEIG9yICNERUZBVUxULiBcIiArIHRoaXMuZGVidWdJbmZvKGVsZW1lbnROYW1lKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmVsZW1lbnROYW1lID0gdGhpcy5zdHJpbmdpZnkubmFtZShlbGVtZW50TmFtZSk7XG4gICAgICB0aGlzLnR5cGUgPSBOb2RlVHlwZS5BdHRyaWJ1dGVEZWNsYXJhdGlvbjtcbiAgICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IHRoaXMuc3RyaW5naWZ5Lm5hbWUoYXR0cmlidXRlTmFtZSk7XG4gICAgICB0aGlzLmF0dHJpYnV0ZVR5cGUgPSB0aGlzLnN0cmluZ2lmeS5kdGRBdHRUeXBlKGF0dHJpYnV0ZVR5cGUpO1xuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHRoaXMuc3RyaW5naWZ5LmR0ZEF0dERlZmF1bHQoZGVmYXVsdFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVmYXVsdFZhbHVlVHlwZSA9IGRlZmF1bHRWYWx1ZVR5cGU7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydHMgdGhlIFhNTCBmcmFnbWVudCB0byBzdHJpbmdcblxuICAgIC8vIGBvcHRpb25zLnByZXR0eWAgcHJldHR5IHByaW50cyB0aGUgcmVzdWx0XG4gICAgLy8gYG9wdGlvbnMuaW5kZW50YCBpbmRlbnRhdGlvbiBmb3IgcHJldHR5IHByaW50XG4gICAgLy8gYG9wdGlvbnMub2Zmc2V0YCBob3cgbWFueSBpbmRlbnRhdGlvbnMgdG8gYWRkIHRvIGV2ZXJ5IGxpbmUgZm9yIHByZXR0eSBwcmludFxuICAgIC8vIGBvcHRpb25zLm5ld2xpbmVgIG5ld2xpbmUgc2VxdWVuY2UgZm9yIHByZXR0eSBwcmludFxuICAgIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLmR0ZEF0dExpc3QodGhpcywgdGhpcy5vcHRpb25zLndyaXRlci5maWx0ZXJPcHRpb25zKG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi40LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIE5vZGVUeXBlLCBYTUxEVERFbGVtZW50LCBYTUxOb2RlO1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vTm9kZVR5cGUnKTtcblxuICAvLyBSZXByZXNlbnRzIGFuIGF0dHJpYnV0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERUREVsZW1lbnQgPSBjbGFzcyBYTUxEVERFbGVtZW50IGV4dGVuZHMgWE1MTm9kZSB7XG4gICAgLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYFhNTERUREVsZW1lbnRgXG5cbiAgICAvLyBgcGFyZW50YCB0aGUgcGFyZW50IGBYTUxEb2NUeXBlYCBlbGVtZW50XG4gICAgLy8gYG5hbWVgIGVsZW1lbnQgbmFtZVxuICAgIC8vIGB2YWx1ZWAgZWxlbWVudCBjb250ZW50IChkZWZhdWx0cyB0byAjUENEQVRBKVxuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHN1cGVyKHBhcmVudCk7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGVsZW1lbnQgbmFtZS4gXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSAnKCNQQ0RBVEEpJztcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9ICcoJyArIHZhbHVlLmpvaW4oJywnKSArICcpJztcbiAgICAgIH1cbiAgICAgIHRoaXMubmFtZSA9IHRoaXMuc3RyaW5naWZ5Lm5hbWUobmFtZSk7XG4gICAgICB0aGlzLnR5cGUgPSBOb2RlVHlwZS5FbGVtZW50RGVjbGFyYXRpb247XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5zdHJpbmdpZnkuZHRkRWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0cyB0aGUgWE1MIGZyYWdtZW50IHRvIHN0cmluZ1xuXG4gICAgLy8gYG9wdGlvbnMucHJldHR5YCBwcmV0dHkgcHJpbnRzIHRoZSByZXN1bHRcbiAgICAvLyBgb3B0aW9ucy5pbmRlbnRgIGluZGVudGF0aW9uIGZvciBwcmV0dHkgcHJpbnRcbiAgICAvLyBgb3B0aW9ucy5vZmZzZXRgIGhvdyBtYW55IGluZGVudGF0aW9ucyB0byBhZGQgdG8gZXZlcnkgbGluZSBmb3IgcHJldHR5IHByaW50XG4gICAgLy8gYG9wdGlvbnMubmV3bGluZWAgbmV3bGluZSBzZXF1ZW5jZSBmb3IgcHJldHR5IHByaW50XG4gICAgdG9TdHJpbmcob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cml0ZXIuZHRkRWxlbWVudCh0aGlzLCB0aGlzLm9wdGlvbnMud3JpdGVyLmZpbHRlck9wdGlvbnMob3B0aW9ucykpO1xuICAgIH1cblxuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjQuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgTm9kZVR5cGUsIFhNTERUREVudGl0eSwgWE1MTm9kZSwgaXNPYmplY3Q7XG5cbiAgKHtpc09iamVjdH0gPSByZXF1aXJlKCcuL1V0aWxpdHknKSk7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9Ob2RlVHlwZScpO1xuXG4gIC8vIFJlcHJlc2VudHMgYW4gZW50aXR5IGRlY2xhcmF0aW9uIGluIHRoZSBEVERcbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEVERFbnRpdHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgWE1MRFRERW50aXR5IGV4dGVuZHMgWE1MTm9kZSB7XG4gICAgICAvLyBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiBgWE1MRFRERW50aXR5YFxuXG4gICAgICAvLyBgcGFyZW50YCB0aGUgcGFyZW50IGBYTUxEb2NUeXBlYCBlbGVtZW50XG4gICAgICAvLyBgcGVgIHdoZXRoZXIgdGhpcyBpcyBhIHBhcmFtZXRlciBlbnRpdHkgb3IgYSBnZW5lcmFsIGVudGl0eVxuICAgICAgLy8gICAgICBkZWZhdWx0cyB0byBgZmFsc2VgIChnZW5lcmFsIGVudGl0eSlcbiAgICAgIC8vIGBuYW1lYCB0aGUgbmFtZSBvZiB0aGUgZW50aXR5XG4gICAgICAvLyBgdmFsdWVgIGludGVybmFsIGVudGl0eSB2YWx1ZSBvciBhbiBvYmplY3Qgd2l0aCBleHRlcm5hbCBlbnRpdHkgZGV0YWlsc1xuICAgICAgLy8gYHZhbHVlLnB1YklEYCBwdWJsaWMgaWRlbnRpZmllclxuICAgICAgLy8gYHZhbHVlLnN5c0lEYCBzeXN0ZW0gaWRlbnRpZmllclxuICAgICAgLy8gYHZhbHVlLm5EYXRhYCBub3RhdGlvbiBkZWNsYXJhdGlvblxuICAgICAgY29uc3RydWN0b3IocGFyZW50LCBwZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIocGFyZW50KTtcbiAgICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGVudGl0eSBuYW1lLiBcIiArIHRoaXMuZGVidWdJbmZvKG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGVudGl0eSB2YWx1ZS4gXCIgKyB0aGlzLmRlYnVnSW5mbyhuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZSA9ICEhcGU7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuc3RyaW5naWZ5Lm5hbWUobmFtZSk7XG4gICAgICAgIHRoaXMudHlwZSA9IE5vZGVUeXBlLkVudGl0eURlY2xhcmF0aW9uO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5kdGRFbnRpdHlWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgdGhpcy5pbnRlcm5hbCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF2YWx1ZS5wdWJJRCAmJiAhdmFsdWUuc3lzSUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlB1YmxpYyBhbmQvb3Igc3lzdGVtIGlkZW50aWZpZXJzIGFyZSByZXF1aXJlZCBmb3IgYW4gZXh0ZXJuYWwgZW50aXR5LiBcIiArIHRoaXMuZGVidWdJbmZvKG5hbWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlLnB1YklEICYmICF2YWx1ZS5zeXNJRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3lzdGVtIGlkZW50aWZpZXIgaXMgcmVxdWlyZWQgZm9yIGEgcHVibGljIGV4dGVybmFsIGVudGl0eS4gXCIgKyB0aGlzLmRlYnVnSW5mbyhuYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaW50ZXJuYWwgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodmFsdWUucHViSUQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wdWJJRCA9IHRoaXMuc3RyaW5naWZ5LmR0ZFB1YklEKHZhbHVlLnB1YklEKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlLnN5c0lEICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3lzSUQgPSB0aGlzLnN0cmluZ2lmeS5kdGRTeXNJRCh2YWx1ZS5zeXNJRCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZS5uRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm5EYXRhID0gdGhpcy5zdHJpbmdpZnkuZHRkTkRhdGEodmFsdWUubkRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5wZSAmJiB0aGlzLm5EYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3RhdGlvbiBkZWNsYXJhdGlvbiBpcyBub3QgYWxsb3dlZCBpbiBhIHBhcmFtZXRlciBlbnRpdHkuIFwiICsgdGhpcy5kZWJ1Z0luZm8obmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDb252ZXJ0cyB0aGUgWE1MIGZyYWdtZW50IHRvIHN0cmluZ1xuXG4gICAgICAvLyBgb3B0aW9ucy5wcmV0dHlgIHByZXR0eSBwcmludHMgdGhlIHJlc3VsdFxuICAgICAgLy8gYG9wdGlvbnMuaW5kZW50YCBpbmRlbnRhdGlvbiBmb3IgcHJldHR5IHByaW50XG4gICAgICAvLyBgb3B0aW9ucy5vZmZzZXRgIGhvdyBtYW55IGluZGVudGF0aW9ucyB0byBhZGQgdG8gZXZlcnkgbGluZSBmb3IgcHJldHR5IHByaW50XG4gICAgICAvLyBgb3B0aW9ucy5uZXdsaW5lYCBuZXdsaW5lIHNlcXVlbmNlIGZvciBwcmV0dHkgcHJpbnRcbiAgICAgIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cml0ZXIuZHRkRW50aXR5KHRoaXMsIHRoaXMub3B0aW9ucy53cml0ZXIuZmlsdGVyT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgLy8gRE9NIGxldmVsIDFcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MRFRERW50aXR5LnByb3RvdHlwZSwgJ3B1YmxpY0lkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHViSUQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MRFRERW50aXR5LnByb3RvdHlwZSwgJ3N5c3RlbUlkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3lzSUQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MRFRERW50aXR5LnByb3RvdHlwZSwgJ25vdGF0aW9uTmFtZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5EYXRhIHx8IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBET00gbGV2ZWwgM1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxEVERFbnRpdHkucHJvdG90eXBlLCAnaW5wdXRFbmNvZGluZycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTERUREVudGl0eS5wcm90b3R5cGUsICd4bWxFbmNvZGluZycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTERUREVudGl0eS5wcm90b3R5cGUsICd4bWxWZXJzaW9uJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gWE1MRFRERW50aXR5O1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuNC4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBOb2RlVHlwZSwgWE1MRFRETm90YXRpb24sIFhNTE5vZGU7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9Ob2RlVHlwZScpO1xuXG4gIC8vIFJlcHJlc2VudHMgYSBOT1RBVElPTiBlbnRyeSBpbiB0aGUgRFREXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MRFRETm90YXRpb24gPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgWE1MRFRETm90YXRpb24gZXh0ZW5kcyBYTUxOb2RlIHtcbiAgICAgIC8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIGBYTUxEVEROb3RhdGlvbmBcblxuICAgICAgLy8gYHBhcmVudGAgdGhlIHBhcmVudCBgWE1MRG9jVHlwZWAgZWxlbWVudFxuICAgICAgLy8gYG5hbWVgIHRoZSBuYW1lIG9mIHRoZSBub3RhdGlvblxuICAgICAgLy8gYHZhbHVlYCBhbiBvYmplY3Qgd2l0aCBleHRlcm5hbCBlbnRpdHkgZGV0YWlsc1xuICAgICAgLy8gYHZhbHVlLnB1YklEYCBwdWJsaWMgaWRlbnRpZmllclxuICAgICAgLy8gYHZhbHVlLnN5c0lEYCBzeXN0ZW0gaWRlbnRpZmllclxuICAgICAgY29uc3RydWN0b3IocGFyZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcihwYXJlbnQpO1xuICAgICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBEVEQgbm90YXRpb24gbmFtZS4gXCIgKyB0aGlzLmRlYnVnSW5mbyhuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZS5wdWJJRCAmJiAhdmFsdWUuc3lzSUQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQdWJsaWMgb3Igc3lzdGVtIGlkZW50aWZpZXJzIGFyZSByZXF1aXJlZCBmb3IgYW4gZXh0ZXJuYWwgZW50aXR5LiBcIiArIHRoaXMuZGVidWdJbmZvKG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLnN0cmluZ2lmeS5uYW1lKG5hbWUpO1xuICAgICAgICB0aGlzLnR5cGUgPSBOb2RlVHlwZS5Ob3RhdGlvbkRlY2xhcmF0aW9uO1xuICAgICAgICBpZiAodmFsdWUucHViSUQgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucHViSUQgPSB0aGlzLnN0cmluZ2lmeS5kdGRQdWJJRCh2YWx1ZS5wdWJJRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnN5c0lEICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnN5c0lEID0gdGhpcy5zdHJpbmdpZnkuZHRkU3lzSUQodmFsdWUuc3lzSUQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnZlcnRzIHRoZSBYTUwgZnJhZ21lbnQgdG8gc3RyaW5nXG5cbiAgICAgIC8vIGBvcHRpb25zLnByZXR0eWAgcHJldHR5IHByaW50cyB0aGUgcmVzdWx0XG4gICAgICAvLyBgb3B0aW9ucy5pbmRlbnRgIGluZGVudGF0aW9uIGZvciBwcmV0dHkgcHJpbnRcbiAgICAgIC8vIGBvcHRpb25zLm9mZnNldGAgaG93IG1hbnkgaW5kZW50YXRpb25zIHRvIGFkZCB0byBldmVyeSBsaW5lIGZvciBwcmV0dHkgcHJpbnRcbiAgICAgIC8vIGBvcHRpb25zLm5ld2xpbmVgIG5ld2xpbmUgc2VxdWVuY2UgZm9yIHByZXR0eSBwcmludFxuICAgICAgdG9TdHJpbmcob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5kdGROb3RhdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMud3JpdGVyLmZpbHRlck9wdGlvbnMob3B0aW9ucykpO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIERPTSBsZXZlbCAxXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTERURE5vdGF0aW9uLnByb3RvdHlwZSwgJ3B1YmxpY0lkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHViSUQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MRFRETm90YXRpb24ucHJvdG90eXBlLCAnc3lzdGVtSWQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeXNJRDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBYTUxEVEROb3RhdGlvbjtcblxuICB9KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjQuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgTm9kZVR5cGUsIFhNTERlY2xhcmF0aW9uLCBYTUxOb2RlLCBpc09iamVjdDtcblxuICAoe2lzT2JqZWN0fSA9IHJlcXVpcmUoJy4vVXRpbGl0eScpKTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgTm9kZVR5cGUgPSByZXF1aXJlKCcuL05vZGVUeXBlJyk7XG5cbiAgLy8gUmVwcmVzZW50cyB0aGUgWE1MIGRlY2xhcmF0aW9uXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MRGVjbGFyYXRpb24gPSBjbGFzcyBYTUxEZWNsYXJhdGlvbiBleHRlbmRzIFhNTE5vZGUge1xuICAgIC8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIGBYTUxEZWNsYXJhdGlvbmBcblxuICAgIC8vIGBwYXJlbnRgIHRoZSBkb2N1bWVudCBvYmplY3RcblxuICAgIC8vIGB2ZXJzaW9uYCBBIHZlcnNpb24gbnVtYmVyIHN0cmluZywgZS5nLiAxLjBcbiAgICAvLyBgZW5jb2RpbmdgIEVuY29kaW5nIGRlY2xhcmF0aW9uLCBlLmcuIFVURi04XG4gICAgLy8gYHN0YW5kYWxvbmVgIHN0YW5kYWxvbmUgZG9jdW1lbnQgZGVjbGFyYXRpb246IHRydWUgb3IgZmFsc2VcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKSB7XG4gICAgICBzdXBlcihwYXJlbnQpO1xuICAgICAgLy8gYXJndW1lbnRzIG1heSBhbHNvIGJlIHBhc3NlZCBhcyBhbiBvYmplY3RcbiAgICAgIGlmIChpc09iamVjdCh2ZXJzaW9uKSkge1xuICAgICAgICAoe3ZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lfSA9IHZlcnNpb24pO1xuICAgICAgfVxuICAgICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICAgIHZlcnNpb24gPSAnMS4wJztcbiAgICAgIH1cbiAgICAgIHRoaXMudHlwZSA9IE5vZGVUeXBlLkRlY2xhcmF0aW9uO1xuICAgICAgdGhpcy52ZXJzaW9uID0gdGhpcy5zdHJpbmdpZnkueG1sVmVyc2lvbih2ZXJzaW9uKTtcbiAgICAgIGlmIChlbmNvZGluZyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSB0aGlzLnN0cmluZ2lmeS54bWxFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhbmRhbG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhbmRhbG9uZSA9IHRoaXMuc3RyaW5naWZ5LnhtbFN0YW5kYWxvbmUoc3RhbmRhbG9uZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29udmVydHMgdG8gc3RyaW5nXG5cbiAgICAvLyBgb3B0aW9ucy5wcmV0dHlgIHByZXR0eSBwcmludHMgdGhlIHJlc3VsdFxuICAgIC8vIGBvcHRpb25zLmluZGVudGAgaW5kZW50YXRpb24gZm9yIHByZXR0eSBwcmludFxuICAgIC8vIGBvcHRpb25zLm9mZnNldGAgaG93IG1hbnkgaW5kZW50YXRpb25zIHRvIGFkZCB0byBldmVyeSBsaW5lIGZvciBwcmV0dHkgcHJpbnRcbiAgICAvLyBgb3B0aW9ucy5uZXdsaW5lYCBuZXdsaW5lIHNlcXVlbmNlIGZvciBwcmV0dHkgcHJpbnRcbiAgICB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5kZWNsYXJhdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMud3JpdGVyLmZpbHRlck9wdGlvbnMob3B0aW9ucykpO1xuICAgIH1cblxuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjQuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgTm9kZVR5cGUsIFhNTERUREF0dExpc3QsIFhNTERUREVsZW1lbnQsIFhNTERUREVudGl0eSwgWE1MRFRETm90YXRpb24sIFhNTERvY1R5cGUsIFhNTE5hbWVkTm9kZU1hcCwgWE1MTm9kZSwgaXNPYmplY3Q7XG5cbiAgKHtpc09iamVjdH0gPSByZXF1aXJlKCcuL1V0aWxpdHknKSk7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9Ob2RlVHlwZScpO1xuXG4gIFhNTERUREF0dExpc3QgPSByZXF1aXJlKCcuL1hNTERUREF0dExpc3QnKTtcblxuICBYTUxEVERFbnRpdHkgPSByZXF1aXJlKCcuL1hNTERUREVudGl0eScpO1xuXG4gIFhNTERUREVsZW1lbnQgPSByZXF1aXJlKCcuL1hNTERUREVsZW1lbnQnKTtcblxuICBYTUxEVEROb3RhdGlvbiA9IHJlcXVpcmUoJy4vWE1MRFRETm90YXRpb24nKTtcblxuICBYTUxOYW1lZE5vZGVNYXAgPSByZXF1aXJlKCcuL1hNTE5hbWVkTm9kZU1hcCcpO1xuXG4gIC8vIFJlcHJlc2VudHMgZG9jdHlwZSBkZWNsYXJhdGlvblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERvY1R5cGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgWE1MRG9jVHlwZSBleHRlbmRzIFhNTE5vZGUge1xuICAgICAgLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYFhNTERvY1R5cGVgXG5cbiAgICAgIC8vIGBwYXJlbnRgIHRoZSBkb2N1bWVudCBvYmplY3RcblxuICAgICAgLy8gYHB1YklEYCBwdWJsaWMgaWRlbnRpZmllciBvZiB0aGUgZXh0ZXJuYWwgc3Vic2V0XG4gICAgICAvLyBgc3lzSURgIHN5c3RlbSBpZGVudGlmaWVyIG9mIHRoZSBleHRlcm5hbCBzdWJzZXRcbiAgICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgcHViSUQsIHN5c0lEKSB7XG4gICAgICAgIHZhciBjaGlsZCwgaSwgbGVuLCByZWY7XG4gICAgICAgIHN1cGVyKHBhcmVudCk7XG4gICAgICAgIHRoaXMudHlwZSA9IE5vZGVUeXBlLkRvY1R5cGU7XG4gICAgICAgIC8vIHNldCBEVEQgbmFtZSB0byB0aGUgbmFtZSBvZiB0aGUgcm9vdCBub2RlXG4gICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgICByZWYgPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHJlZltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMubmFtZSA9IGNoaWxkLm5hbWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvY3VtZW50T2JqZWN0ID0gcGFyZW50O1xuICAgICAgICAvLyBhcmd1bWVudHMgbWF5IGFsc28gYmUgcGFzc2VkIGFzIGFuIG9iamVjdFxuICAgICAgICBpZiAoaXNPYmplY3QocHViSUQpKSB7XG4gICAgICAgICAgKHtwdWJJRCwgc3lzSUR9ID0gcHViSUQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzeXNJRCA9PSBudWxsKSB7XG4gICAgICAgICAgW3N5c0lELCBwdWJJRF0gPSBbcHViSUQsIHN5c0lEXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHViSUQgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucHViSUQgPSB0aGlzLnN0cmluZ2lmeS5kdGRQdWJJRChwdWJJRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN5c0lEICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnN5c0lEID0gdGhpcy5zdHJpbmdpZnkuZHRkU3lzSUQoc3lzSUQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZXMgYW4gZWxlbWVudCB0eXBlIGRlY2xhcmF0aW9uXG5cbiAgICAgIC8vIGBuYW1lYCBlbGVtZW50IG5hbWVcbiAgICAgIC8vIGB2YWx1ZWAgZWxlbWVudCBjb250ZW50IChkZWZhdWx0cyB0byAjUENEQVRBKVxuICAgICAgZWxlbWVudChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIGNoaWxkID0gbmV3IFhNTERUREVsZW1lbnQodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGUgZGVjbGFyYXRpb25cblxuICAgICAgLy8gYGVsZW1lbnROYW1lYCB0aGUgbmFtZSBvZiB0aGUgZWxlbWVudCBjb250YWluaW5nIHRoaXMgYXR0cmlidXRlXG4gICAgICAvLyBgYXR0cmlidXRlTmFtZWAgYXR0cmlidXRlIG5hbWVcbiAgICAgIC8vIGBhdHRyaWJ1dGVUeXBlYCB0eXBlIG9mIHRoZSBhdHRyaWJ1dGUgKGRlZmF1bHRzIHRvIENEQVRBKVxuICAgICAgLy8gYGRlZmF1bHRWYWx1ZVR5cGVgIGRlZmF1bHQgdmFsdWUgdHlwZSAoZWl0aGVyICNSRVFVSVJFRCwgI0lNUExJRUQsICNGSVhFRCBvclxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICNERUZBVUxUKSAoZGVmYXVsdHMgdG8gI0lNUExJRUQpXG4gICAgICAvLyBgZGVmYXVsdFZhbHVlYCBkZWZhdWx0IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgIC8vICAgICAgICAgICAgICAgIChvbmx5IHVzZWQgZm9yICNGSVhFRCBvciAjREVGQVVMVClcbiAgICAgIGF0dExpc3QoZWxlbWVudE5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGRlZmF1bHRWYWx1ZVR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIGNoaWxkID0gbmV3IFhNTERUREF0dExpc3QodGhpcywgZWxlbWVudE5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGRlZmF1bHRWYWx1ZVR5cGUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGVzIGEgZ2VuZXJhbCBlbnRpdHkgZGVjbGFyYXRpb25cblxuICAgICAgLy8gYG5hbWVgIHRoZSBuYW1lIG9mIHRoZSBlbnRpdHlcbiAgICAgIC8vIGB2YWx1ZWAgaW50ZXJuYWwgZW50aXR5IHZhbHVlIG9yIGFuIG9iamVjdCB3aXRoIGV4dGVybmFsIGVudGl0eSBkZXRhaWxzXG4gICAgICAvLyBgdmFsdWUucHViSURgIHB1YmxpYyBpZGVudGlmaWVyXG4gICAgICAvLyBgdmFsdWUuc3lzSURgIHN5c3RlbSBpZGVudGlmaWVyXG4gICAgICAvLyBgdmFsdWUubkRhdGFgIG5vdGF0aW9uIGRlY2xhcmF0aW9uXG4gICAgICBlbnRpdHkobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICBjaGlsZCA9IG5ldyBYTUxEVERFbnRpdHkodGhpcywgZmFsc2UsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZXMgYSBwYXJhbWV0ZXIgZW50aXR5IGRlY2xhcmF0aW9uXG5cbiAgICAgIC8vIGBuYW1lYCB0aGUgbmFtZSBvZiB0aGUgZW50aXR5XG4gICAgICAvLyBgdmFsdWVgIGludGVybmFsIGVudGl0eSB2YWx1ZSBvciBhbiBvYmplY3Qgd2l0aCBleHRlcm5hbCBlbnRpdHkgZGV0YWlsc1xuICAgICAgLy8gYHZhbHVlLnB1YklEYCBwdWJsaWMgaWRlbnRpZmllclxuICAgICAgLy8gYHZhbHVlLnN5c0lEYCBzeXN0ZW0gaWRlbnRpZmllclxuICAgICAgcEVudGl0eShuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIGNoaWxkID0gbmV3IFhNTERUREVudGl0eSh0aGlzLCB0cnVlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGVzIGEgTk9UQVRJT04gZGVjbGFyYXRpb25cblxuICAgICAgLy8gYG5hbWVgIHRoZSBuYW1lIG9mIHRoZSBub3RhdGlvblxuICAgICAgLy8gYHZhbHVlYCBhbiBvYmplY3Qgd2l0aCBleHRlcm5hbCBlbnRpdHkgZGV0YWlsc1xuICAgICAgLy8gYHZhbHVlLnB1YklEYCBwdWJsaWMgaWRlbnRpZmllclxuICAgICAgLy8gYHZhbHVlLnN5c0lEYCBzeXN0ZW0gaWRlbnRpZmllclxuICAgICAgbm90YXRpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICBjaGlsZCA9IG5ldyBYTUxEVEROb3RhdGlvbih0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBDb252ZXJ0cyB0byBzdHJpbmdcblxuICAgICAgLy8gYG9wdGlvbnMucHJldHR5YCBwcmV0dHkgcHJpbnRzIHRoZSByZXN1bHRcbiAgICAgIC8vIGBvcHRpb25zLmluZGVudGAgaW5kZW50YXRpb24gZm9yIHByZXR0eSBwcmludFxuICAgICAgLy8gYG9wdGlvbnMub2Zmc2V0YCBob3cgbWFueSBpbmRlbnRhdGlvbnMgdG8gYWRkIHRvIGV2ZXJ5IGxpbmUgZm9yIHByZXR0eSBwcmludFxuICAgICAgLy8gYG9wdGlvbnMubmV3bGluZWAgbmV3bGluZSBzZXF1ZW5jZSBmb3IgcHJldHR5IHByaW50XG4gICAgICB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLmRvY1R5cGUodGhpcywgdGhpcy5vcHRpb25zLndyaXRlci5maWx0ZXJPcHRpb25zKG9wdGlvbnMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWxpYXNlc1xuICAgICAgZWxlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBhdHQoZWxlbWVudE5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGRlZmF1bHRWYWx1ZVR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRMaXN0KGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBkZWZhdWx0VmFsdWVUeXBlLCBkZWZhdWx0VmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBlbnQobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50aXR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcGVudChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wRW50aXR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgbm90KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vdGF0aW9uKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QoKSB8fCB0aGlzLmRvY3VtZW50T2JqZWN0O1xuICAgICAgfVxuXG4gICAgICBpc0VxdWFsTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghc3VwZXIuaXNFcXVhbE5vZGUobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubmFtZSAhPT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnB1YmxpY0lkICE9PSB0aGlzLnB1YmxpY0lkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnN5c3RlbUlkICE9PSB0aGlzLnN5c3RlbUlkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIERPTSBsZXZlbCAxXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTERvY1R5cGUucHJvdG90eXBlLCAnZW50aXRpZXMnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hpbGQsIGksIGxlbiwgbm9kZXMsIHJlZjtcbiAgICAgICAgbm9kZXMgPSB7fTtcbiAgICAgICAgcmVmID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWZbaV07XG4gICAgICAgICAgaWYgKChjaGlsZC50eXBlID09PSBOb2RlVHlwZS5FbnRpdHlEZWNsYXJhdGlvbikgJiYgIWNoaWxkLnBlKSB7XG4gICAgICAgICAgICBub2Rlc1tjaGlsZC5uYW1lXSA9IGNoaWxkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFhNTE5hbWVkTm9kZU1hcChub2Rlcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MRG9jVHlwZS5wcm90b3R5cGUsICdub3RhdGlvbnMnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hpbGQsIGksIGxlbiwgbm9kZXMsIHJlZjtcbiAgICAgICAgbm9kZXMgPSB7fTtcbiAgICAgICAgcmVmID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWZbaV07XG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IE5vZGVUeXBlLk5vdGF0aW9uRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIG5vZGVzW2NoaWxkLm5hbWVdID0gY2hpbGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWE1MTmFtZWROb2RlTWFwKG5vZGVzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIERPTSBsZXZlbCAyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTERvY1R5cGUucHJvdG90eXBlLCAncHVibGljSWQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJJRDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxEb2NUeXBlLnByb3RvdHlwZSwgJ3N5c3RlbUlkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3lzSUQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MRG9jVHlwZS5wcm90b3R5cGUsICdpbnRlcm5hbFN1YnNldCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBYTUxEb2NUeXBlO1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuNC4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBOb2RlVHlwZSwgWE1MRE9NQ29uZmlndXJhdGlvbiwgWE1MRE9NSW1wbGVtZW50YXRpb24sIFhNTERvY3VtZW50LCBYTUxOb2RlLCBYTUxTdHJpbmdXcml0ZXIsIFhNTFN0cmluZ2lmaWVyLCBpc1BsYWluT2JqZWN0O1xuXG4gICh7aXNQbGFpbk9iamVjdH0gPSByZXF1aXJlKCcuL1V0aWxpdHknKSk7XG5cbiAgWE1MRE9NSW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL1hNTERPTUltcGxlbWVudGF0aW9uJyk7XG5cbiAgWE1MRE9NQ29uZmlndXJhdGlvbiA9IHJlcXVpcmUoJy4vWE1MRE9NQ29uZmlndXJhdGlvbicpO1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vTm9kZVR5cGUnKTtcblxuICBYTUxTdHJpbmdpZmllciA9IHJlcXVpcmUoJy4vWE1MU3RyaW5naWZpZXInKTtcblxuICBYTUxTdHJpbmdXcml0ZXIgPSByZXF1aXJlKCcuL1hNTFN0cmluZ1dyaXRlcicpO1xuXG4gIC8vIFJlcHJlc2VudHMgYW4gWE1MIGJ1aWxkZXJcbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEb2N1bWVudCA9IChmdW5jdGlvbigpIHtcbiAgICBjbGFzcyBYTUxEb2N1bWVudCBleHRlbmRzIFhNTE5vZGUge1xuICAgICAgLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYFhNTERvY3VtZW50YFxuXG4gICAgICAvLyBgb3B0aW9ucy5rZWVwTnVsbE5vZGVzYCB3aGV0aGVyIG5vZGVzIHdpdGggbnVsbCB2YWx1ZXMgd2lsbCBiZSBrZXB0XG4gICAgICAvLyAgICAgb3IgaWdub3JlZDogdHJ1ZSBvciBmYWxzZVxuICAgICAgLy8gYG9wdGlvbnMua2VlcE51bGxBdHRyaWJ1dGVzYCB3aGV0aGVyIGF0dHJpYnV0ZXMgd2l0aCBudWxsIHZhbHVlcyB3aWxsIGJlXG4gICAgICAvLyAgICAga2VwdCBvciBpZ25vcmVkOiB0cnVlIG9yIGZhbHNlXG4gICAgICAvLyBgb3B0aW9ucy5pZ25vcmVEZWNvcmF0b3JzYCB3aGV0aGVyIGRlY29yYXRvciBzdHJpbmdzIHdpbGwgYmUgaWdub3JlZCB3aGVuXG4gICAgICAvLyAgICAgY29udmVydGluZyBKUyBvYmplY3RzOiB0cnVlIG9yIGZhbHNlXG4gICAgICAvLyBgb3B0aW9ucy5zZXBhcmF0ZUFycmF5SXRlbXNgIHdoZXRoZXIgYXJyYXkgaXRlbXMgYXJlIGNyZWF0ZWQgYXMgc2VwYXJhdGVcbiAgICAgIC8vICAgICBub2RlcyB3aGVuIHBhc3NlZCBhcyBhbiBvYmplY3QgdmFsdWU6IHRydWUgb3IgZmFsc2VcbiAgICAgIC8vIGBvcHRpb25zLm5vRG91YmxlRW5jb2RpbmdgIHdoZXRoZXIgZXhpc3RpbmcgaHRtbCBlbnRpdGllcyBhcmUgZW5jb2RlZDpcbiAgICAgIC8vICAgICB0cnVlIG9yIGZhbHNlXG4gICAgICAvLyBgb3B0aW9ucy5zdHJpbmdpZnlgIGEgc2V0IG9mIGZ1bmN0aW9ucyB0byB1c2UgZm9yIGNvbnZlcnRpbmcgdmFsdWVzIHRvXG4gICAgICAvLyAgICAgc3RyaW5nc1xuICAgICAgLy8gYG9wdGlvbnMud3JpdGVyYCB0aGUgZGVmYXVsdCBYTUwgd3JpdGVyIHRvIHVzZSBmb3IgY29udmVydGluZyBub2RlcyB0b1xuICAgICAgLy8gICAgIHN0cmluZy4gSWYgdGhlIGRlZmF1bHQgd3JpdGVyIGlzIG5vdCBzZXQsIHRoZSBidWlsdC1pbiBYTUxTdHJpbmdXcml0ZXJcbiAgICAgIC8vICAgICB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobnVsbCk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiI2RvY3VtZW50XCI7XG4gICAgICAgIHRoaXMudHlwZSA9IE5vZGVUeXBlLkRvY3VtZW50O1xuICAgICAgICB0aGlzLmRvY3VtZW50VVJJID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb21Db25maWcgPSBuZXcgWE1MRE9NQ29uZmlndXJhdGlvbigpO1xuICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICBpZiAoIW9wdGlvbnMud3JpdGVyKSB7XG4gICAgICAgICAgb3B0aW9ucy53cml0ZXIgPSBuZXcgWE1MU3RyaW5nV3JpdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5zdHJpbmdpZnkgPSBuZXcgWE1MU3RyaW5naWZpZXIob3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVuZHMgdGhlIGRvY3VtZW50IGFuZCBwYXNzZXMgaXQgdG8gdGhlIGdpdmVuIFhNTCB3cml0ZXJcblxuICAgICAgLy8gYHdyaXRlcmAgaXMgZWl0aGVyIGFuIFhNTCB3cml0ZXIgb3IgYSBwbGFpbiBvYmplY3QgdG8gcGFzcyB0byB0aGVcbiAgICAgIC8vIGNvbnN0cnVjdG9yIG9mIHRoZSBkZWZhdWx0IFhNTCB3cml0ZXIuIFRoZSBkZWZhdWx0IHdyaXRlciBpcyBhc3NpZ25lZCB3aGVuXG4gICAgICAvLyBjcmVhdGluZyB0aGUgWE1MIGRvY3VtZW50LiBGb2xsb3dpbmcgZmxhZ3MgYXJlIHJlY29nbml6ZWQgYnkgdGhlXG4gICAgICAvLyBidWlsdC1pbiBYTUxTdHJpbmdXcml0ZXI6XG4gICAgICAvLyAgIGB3cml0ZXIucHJldHR5YCBwcmV0dHkgcHJpbnRzIHRoZSByZXN1bHRcbiAgICAgIC8vICAgYHdyaXRlci5pbmRlbnRgIGluZGVudGF0aW9uIGZvciBwcmV0dHkgcHJpbnRcbiAgICAgIC8vICAgYHdyaXRlci5vZmZzZXRgIGhvdyBtYW55IGluZGVudGF0aW9ucyB0byBhZGQgdG8gZXZlcnkgbGluZSBmb3IgcHJldHR5IHByaW50XG4gICAgICAvLyAgIGB3cml0ZXIubmV3bGluZWAgbmV3bGluZSBzZXF1ZW5jZSBmb3IgcHJldHR5IHByaW50XG4gICAgICBlbmQod3JpdGVyKSB7XG4gICAgICAgIHZhciB3cml0ZXJPcHRpb25zO1xuICAgICAgICB3cml0ZXJPcHRpb25zID0ge307XG4gICAgICAgIGlmICghd3JpdGVyKSB7XG4gICAgICAgICAgd3JpdGVyID0gdGhpcy5vcHRpb25zLndyaXRlcjtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHdyaXRlcikpIHtcbiAgICAgICAgICB3cml0ZXJPcHRpb25zID0gd3JpdGVyO1xuICAgICAgICAgIHdyaXRlciA9IHRoaXMub3B0aW9ucy53cml0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlci5kb2N1bWVudCh0aGlzLCB3cml0ZXIuZmlsdGVyT3B0aW9ucyh3cml0ZXJPcHRpb25zKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnZlcnRzIHRoZSBYTUwgZG9jdW1lbnQgdG8gc3RyaW5nXG5cbiAgICAgIC8vIGBvcHRpb25zLnByZXR0eWAgcHJldHR5IHByaW50cyB0aGUgcmVzdWx0XG4gICAgICAvLyBgb3B0aW9ucy5pbmRlbnRgIGluZGVudGF0aW9uIGZvciBwcmV0dHkgcHJpbnRcbiAgICAgIC8vIGBvcHRpb25zLm9mZnNldGAgaG93IG1hbnkgaW5kZW50YXRpb25zIHRvIGFkZCB0byBldmVyeSBsaW5lIGZvciBwcmV0dHkgcHJpbnRcbiAgICAgIC8vIGBvcHRpb25zLm5ld2xpbmVgIG5ld2xpbmUgc2VxdWVuY2UgZm9yIHByZXR0eSBwcmludFxuICAgICAgdG9TdHJpbmcob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5kb2N1bWVudCh0aGlzLCB0aGlzLm9wdGlvbnMud3JpdGVyLmZpbHRlck9wdGlvbnMob3B0aW9ucykpO1xuICAgICAgfVxuXG4gICAgICAvLyBET00gbGV2ZWwgMSBmdW5jdGlvbnMgdG8gYmUgaW1wbGVtZW50ZWQgbGF0ZXJcbiAgICAgIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgY3JlYXRlVGV4dE5vZGUoZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZUNvbW1lbnQoZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZUNEQVRBU2VjdGlvbihkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgY3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uKHRhcmdldCwgZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZUF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgY3JlYXRlRW50aXR5UmVmZXJlbmNlKG5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBET00gbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5cIiArIHRoaXMuZGVidWdJbmZvKCkpO1xuICAgICAgfVxuXG4gICAgICBnZXRFbGVtZW50c0J5VGFnTmFtZSh0YWduYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgLy8gRE9NIGxldmVsIDIgZnVuY3Rpb25zIHRvIGJlIGltcGxlbWVudGVkIGxhdGVyXG4gICAgICBpbXBvcnROb2RlKGltcG9ydGVkTm9kZSwgZGVlcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBET00gbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5cIiArIHRoaXMuZGVidWdJbmZvKCkpO1xuICAgICAgfVxuXG4gICAgICBjcmVhdGVBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBET00gbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5cIiArIHRoaXMuZGVidWdJbmZvKCkpO1xuICAgICAgfVxuXG4gICAgICBnZXRFbGVtZW50c0J5VGFnTmFtZU5TKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgLy8gRE9NIGxldmVsIDMgZnVuY3Rpb25zIHRvIGJlIGltcGxlbWVudGVkIGxhdGVyXG4gICAgICBhZG9wdE5vZGUoc291cmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgbm9ybWFsaXplRG9jdW1lbnQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgcmVuYW1lTm9kZShub2RlLCBuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBET00gbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5cIiArIHRoaXMuZGVidWdJbmZvKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBET00gbGV2ZWwgNCBmdW5jdGlvbnMgdG8gYmUgaW1wbGVtZW50ZWQgbGF0ZXJcbiAgICAgIGdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZUV2ZW50KGV2ZW50SW50ZXJmYWNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgY3JlYXRlUmFuZ2UoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgY3JlYXRlTm9kZUl0ZXJhdG9yKHJvb3QsIHdoYXRUb1Nob3csIGZpbHRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZVRyZWVXYWxrZXIocm9vdCwgd2hhdFRvU2hvdywgZmlsdGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICAvLyBET00gbGV2ZWwgMVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxEb2N1bWVudC5wcm90b3R5cGUsICdpbXBsZW1lbnRhdGlvbicsIHtcbiAgICAgIHZhbHVlOiBuZXcgWE1MRE9NSW1wbGVtZW50YXRpb24oKVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTERvY3VtZW50LnByb3RvdHlwZSwgJ2RvY3R5cGUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hpbGQsIGksIGxlbiwgcmVmO1xuICAgICAgICByZWYgPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaGlsZCA9IHJlZltpXTtcbiAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gTm9kZVR5cGUuRG9jVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxEb2N1bWVudC5wcm90b3R5cGUsICdkb2N1bWVudEVsZW1lbnQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290T2JqZWN0IHx8IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBET00gbGV2ZWwgM1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxEb2N1bWVudC5wcm90b3R5cGUsICdpbnB1dEVuY29kaW5nJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MRG9jdW1lbnQucHJvdG90eXBlLCAnc3RyaWN0RXJyb3JDaGVja2luZycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxEb2N1bWVudC5wcm90b3R5cGUsICd4bWxFbmNvZGluZycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCAmJiB0aGlzLmNoaWxkcmVuWzBdLnR5cGUgPT09IE5vZGVUeXBlLkRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF0uZW5jb2Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxEb2N1bWVudC5wcm90b3R5cGUsICd4bWxTdGFuZGFsb25lJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIHRoaXMuY2hpbGRyZW5bMF0udHlwZSA9PT0gTm9kZVR5cGUuRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXS5zdGFuZGFsb25lID09PSAneWVzJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxEb2N1bWVudC5wcm90b3R5cGUsICd4bWxWZXJzaW9uJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIHRoaXMuY2hpbGRyZW5bMF0udHlwZSA9PT0gTm9kZVR5cGUuRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXS52ZXJzaW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBcIjEuMFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBET00gbGV2ZWwgNFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxEb2N1bWVudC5wcm90b3R5cGUsICdVUkwnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFVSSTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxEb2N1bWVudC5wcm90b3R5cGUsICdvcmlnaW4nLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxEb2N1bWVudC5wcm90b3R5cGUsICdjb21wYXRNb2RlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MRG9jdW1lbnQucHJvdG90eXBlLCAnY2hhcmFjdGVyU2V0Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MRG9jdW1lbnQucHJvdG90eXBlLCAnY29udGVudFR5cGUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBYTUxEb2N1bWVudDtcblxuICB9KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjQuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgTm9kZVR5cGUsIFdyaXRlclN0YXRlLCBYTUxBdHRyaWJ1dGUsIFhNTENEYXRhLCBYTUxDb21tZW50LCBYTUxEVERBdHRMaXN0LCBYTUxEVERFbGVtZW50LCBYTUxEVERFbnRpdHksIFhNTERURE5vdGF0aW9uLCBYTUxEZWNsYXJhdGlvbiwgWE1MRG9jVHlwZSwgWE1MRG9jdW1lbnQsIFhNTERvY3VtZW50Q0IsIFhNTEVsZW1lbnQsIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiwgWE1MUmF3LCBYTUxTdHJpbmdXcml0ZXIsIFhNTFN0cmluZ2lmaWVyLCBYTUxUZXh0LCBnZXRWYWx1ZSwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIGlzUGxhaW5PYmplY3QsXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gICh7aXNPYmplY3QsIGlzRnVuY3Rpb24sIGlzUGxhaW5PYmplY3QsIGdldFZhbHVlfSA9IHJlcXVpcmUoJy4vVXRpbGl0eScpKTtcblxuICBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vTm9kZVR5cGUnKTtcblxuICBYTUxEb2N1bWVudCA9IHJlcXVpcmUoJy4vWE1MRG9jdW1lbnQnKTtcblxuICBYTUxFbGVtZW50ID0gcmVxdWlyZSgnLi9YTUxFbGVtZW50Jyk7XG5cbiAgWE1MQ0RhdGEgPSByZXF1aXJlKCcuL1hNTENEYXRhJyk7XG5cbiAgWE1MQ29tbWVudCA9IHJlcXVpcmUoJy4vWE1MQ29tbWVudCcpO1xuXG4gIFhNTFJhdyA9IHJlcXVpcmUoJy4vWE1MUmF3Jyk7XG5cbiAgWE1MVGV4dCA9IHJlcXVpcmUoJy4vWE1MVGV4dCcpO1xuXG4gIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IHJlcXVpcmUoJy4vWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uJyk7XG5cbiAgWE1MRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL1hNTERlY2xhcmF0aW9uJyk7XG5cbiAgWE1MRG9jVHlwZSA9IHJlcXVpcmUoJy4vWE1MRG9jVHlwZScpO1xuXG4gIFhNTERUREF0dExpc3QgPSByZXF1aXJlKCcuL1hNTERUREF0dExpc3QnKTtcblxuICBYTUxEVERFbnRpdHkgPSByZXF1aXJlKCcuL1hNTERUREVudGl0eScpO1xuXG4gIFhNTERUREVsZW1lbnQgPSByZXF1aXJlKCcuL1hNTERUREVsZW1lbnQnKTtcblxuICBYTUxEVEROb3RhdGlvbiA9IHJlcXVpcmUoJy4vWE1MRFRETm90YXRpb24nKTtcblxuICBYTUxBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL1hNTEF0dHJpYnV0ZScpO1xuXG4gIFhNTFN0cmluZ2lmaWVyID0gcmVxdWlyZSgnLi9YTUxTdHJpbmdpZmllcicpO1xuXG4gIFhNTFN0cmluZ1dyaXRlciA9IHJlcXVpcmUoJy4vWE1MU3RyaW5nV3JpdGVyJyk7XG5cbiAgV3JpdGVyU3RhdGUgPSByZXF1aXJlKCcuL1dyaXRlclN0YXRlJyk7XG5cbiAgLy8gUmVwcmVzZW50cyBhbiBYTUwgYnVpbGRlclxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERvY3VtZW50Q0IgPSBjbGFzcyBYTUxEb2N1bWVudENCIHtcbiAgICAvLyBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiBgWE1MRG9jdW1lbnRDQmBcblxuICAgIC8vIGBvcHRpb25zLmtlZXBOdWxsTm9kZXNgIHdoZXRoZXIgbm9kZXMgd2l0aCBudWxsIHZhbHVlcyB3aWxsIGJlIGtlcHRcbiAgICAvLyAgICAgb3IgaWdub3JlZDogdHJ1ZSBvciBmYWxzZVxuICAgIC8vIGBvcHRpb25zLmtlZXBOdWxsQXR0cmlidXRlc2Agd2hldGhlciBhdHRyaWJ1dGVzIHdpdGggbnVsbCB2YWx1ZXMgd2lsbCBiZVxuICAgIC8vICAgICBrZXB0IG9yIGlnbm9yZWQ6IHRydWUgb3IgZmFsc2VcbiAgICAvLyBgb3B0aW9ucy5pZ25vcmVEZWNvcmF0b3JzYCB3aGV0aGVyIGRlY29yYXRvciBzdHJpbmdzIHdpbGwgYmUgaWdub3JlZCB3aGVuXG4gICAgLy8gICAgIGNvbnZlcnRpbmcgSlMgb2JqZWN0czogdHJ1ZSBvciBmYWxzZVxuICAgIC8vIGBvcHRpb25zLnNlcGFyYXRlQXJyYXlJdGVtc2Agd2hldGhlciBhcnJheSBpdGVtcyBhcmUgY3JlYXRlZCBhcyBzZXBhcmF0ZVxuICAgIC8vICAgICBub2RlcyB3aGVuIHBhc3NlZCBhcyBhbiBvYmplY3QgdmFsdWU6IHRydWUgb3IgZmFsc2VcbiAgICAvLyBgb3B0aW9ucy5ub0RvdWJsZUVuY29kaW5nYCB3aGV0aGVyIGV4aXN0aW5nIGh0bWwgZW50aXRpZXMgYXJlIGVuY29kZWQ6XG4gICAgLy8gICAgIHRydWUgb3IgZmFsc2VcbiAgICAvLyBgb3B0aW9ucy5zdHJpbmdpZnlgIGEgc2V0IG9mIGZ1bmN0aW9ucyB0byB1c2UgZm9yIGNvbnZlcnRpbmcgdmFsdWVzIHRvXG4gICAgLy8gICAgIHN0cmluZ3NcbiAgICAvLyBgb3B0aW9ucy53cml0ZXJgIHRoZSBkZWZhdWx0IFhNTCB3cml0ZXIgdG8gdXNlIGZvciBjb252ZXJ0aW5nIG5vZGVzIHRvXG4gICAgLy8gICAgIHN0cmluZy4gSWYgdGhlIGRlZmF1bHQgd3JpdGVyIGlzIG5vdCBzZXQsIHRoZSBidWlsdC1pbiBYTUxTdHJpbmdXcml0ZXJcbiAgICAvLyAgICAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXG5cbiAgICAvLyBgb25EYXRhYCB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gYSBuZXcgY2h1bmsgb2YgWE1MIGlzIG91dHB1dC4gVGhlXG4gICAgLy8gICAgICAgICAgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIFhNTCBjaHVuayBpcyBwYXNzZWQgdG8gYG9uRGF0YWAgYXMgaXRzIGZpcnN0XG4gICAgLy8gICAgICAgICAgYXJndW1lbnQsIGFuZCB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50LlxuICAgIC8vIGBvbkVuZGAgIHRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgWE1MIGRvY3VtZW50IGlzIGNvbXBsZXRlZCB3aXRoXG4gICAgLy8gICAgICAgICAgYGVuZGAuIGBvbkVuZGAgZG9lcyBub3QgcmVjZWl2ZSBhbnkgYXJndW1lbnRzLlxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIG9uRGF0YSwgb25FbmQpIHtcbiAgICAgIHZhciB3cml0ZXJPcHRpb25zO1xuICAgICAgdGhpcy5uYW1lID0gXCI/eG1sXCI7XG4gICAgICB0aGlzLnR5cGUgPSBOb2RlVHlwZS5Eb2N1bWVudDtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICB3cml0ZXJPcHRpb25zID0ge307XG4gICAgICBpZiAoIW9wdGlvbnMud3JpdGVyKSB7XG4gICAgICAgIG9wdGlvbnMud3JpdGVyID0gbmV3IFhNTFN0cmluZ1dyaXRlcigpO1xuICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KG9wdGlvbnMud3JpdGVyKSkge1xuICAgICAgICB3cml0ZXJPcHRpb25zID0gb3B0aW9ucy53cml0ZXI7XG4gICAgICAgIG9wdGlvbnMud3JpdGVyID0gbmV3IFhNTFN0cmluZ1dyaXRlcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMud3JpdGVyID0gb3B0aW9ucy53cml0ZXI7XG4gICAgICB0aGlzLndyaXRlck9wdGlvbnMgPSB0aGlzLndyaXRlci5maWx0ZXJPcHRpb25zKHdyaXRlck9wdGlvbnMpO1xuICAgICAgdGhpcy5zdHJpbmdpZnkgPSBuZXcgWE1MU3RyaW5naWZpZXIob3B0aW9ucyk7XG4gICAgICB0aGlzLm9uRGF0YUNhbGxiYWNrID0gb25EYXRhIHx8IGZ1bmN0aW9uKCkge307XG4gICAgICB0aGlzLm9uRW5kQ2FsbGJhY2sgPSBvbkVuZCB8fCBmdW5jdGlvbigpIHt9O1xuICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IC0xO1xuICAgICAgdGhpcy5vcGVuVGFncyA9IHt9O1xuICAgICAgdGhpcy5kb2N1bWVudFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZG9jdW1lbnRDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlcyBhIGNoaWxkIGVsZW1lbnQgbm9kZSBmcm9tIHRoZSBnaXZlbiBYTUxOb2RlXG5cbiAgICAvLyBgbm9kZWAgdGhlIGNoaWxkIG5vZGVcbiAgICBjcmVhdGVDaGlsZE5vZGUobm9kZSkge1xuICAgICAgdmFyIGF0dCwgYXR0TmFtZSwgYXR0cmlidXRlcywgY2hpbGQsIGksIGxlbiwgcmVmLCByZWYxO1xuICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5DRGF0YTpcbiAgICAgICAgICB0aGlzLmNkYXRhKG5vZGUudmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE5vZGVUeXBlLkNvbW1lbnQ6XG4gICAgICAgICAgdGhpcy5jb21tZW50KG5vZGUudmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE5vZGVUeXBlLkVsZW1lbnQ6XG4gICAgICAgICAgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgIHJlZiA9IG5vZGUuYXR0cmlicztcbiAgICAgICAgICBmb3IgKGF0dE5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGF0dE5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGF0dCA9IHJlZlthdHROYW1lXTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0TmFtZV0gPSBhdHQudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubm9kZShub2RlLm5hbWUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE5vZGVUeXBlLkR1bW15OlxuICAgICAgICAgIHRoaXMuZHVtbXkoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5SYXc6XG4gICAgICAgICAgdGhpcy5yYXcobm9kZS52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuVGV4dDpcbiAgICAgICAgICB0aGlzLnRleHQobm9kZS52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuUHJvY2Vzc2luZ0luc3RydWN0aW9uOlxuICAgICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb24obm9kZS50YXJnZXQsIG5vZGUudmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgWE1MIG5vZGUgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIGluIGEgSlMgb2JqZWN0OiBcIiArIG5vZGUuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICB9XG4gICAgICByZWYxID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIC8vIHdyaXRlIGNoaWxkIG5vZGVzIHJlY3Vyc2l2ZWx5XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gcmVmMVtpXTtcbiAgICAgICAgdGhpcy5jcmVhdGVDaGlsZE5vZGUoY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMudXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlcyBhIGR1bW15IG5vZGVcblxuICAgIGR1bW15KCkge1xuICAgICAgLy8gbm8tb3AsIGp1c3QgcmV0dXJuIHRoaXNcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZXMgYSBub2RlXG5cbiAgICAvLyBgbmFtZWAgbmFtZSBvZiB0aGUgbm9kZVxuICAgIC8vIGBhdHRyaWJ1dGVzYCBhbiBvYmplY3QgY29udGFpbmluZyBuYW1lL3ZhbHVlIHBhaXJzIG9mIGF0dHJpYnV0ZXNcbiAgICAvLyBgdGV4dGAgZWxlbWVudCB0ZXh0XG4gICAgbm9kZShuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgbm9kZSBuYW1lLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJvb3QgJiYgdGhpcy5jdXJyZW50TGV2ZWwgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRvY3VtZW50IGNhbiBvbmx5IGhhdmUgb25lIHJvb3Qgbm9kZS4gXCIgKyB0aGlzLmRlYnVnSW5mbyhuYW1lKSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wZW5DdXJyZW50KCk7XG4gICAgICBuYW1lID0gZ2V0VmFsdWUobmFtZSk7XG4gICAgICBpZiAoYXR0cmlidXRlcyA9PSBudWxsKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGF0dHJpYnV0ZXMgPSBnZXRWYWx1ZShhdHRyaWJ1dGVzKTtcbiAgICAgIC8vIHN3YXAgYXJndW1lbnQgb3JkZXI6IHRleHQgPC0+IGF0dHJpYnV0ZXNcbiAgICAgIGlmICghaXNPYmplY3QoYXR0cmlidXRlcykpIHtcbiAgICAgICAgW3RleHQsIGF0dHJpYnV0ZXNdID0gW2F0dHJpYnV0ZXMsIHRleHRdO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5ldyBYTUxFbGVtZW50KHRoaXMsIG5hbWUsIGF0dHJpYnV0ZXMpO1xuICAgICAgdGhpcy5jdXJyZW50Tm9kZS5jaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5jdXJyZW50TGV2ZWwrKztcbiAgICAgIHRoaXMub3BlblRhZ3NbdGhpcy5jdXJyZW50TGV2ZWxdID0gdGhpcy5jdXJyZW50Tm9kZTtcbiAgICAgIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy50ZXh0KHRleHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlcyBhIGNoaWxkIGVsZW1lbnQgbm9kZSBvciBhbiBlbGVtZW50IHR5cGUgZGVjbGFyYXRpb24gd2hlbiBjYWxsZWRcbiAgICAvLyBpbnNpZGUgdGhlIERURFxuXG4gICAgLy8gYG5hbWVgIG5hbWUgb2YgdGhlIG5vZGVcbiAgICAvLyBgYXR0cmlidXRlc2AgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmFtZS92YWx1ZSBwYWlycyBvZiBhdHRyaWJ1dGVzXG4gICAgLy8gYHRleHRgIGVsZW1lbnQgdGV4dFxuICAgIGVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgdmFyIGNoaWxkLCBpLCBsZW4sIG9sZFZhbGlkYXRpb25GbGFnLCByZWYsIHJvb3Q7XG4gICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSAmJiB0aGlzLmN1cnJlbnROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkRvY1R5cGUpIHtcbiAgICAgICAgdGhpcy5kdGRFbGVtZW50KC4uLmFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSB8fCBpc09iamVjdChuYW1lKSB8fCBpc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgICAgb2xkVmFsaWRhdGlvbkZsYWcgPSB0aGlzLm9wdGlvbnMubm9WYWxpZGF0aW9uO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5ub1ZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgICAgIHJvb3QgPSBuZXcgWE1MRG9jdW1lbnQodGhpcy5vcHRpb25zKS5lbGVtZW50KCdURU1QX1JPT1QnKTtcbiAgICAgICAgICByb290LmVsZW1lbnQobmFtZSk7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLm5vVmFsaWRhdGlvbiA9IG9sZFZhbGlkYXRpb25GbGFnO1xuICAgICAgICAgIHJlZiA9IHJvb3QuY2hpbGRyZW47XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHJlZltpXTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQ2hpbGROb2RlKGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMudXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ub2RlKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGRzIG9yIG1vZGlmaWVzIGFuIGF0dHJpYnV0ZVxuXG4gICAgLy8gYG5hbWVgIGF0dHJpYnV0ZSBuYW1lXG4gICAgLy8gYHZhbHVlYCBhdHRyaWJ1dGUgdmFsdWVcbiAgICBhdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBhdHROYW1lLCBhdHRWYWx1ZTtcbiAgICAgIGlmICghdGhpcy5jdXJyZW50Tm9kZSB8fCB0aGlzLmN1cnJlbnROb2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImF0dCgpIGNhbiBvbmx5IGJlIHVzZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYW4gZWxlKCkgY2FsbCBpbiBjYWxsYmFjayBtb2RlLiBcIiArIHRoaXMuZGVidWdJbmZvKG5hbWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgbmFtZSA9IGdldFZhbHVlKG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7IC8vIGV4cGFuZCBpZiBvYmplY3RcbiAgICAgICAgZm9yIChhdHROYW1lIGluIG5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChuYW1lLCBhdHROYW1lKSkgY29udGludWU7XG4gICAgICAgICAgYXR0VmFsdWUgPSBuYW1lW2F0dE5hbWVdO1xuICAgICAgICAgIHRoaXMuYXR0cmlidXRlKGF0dE5hbWUsIGF0dFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5hcHBseSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcE51bGxBdHRyaWJ1dGVzICYmICh2YWx1ZSA9PSBudWxsKSkge1xuICAgICAgICAgIHRoaXMuY3VycmVudE5vZGUuYXR0cmlic1tuYW1lXSA9IG5ldyBYTUxBdHRyaWJ1dGUodGhpcywgbmFtZSwgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuY3VycmVudE5vZGUuYXR0cmlic1tuYW1lXSA9IG5ldyBYTUxBdHRyaWJ1dGUodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBDcmVhdGVzIGEgdGV4dCBub2RlXG5cbiAgICAvLyBgdmFsdWVgIGVsZW1lbnQgdGV4dFxuICAgIHRleHQodmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxUZXh0KHRoaXMsIHZhbHVlKTtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLnRleHQobm9kZSwgdGhpcy53cml0ZXJPcHRpb25zLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlcyBhIENEQVRBIG5vZGVcblxuICAgIC8vIGB2YWx1ZWAgZWxlbWVudCB0ZXh0IHdpdGhvdXQgQ0RBVEEgZGVsaW1pdGVyc1xuICAgIGNkYXRhKHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MQ0RhdGEodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIuY2RhdGEobm9kZSwgdGhpcy53cml0ZXJPcHRpb25zLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlcyBhIGNvbW1lbnQgbm9kZVxuXG4gICAgLy8gYHZhbHVlYCBjb21tZW50IHRleHRcbiAgICBjb21tZW50KHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MQ29tbWVudCh0aGlzLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci5jb21tZW50KG5vZGUsIHRoaXMud3JpdGVyT3B0aW9ucywgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKSwgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZHMgdW5lc2NhcGVkIHJhdyB0ZXh0XG5cbiAgICAvLyBgdmFsdWVgIHRleHRcbiAgICByYXcodmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxSYXcodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIucmF3KG5vZGUsIHRoaXMud3JpdGVyT3B0aW9ucywgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKSwgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZHMgYSBwcm9jZXNzaW5nIGluc3RydWN0aW9uXG5cbiAgICAvLyBgdGFyZ2V0YCBpbnN0cnVjdGlvbiB0YXJnZXRcbiAgICAvLyBgdmFsdWVgIGluc3RydWN0aW9uIHZhbHVlXG4gICAgaW5zdHJ1Y3Rpb24odGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgdmFyIGksIGluc1RhcmdldCwgaW5zVmFsdWUsIGxlbiwgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQgPSBnZXRWYWx1ZSh0YXJnZXQpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSBnZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7IC8vIGV4cGFuZCBpZiBhcnJheVxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0YXJnZXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpbnNUYXJnZXQgPSB0YXJnZXRbaV07XG4gICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbihpbnNUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHRhcmdldCkpIHsgLy8gZXhwYW5kIGlmIG9iamVjdFxuICAgICAgICBmb3IgKGluc1RhcmdldCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbCh0YXJnZXQsIGluc1RhcmdldCkpIGNvbnRpbnVlO1xuICAgICAgICAgIGluc1ZhbHVlID0gdGFyZ2V0W2luc1RhcmdldF07XG4gICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbihpbnNUYXJnZXQsIGluc1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5hcHBseSgpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBuZXcgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uKHRoaXMsIHRhcmdldCwgdmFsdWUpO1xuICAgICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24obm9kZSwgdGhpcy53cml0ZXJPcHRpb25zLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlcyB0aGUgeG1sIGRlY2xhcmF0aW9uXG5cbiAgICAvLyBgdmVyc2lvbmAgQSB2ZXJzaW9uIG51bWJlciBzdHJpbmcsIGUuZy4gMS4wXG4gICAgLy8gYGVuY29kaW5nYCBFbmNvZGluZyBkZWNsYXJhdGlvbiwgZS5nLiBVVEYtOFxuICAgIC8vIGBzdGFuZGFsb25lYCBzdGFuZGFsb25lIGRvY3VtZW50IGRlY2xhcmF0aW9uOiB0cnVlIG9yIGZhbHNlXG4gICAgZGVjbGFyYXRpb24odmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgaWYgKHRoaXMuZG9jdW1lbnRTdGFydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImRlY2xhcmF0aW9uKCkgbXVzdCBiZSB0aGUgZmlyc3Qgbm9kZS5cIik7XG4gICAgICB9XG4gICAgICBub2RlID0gbmV3IFhNTERlY2xhcmF0aW9uKHRoaXMsIHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKTtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLmRlY2xhcmF0aW9uKG5vZGUsIHRoaXMud3JpdGVyT3B0aW9ucywgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKSwgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZXMgdGhlIGRvY3VtZW50IHR5cGUgZGVjbGFyYXRpb25cblxuICAgIC8vIGByb290YCAgdGhlIG5hbWUgb2YgdGhlIHJvb3Qgbm9kZVxuICAgIC8vIGBwdWJJRGAgdGhlIHB1YmxpYyBpZGVudGlmaWVyIG9mIHRoZSBleHRlcm5hbCBzdWJzZXRcbiAgICAvLyBgc3lzSURgIHRoZSBzeXN0ZW0gaWRlbnRpZmllciBvZiB0aGUgZXh0ZXJuYWwgc3Vic2V0XG4gICAgZG9jdHlwZShyb290LCBwdWJJRCwgc3lzSUQpIHtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIGlmIChyb290ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByb290IG5vZGUgbmFtZS5cIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImR0ZCgpIG11c3QgY29tZSBiZWZvcmUgdGhlIHJvb3Qgbm9kZS5cIik7XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnJlbnROb2RlID0gbmV3IFhNTERvY1R5cGUodGhpcywgcHViSUQsIHN5c0lEKTtcbiAgICAgIHRoaXMuY3VycmVudE5vZGUucm9vdE5vZGVOYW1lID0gcm9vdDtcbiAgICAgIHRoaXMuY3VycmVudE5vZGUuY2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuY3VycmVudExldmVsKys7XG4gICAgICB0aGlzLm9wZW5UYWdzW3RoaXMuY3VycmVudExldmVsXSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBDcmVhdGVzIGFuIGVsZW1lbnQgdHlwZSBkZWNsYXJhdGlvblxuXG4gICAgLy8gYG5hbWVgIGVsZW1lbnQgbmFtZVxuICAgIC8vIGB2YWx1ZWAgZWxlbWVudCBjb250ZW50IChkZWZhdWx0cyB0byAjUENEQVRBKVxuICAgIGR0ZEVsZW1lbnQobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxEVERFbGVtZW50KHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLmR0ZEVsZW1lbnQobm9kZSwgdGhpcy53cml0ZXJPcHRpb25zLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlcyBhbiBhdHRyaWJ1dGUgZGVjbGFyYXRpb25cblxuICAgIC8vIGBlbGVtZW50TmFtZWAgdGhlIG5hbWUgb2YgdGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGlzIGF0dHJpYnV0ZVxuICAgIC8vIGBhdHRyaWJ1dGVOYW1lYCBhdHRyaWJ1dGUgbmFtZVxuICAgIC8vIGBhdHRyaWJ1dGVUeXBlYCB0eXBlIG9mIHRoZSBhdHRyaWJ1dGUgKGRlZmF1bHRzIHRvIENEQVRBKVxuICAgIC8vIGBkZWZhdWx0VmFsdWVUeXBlYCBkZWZhdWx0IHZhbHVlIHR5cGUgKGVpdGhlciAjUkVRVUlSRUQsICNJTVBMSUVELCAjRklYRUQgb3JcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgI0RFRkFVTFQpIChkZWZhdWx0cyB0byAjSU1QTElFRClcbiAgICAvLyBgZGVmYXVsdFZhbHVlYCBkZWZhdWx0IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAvLyAgICAgICAgICAgICAgICAob25seSB1c2VkIGZvciAjRklYRUQgb3IgI0RFRkFVTFQpXG4gICAgYXR0TGlzdChlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MRFREQXR0TGlzdCh0aGlzLCBlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgIHRoaXMub25EYXRhKHRoaXMud3JpdGVyLmR0ZEF0dExpc3Qobm9kZSwgdGhpcy53cml0ZXJPcHRpb25zLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlcyBhIGdlbmVyYWwgZW50aXR5IGRlY2xhcmF0aW9uXG5cbiAgICAvLyBgbmFtZWAgdGhlIG5hbWUgb2YgdGhlIGVudGl0eVxuICAgIC8vIGB2YWx1ZWAgaW50ZXJuYWwgZW50aXR5IHZhbHVlIG9yIGFuIG9iamVjdCB3aXRoIGV4dGVybmFsIGVudGl0eSBkZXRhaWxzXG4gICAgLy8gYHZhbHVlLnB1YklEYCBwdWJsaWMgaWRlbnRpZmllclxuICAgIC8vIGB2YWx1ZS5zeXNJRGAgc3lzdGVtIGlkZW50aWZpZXJcbiAgICAvLyBgdmFsdWUubkRhdGFgIG5vdGF0aW9uIGRlY2xhcmF0aW9uXG4gICAgZW50aXR5KG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MRFRERW50aXR5KHRoaXMsIGZhbHNlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLndyaXRlci5kdGRFbnRpdHkobm9kZSwgdGhpcy53cml0ZXJPcHRpb25zLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlcyBhIHBhcmFtZXRlciBlbnRpdHkgZGVjbGFyYXRpb25cblxuICAgIC8vIGBuYW1lYCB0aGUgbmFtZSBvZiB0aGUgZW50aXR5XG4gICAgLy8gYHZhbHVlYCBpbnRlcm5hbCBlbnRpdHkgdmFsdWUgb3IgYW4gb2JqZWN0IHdpdGggZXh0ZXJuYWwgZW50aXR5IGRldGFpbHNcbiAgICAvLyBgdmFsdWUucHViSURgIHB1YmxpYyBpZGVudGlmaWVyXG4gICAgLy8gYHZhbHVlLnN5c0lEYCBzeXN0ZW0gaWRlbnRpZmllclxuICAgIHBFbnRpdHkobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdGhpcy5vcGVuQ3VycmVudCgpO1xuICAgICAgbm9kZSA9IG5ldyBYTUxEVERFbnRpdHkodGhpcywgdHJ1ZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIuZHRkRW50aXR5KG5vZGUsIHRoaXMud3JpdGVyT3B0aW9ucywgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKSwgdGhpcy5jdXJyZW50TGV2ZWwgKyAxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZXMgYSBOT1RBVElPTiBkZWNsYXJhdGlvblxuXG4gICAgLy8gYG5hbWVgIHRoZSBuYW1lIG9mIHRoZSBub3RhdGlvblxuICAgIC8vIGB2YWx1ZWAgYW4gb2JqZWN0IHdpdGggZXh0ZXJuYWwgZW50aXR5IGRldGFpbHNcbiAgICAvLyBgdmFsdWUucHViSURgIHB1YmxpYyBpZGVudGlmaWVyXG4gICAgLy8gYHZhbHVlLnN5c0lEYCBzeXN0ZW0gaWRlbnRpZmllclxuICAgIG5vdGF0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHRoaXMub3BlbkN1cnJlbnQoKTtcbiAgICAgIG5vZGUgPSBuZXcgWE1MRFRETm90YXRpb24odGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy53cml0ZXIuZHRkTm90YXRpb24obm9kZSwgdGhpcy53cml0ZXJPcHRpb25zLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpLCB0aGlzLmN1cnJlbnRMZXZlbCArIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gR2V0cyB0aGUgcGFyZW50IG5vZGVcbiAgICB1cCgpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRvY3VtZW50IG5vZGUgaGFzIG5vIHBhcmVudC5cIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIHRoaXMuY2xvc2VOb2RlKHRoaXMuY3VycmVudE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3Blbk5vZGUodGhpcy5jdXJyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNsb3NlTm9kZSh0aGlzLm9wZW5UYWdzW3RoaXMuY3VycmVudExldmVsXSk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5vcGVuVGFnc1t0aGlzLmN1cnJlbnRMZXZlbF07XG4gICAgICB0aGlzLmN1cnJlbnRMZXZlbC0tO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRW5kcyB0aGUgZG9jdW1lbnRcbiAgICBlbmQoKSB7XG4gICAgICB3aGlsZSAodGhpcy5jdXJyZW50TGV2ZWwgPj0gMCkge1xuICAgICAgICB0aGlzLnVwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5vbkVuZCgpO1xuICAgIH1cblxuICAgIC8vIE9wZW5zIHRoZSBjdXJyZW50IHBhcmVudCBub2RlXG4gICAgb3BlbkN1cnJlbnQoKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnROb2RlLmNoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3Blbk5vZGUodGhpcy5jdXJyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV3JpdGVzIHRoZSBvcGVuaW5nIHRhZyBvZiB0aGUgY3VycmVudCBub2RlIG9yIHRoZSBlbnRpcmUgbm9kZSBpZiBpdCBoYXNcbiAgICAvLyBubyBjaGlsZCBub2Rlc1xuICAgIG9wZW5Ob2RlKG5vZGUpIHtcbiAgICAgIHZhciBhdHQsIGNodW5rLCBuYW1lLCByZWY7XG4gICAgICBpZiAoIW5vZGUuaXNPcGVuKSB7XG4gICAgICAgIGlmICghdGhpcy5yb290ICYmIHRoaXMuY3VycmVudExldmVsID09PSAwICYmIG5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMucm9vdCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmsgPSAnJztcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMud3JpdGVyT3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLk9wZW5UYWc7XG4gICAgICAgICAgY2h1bmsgPSB0aGlzLndyaXRlci5pbmRlbnQobm9kZSwgdGhpcy53cml0ZXJPcHRpb25zLCB0aGlzLmN1cnJlbnRMZXZlbCkgKyAnPCcgKyBub2RlLm5hbWU7XG4gICAgICAgICAgcmVmID0gbm9kZS5hdHRyaWJzO1xuICAgICAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwgbmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgYXR0ID0gcmVmW25hbWVdO1xuICAgICAgICAgICAgY2h1bmsgKz0gdGhpcy53cml0ZXIuYXR0cmlidXRlKGF0dCwgdGhpcy53cml0ZXJPcHRpb25zLCB0aGlzLmN1cnJlbnRMZXZlbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNodW5rICs9IChub2RlLmNoaWxkcmVuID8gJz4nIDogJy8+JykgKyB0aGlzLndyaXRlci5lbmRsaW5lKG5vZGUsIHRoaXMud3JpdGVyT3B0aW9ucywgdGhpcy5jdXJyZW50TGV2ZWwpO1xuICAgICAgICAgIHRoaXMud3JpdGVyT3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkluc2lkZVRhZzsgLy8gaWYgbm9kZS50eXBlIGlzIE5vZGVUeXBlLkRvY1R5cGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndyaXRlck9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5PcGVuVGFnO1xuICAgICAgICAgIGNodW5rID0gdGhpcy53cml0ZXIuaW5kZW50KG5vZGUsIHRoaXMud3JpdGVyT3B0aW9ucywgdGhpcy5jdXJyZW50TGV2ZWwpICsgJzwhRE9DVFlQRSAnICsgbm9kZS5yb290Tm9kZU5hbWU7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gZXh0ZXJuYWwgaWRlbnRpZmllclxuICAgICAgICAgIGlmIChub2RlLnB1YklEICYmIG5vZGUuc3lzSUQpIHtcbiAgICAgICAgICAgIGNodW5rICs9ICcgUFVCTElDIFwiJyArIG5vZGUucHViSUQgKyAnXCIgXCInICsgbm9kZS5zeXNJRCArICdcIic7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLnN5c0lEKSB7XG4gICAgICAgICAgICBjaHVuayArPSAnIFNZU1RFTSBcIicgKyBub2RlLnN5c0lEICsgJ1wiJztcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gaW50ZXJuYWwgc3Vic2V0XG4gICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNodW5rICs9ICcgWyc7XG4gICAgICAgICAgICB0aGlzLndyaXRlck9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5JbnNpZGVUYWc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVyT3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkNsb3NlVGFnO1xuICAgICAgICAgICAgY2h1bmsgKz0gJz4nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaHVuayArPSB0aGlzLndyaXRlci5lbmRsaW5lKG5vZGUsIHRoaXMud3JpdGVyT3B0aW9ucywgdGhpcy5jdXJyZW50TGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25EYXRhKGNodW5rLCB0aGlzLmN1cnJlbnRMZXZlbCk7XG4gICAgICAgIHJldHVybiBub2RlLmlzT3BlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV3JpdGVzIHRoZSBjbG9zaW5nIHRhZyBvZiB0aGUgY3VycmVudCBub2RlXG4gICAgY2xvc2VOb2RlKG5vZGUpIHtcbiAgICAgIHZhciBjaHVuaztcbiAgICAgIGlmICghbm9kZS5pc0Nsb3NlZCkge1xuICAgICAgICBjaHVuayA9ICcnO1xuICAgICAgICB0aGlzLndyaXRlck9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5DbG9zZVRhZztcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCkge1xuICAgICAgICAgIGNodW5rID0gdGhpcy53cml0ZXIuaW5kZW50KG5vZGUsIHRoaXMud3JpdGVyT3B0aW9ucywgdGhpcy5jdXJyZW50TGV2ZWwpICsgJzwvJyArIG5vZGUubmFtZSArICc+JyArIHRoaXMud3JpdGVyLmVuZGxpbmUobm9kZSwgdGhpcy53cml0ZXJPcHRpb25zLCB0aGlzLmN1cnJlbnRMZXZlbCk7IC8vIGlmIG5vZGUudHlwZSBpcyBOb2RlVHlwZS5Eb2NUeXBlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2h1bmsgPSB0aGlzLndyaXRlci5pbmRlbnQobm9kZSwgdGhpcy53cml0ZXJPcHRpb25zLCB0aGlzLmN1cnJlbnRMZXZlbCkgKyAnXT4nICsgdGhpcy53cml0ZXIuZW5kbGluZShub2RlLCB0aGlzLndyaXRlck9wdGlvbnMsIHRoaXMuY3VycmVudExldmVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlck9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5Ob25lO1xuICAgICAgICB0aGlzLm9uRGF0YShjaHVuaywgdGhpcy5jdXJyZW50TGV2ZWwpO1xuICAgICAgICByZXR1cm4gbm9kZS5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIHdoZW4gYSBuZXcgY2h1bmsgb2YgWE1MIGlzIG91dHB1dFxuXG4gICAgLy8gYGNodW5rYCBhIHN0cmluZyBjb250YWluaW5nIHRoZSBYTUwgY2h1bmtcbiAgICAvLyBgbGV2ZWxgIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWxcbiAgICBvbkRhdGEoY2h1bmssIGxldmVsKSB7XG4gICAgICB0aGlzLmRvY3VtZW50U3RhcnRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5vbkRhdGFDYWxsYmFjayhjaHVuaywgbGV2ZWwgKyAxKTtcbiAgICB9XG5cbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgWE1MIGRvY3VtZW50IGlzIGNvbXBsZXRlZFxuICAgIG9uRW5kKCkge1xuICAgICAgdGhpcy5kb2N1bWVudENvbXBsZXRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5vbkVuZENhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBkZWJ1ZyBzdHJpbmdcbiAgICBkZWJ1Z0luZm8obmFtZSkge1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIm5vZGU6IDxcIiArIG5hbWUgKyBcIj5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOb2RlIGFsaWFzZXNcbiAgICBlbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50KC4uLmFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgbm9kKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgfVxuXG4gICAgdHh0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBkYXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNkYXRhKHZhbHVlKTtcbiAgICB9XG5cbiAgICBjb20odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQodmFsdWUpO1xuICAgIH1cblxuICAgIGlucyh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbih0YXJnZXQsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBkZWModmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmF0aW9uKHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKTtcbiAgICB9XG5cbiAgICBkdGQocm9vdCwgcHViSUQsIHN5c0lEKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N0eXBlKHJvb3QsIHB1YklELCBzeXNJRCk7XG4gICAgfVxuXG4gICAgZShuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgIH1cblxuICAgIG4obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZShuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICB9XG5cbiAgICB0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jZGF0YSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgYyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tbWVudCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmF3KHZhbHVlKTtcbiAgICB9XG5cbiAgICBpKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uKHRhcmdldCwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8vIEF0dHJpYnV0ZSBhbGlhc2VzXG4gICAgYXR0KCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUgJiYgdGhpcy5jdXJyZW50Tm9kZS50eXBlID09PSBOb2RlVHlwZS5Eb2NUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dExpc3QoLi4uYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZSguLi5hcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGEoKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSAmJiB0aGlzLmN1cnJlbnROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkRvY1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0TGlzdCguLi5hcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlKC4uLmFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRFREIGFsaWFzZXNcbiAgICAvLyBhdHQoKSBhbmQgZWxlKCkgYXJlIGRlZmluZWQgYWJvdmVcbiAgICBlbnQobmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVudGl0eShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcGVudChuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucEVudGl0eShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgbm90KG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RhdGlvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuNC4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBOb2RlVHlwZSwgWE1MRHVtbXksIFhNTE5vZGU7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9Ob2RlVHlwZScpO1xuXG4gIC8vIFJlcHJlc2VudHMgYSAgcmF3IG5vZGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEdW1teSA9IGNsYXNzIFhNTER1bW15IGV4dGVuZHMgWE1MTm9kZSB7XG4gICAgLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYFhNTER1bW15YFxuXG4gICAgLy8gYFhNTER1bW15YCBpcyBhIHNwZWNpYWwgbm9kZSByZXByZXNlbnRpbmcgYSBub2RlIHdpdGggXG4gICAgLy8gYSBudWxsIHZhbHVlLiBEdW1teSBub2RlcyBhcmUgY3JlYXRlZCB3aGlsZSByZWN1cnNpdmVseVxuICAgIC8vIGJ1aWxkaW5nIHRoZSBYTUwgdHJlZS4gU2ltcGx5IHNraXBwaW5nIG51bGwgdmFsdWVzIGRvZXNuJ3RcbiAgICAvLyB3b3JrIGJlY2F1c2UgdGhhdCB3b3VsZCBicmVhayB0aGUgcmVjdXJzaXZlIGNoYWluLlxuICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgICAgc3VwZXIocGFyZW50KTtcbiAgICAgIHRoaXMudHlwZSA9IE5vZGVUeXBlLkR1bW15O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZXMgYW5kIHJldHVybnMgYSBkZWVwIGNsb25lIG9mIGB0aGlzYFxuICAgIGNsb25lKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydHMgdGhlIFhNTCBmcmFnbWVudCB0byBzdHJpbmdcblxuICAgIC8vIGBvcHRpb25zLnByZXR0eWAgcHJldHR5IHByaW50cyB0aGUgcmVzdWx0XG4gICAgLy8gYG9wdGlvbnMuaW5kZW50YCBpbmRlbnRhdGlvbiBmb3IgcHJldHR5IHByaW50XG4gICAgLy8gYG9wdGlvbnMub2Zmc2V0YCBob3cgbWFueSBpbmRlbnRhdGlvbnMgdG8gYWRkIHRvIGV2ZXJ5IGxpbmUgZm9yIHByZXR0eSBwcmludFxuICAgIC8vIGBvcHRpb25zLm5ld2xpbmVgIG5ld2xpbmUgc2VxdWVuY2UgZm9yIHByZXR0eSBwcmludFxuICAgIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi40LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIE5vZGVUeXBlLCBYTUxBdHRyaWJ1dGUsIFhNTEVsZW1lbnQsIFhNTE5hbWVkTm9kZU1hcCwgWE1MTm9kZSwgZ2V0VmFsdWUsIGlzRnVuY3Rpb24sIGlzT2JqZWN0LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICAoe2lzT2JqZWN0LCBpc0Z1bmN0aW9uLCBnZXRWYWx1ZX0gPSByZXF1aXJlKCcuL1V0aWxpdHknKSk7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9Ob2RlVHlwZScpO1xuXG4gIFhNTEF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vWE1MQXR0cmlidXRlJyk7XG5cbiAgWE1MTmFtZWROb2RlTWFwID0gcmVxdWlyZSgnLi9YTUxOYW1lZE5vZGVNYXAnKTtcblxuICAvLyBSZXByZXNlbnRzIGFuIGVsZW1lbnQgb2YgdGhlIFhNTCBkb2N1bWVudFxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTEVsZW1lbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgWE1MRWxlbWVudCBleHRlbmRzIFhNTE5vZGUge1xuICAgICAgLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYFhNTEVsZW1lbnRgXG5cbiAgICAgIC8vIGBwYXJlbnRgIHRoZSBwYXJlbnQgbm9kZVxuICAgICAgLy8gYG5hbWVgIGVsZW1lbnQgbmFtZVxuICAgICAgLy8gYGF0dHJpYnV0ZXNgIGFuIG9iamVjdCBjb250YWluaW5nIG5hbWUvdmFsdWUgcGFpcnMgb2YgYXR0cmlidXRlc1xuICAgICAgY29uc3RydWN0b3IocGFyZW50LCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBjaGlsZCwgaiwgbGVuLCByZWY7XG4gICAgICAgIHN1cGVyKHBhcmVudCk7XG4gICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGVsZW1lbnQgbmFtZS4gXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLnN0cmluZ2lmeS5uYW1lKG5hbWUpO1xuICAgICAgICB0aGlzLnR5cGUgPSBOb2RlVHlwZS5FbGVtZW50O1xuICAgICAgICB0aGlzLmF0dHJpYnMgPSB7fTtcbiAgICAgICAgdGhpcy5zY2hlbWFUeXBlSW5mbyA9IG51bGw7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZShhdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgcHJvcGVydGllcyBpZiB0aGlzIGlzIHRoZSByb290IG5vZGVcbiAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBOb2RlVHlwZS5Eb2N1bWVudCkge1xuICAgICAgICAgIHRoaXMuaXNSb290ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRvY3VtZW50T2JqZWN0ID0gcGFyZW50O1xuICAgICAgICAgIHBhcmVudC5yb290T2JqZWN0ID0gdGhpcztcbiAgICAgICAgICAvLyBzZXQgZHRkIG5hbWVcbiAgICAgICAgICBpZiAocGFyZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICByZWYgPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgY2hpbGQgPSByZWZbal07XG4gICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBOb2RlVHlwZS5Eb2NUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQubmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGEgZGVlcCBjbG9uZSBvZiBgdGhpc2BcblxuICAgICAgY2xvbmUoKSB7XG4gICAgICAgIHZhciBhdHQsIGF0dE5hbWUsIGNsb25lZFNlbGYsIHJlZjtcbiAgICAgICAgY2xvbmVkU2VsZiA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgICAgIC8vIHJlbW92ZSBkb2N1bWVudCBlbGVtZW50XG4gICAgICAgIGlmIChjbG9uZWRTZWxmLmlzUm9vdCkge1xuICAgICAgICAgIGNsb25lZFNlbGYuZG9jdW1lbnRPYmplY3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsb25lIGF0dHJpYnV0ZXNcbiAgICAgICAgY2xvbmVkU2VsZi5hdHRyaWJzID0ge307XG4gICAgICAgIHJlZiA9IHRoaXMuYXR0cmlicztcbiAgICAgICAgZm9yIChhdHROYW1lIGluIHJlZikge1xuICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwgYXR0TmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIGF0dCA9IHJlZlthdHROYW1lXTtcbiAgICAgICAgICBjbG9uZWRTZWxmLmF0dHJpYnNbYXR0TmFtZV0gPSBhdHQuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjbG9uZSBjaGlsZCBub2Rlc1xuICAgICAgICBjbG9uZWRTZWxmLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgIHZhciBjbG9uZWRDaGlsZDtcbiAgICAgICAgICBjbG9uZWRDaGlsZCA9IGNoaWxkLmNsb25lKCk7XG4gICAgICAgICAgY2xvbmVkQ2hpbGQucGFyZW50ID0gY2xvbmVkU2VsZjtcbiAgICAgICAgICByZXR1cm4gY2xvbmVkU2VsZi5jaGlsZHJlbi5wdXNoKGNsb25lZENoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbG9uZWRTZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGRzIG9yIG1vZGlmaWVzIGFuIGF0dHJpYnV0ZVxuXG4gICAgICAvLyBgbmFtZWAgYXR0cmlidXRlIG5hbWVcbiAgICAgIC8vIGB2YWx1ZWAgYXR0cmlidXRlIHZhbHVlXG4gICAgICBhdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGF0dE5hbWUsIGF0dFZhbHVlO1xuICAgICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmFtZSA9IGdldFZhbHVlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09iamVjdChuYW1lKSkgeyAvLyBleHBhbmQgaWYgb2JqZWN0XG4gICAgICAgICAgZm9yIChhdHROYW1lIGluIG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKG5hbWUsIGF0dE5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGF0dFZhbHVlID0gbmFtZVthdHROYW1lXTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlKGF0dE5hbWUsIGF0dFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmFwcGx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcE51bGxBdHRyaWJ1dGVzICYmICh2YWx1ZSA9PSBudWxsKSkge1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJzW25hbWVdID0gbmV3IFhNTEF0dHJpYnV0ZSh0aGlzLCBuYW1lLCBcIlwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlic1tuYW1lXSA9IG5ldyBYTUxBdHRyaWJ1dGUodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlcyBhbiBhdHRyaWJ1dGVcblxuICAgICAgLy8gYG5hbWVgIGF0dHJpYnV0ZSBuYW1lXG4gICAgICByZW1vdmVBdHRyaWJ1dGUobmFtZSkge1xuICAgICAgICB2YXIgYXR0TmFtZSwgaiwgbGVuO1xuICAgICAgICAvLyBBbHNvIGRlZmluZWQgaW4gRE9NIGxldmVsIDFcbiAgICAgICAgLy8gcmVtb3ZlQXR0cmlidXRlKG5hbWUpIHJlbW92ZXMgYW4gYXR0cmlidXRlIGJ5IG5hbWUuXG4gICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZSBuYW1lLiBcIiArIHRoaXMuZGVidWdJbmZvKCkpO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBnZXRWYWx1ZShuYW1lKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHsgLy8gZXhwYW5kIGlmIGFycmF5XG4gICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gbmFtZS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXR0TmFtZSA9IG5hbWVbal07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJzW2F0dE5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBDb252ZXJ0cyB0aGUgWE1MIGZyYWdtZW50IHRvIHN0cmluZ1xuXG4gICAgICAvLyBgb3B0aW9ucy5wcmV0dHlgIHByZXR0eSBwcmludHMgdGhlIHJlc3VsdFxuICAgICAgLy8gYG9wdGlvbnMuaW5kZW50YCBpbmRlbnRhdGlvbiBmb3IgcHJldHR5IHByaW50XG4gICAgICAvLyBgb3B0aW9ucy5vZmZzZXRgIGhvdyBtYW55IGluZGVudGF0aW9ucyB0byBhZGQgdG8gZXZlcnkgbGluZSBmb3IgcHJldHR5IHByaW50XG4gICAgICAvLyBgb3B0aW9ucy5uZXdsaW5lYCBuZXdsaW5lIHNlcXVlbmNlIGZvciBwcmV0dHkgcHJpbnRcbiAgICAgIC8vIGBvcHRpb25zLmFsbG93RW1wdHlgIGRvIG5vdCBzZWxmIGNsb3NlIGVtcHR5IGVsZW1lbnQgdGFnc1xuICAgICAgdG9TdHJpbmcob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyaXRlci5lbGVtZW50KHRoaXMsIHRoaXMub3B0aW9ucy53cml0ZXIuZmlsdGVyT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsaWFzZXNcbiAgICAgIGF0dChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBhKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERPTSBMZXZlbCAxXG4gICAgICBnZXRBdHRyaWJ1dGUobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5hdHRyaWJzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlic1tuYW1lXS52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBET00gbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5cIiArIHRoaXMuZGVidWdJbmZvKCkpO1xuICAgICAgfVxuXG4gICAgICBnZXRBdHRyaWJ1dGVOb2RlKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlicy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0QXR0cmlidXRlTm9kZShuZXdBdHRyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlQXR0cmlidXRlTm9kZShvbGRBdHRyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgZ2V0RWxlbWVudHNCeVRhZ05hbWUobmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERPTSBMZXZlbCAyXG4gICAgICBnZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIHNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgcXVhbGlmaWVkTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBET00gbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5cIiArIHRoaXMuZGVidWdJbmZvKCkpO1xuICAgICAgfVxuXG4gICAgICByZW1vdmVBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGdldEF0dHJpYnV0ZU5vZGVOUyhuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIHNldEF0dHJpYnV0ZU5vZGVOUyhuZXdBdHRyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgZ2V0RWxlbWVudHNCeVRhZ05hbWVOUyhuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGhhc0F0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGhhc0F0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgLy8gRE9NIExldmVsIDNcbiAgICAgIHNldElkQXR0cmlidXRlKG5hbWUsIGlzSWQpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlicy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnNbbmFtZV0uaXNJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXNJZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRJZEF0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lLCBpc0lkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgc2V0SWRBdHRyaWJ1dGVOb2RlKGlkQXR0ciwgaXNJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERPTSBMZXZlbCA0XG4gICAgICBnZXRFbGVtZW50c0J5VGFnTmFtZSh0YWduYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgZ2V0RWxlbWVudHNCeVRhZ05hbWVOUyhuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGlzRXF1YWxOb2RlKG5vZGUpIHtcbiAgICAgICAgdmFyIGksIGosIHJlZjtcbiAgICAgICAgaWYgKCFzdXBlci5pc0VxdWFsTm9kZShub2RlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgIT09IHRoaXMubmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnByZWZpeCAhPT0gdGhpcy5wcmVmaXgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubG9jYWxOYW1lICE9PSB0aGlzLmxvY2FsTmFtZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5hdHRyaWJzLmxlbmd0aCAhPT0gdGhpcy5hdHRyaWJzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdGhpcy5hdHRyaWJzLmxlbmd0aCAtIDE7ICgwIDw9IHJlZiA/IGogPD0gcmVmIDogaiA+PSByZWYpOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICBpZiAoIXRoaXMuYXR0cmlic1tpXS5pc0VxdWFsTm9kZShub2RlLmF0dHJpYnNbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIERPTSBsZXZlbCAxXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTEVsZW1lbnQucHJvdG90eXBlLCAndGFnTmFtZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBET00gbGV2ZWwgNFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxFbGVtZW50LnByb3RvdHlwZSwgJ25hbWVzcGFjZVVSSScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxFbGVtZW50LnByb3RvdHlwZSwgJ3ByZWZpeCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxFbGVtZW50LnByb3RvdHlwZSwgJ2xvY2FsTmFtZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MRWxlbWVudC5wcm90b3R5cGUsICdpZCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxFbGVtZW50LnByb3RvdHlwZSwgJ2NsYXNzTmFtZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxFbGVtZW50LnByb3RvdHlwZSwgJ2NsYXNzTGlzdCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxFbGVtZW50LnByb3RvdHlwZSwgJ2F0dHJpYnV0ZXMnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuYXR0cmlidXRlTWFwIHx8ICF0aGlzLmF0dHJpYnV0ZU1hcC5ub2Rlcykge1xuICAgICAgICAgIHRoaXMuYXR0cmlidXRlTWFwID0gbmV3IFhNTE5hbWVkTm9kZU1hcCh0aGlzLmF0dHJpYnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZU1hcDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBYTUxFbGVtZW50O1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuNC4xXG4oZnVuY3Rpb24oKSB7XG4gIC8vIFJlcHJlc2VudHMgYSBtYXAgb2Ygbm9kZXMgYWNjZXNzZWQgYnkgYSBzdHJpbmcga2V5XG4gIHZhciBYTUxOYW1lZE5vZGVNYXA7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxOYW1lZE5vZGVNYXAgPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgWE1MTmFtZWROb2RlTWFwIHtcbiAgICAgIC8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIGBYTUxOYW1lZE5vZGVNYXBgXG4gICAgICAvLyBUaGlzIGlzIGp1c3QgYSB3cmFwcGVyIGFyb3VuZCBhbiBvcmRpbmFyeVxuICAgICAgLy8gSlMgb2JqZWN0LlxuXG4gICAgICAvLyBgbm9kZXNgIHRoZSBvYmplY3QgY29udGFpbmluZyBub2Rlcy5cbiAgICAgIGNvbnN0cnVjdG9yKG5vZGVzKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGRlZXAgY2xvbmUgb2YgYHRoaXNgXG5cbiAgICAgIGNsb25lKCkge1xuICAgICAgICAvLyB0aGlzIGNsYXNzIHNob3VsZCBub3QgYmUgY2xvbmVkIHNpbmNlIGl0IHdyYXBzXG4gICAgICAgIC8vIGFyb3VuZCBhIGdpdmVuIG9iamVjdC4gVGhlIGNhbGxpbmcgZnVuY3Rpb24gc2hvdWxkIGNoZWNrXG4gICAgICAgIC8vIHdoZXRoZXIgdGhlIHdyYXBwZWQgb2JqZWN0IGlzIG51bGwgYW5kIHN1cHBseSBhIG5ldyBvYmplY3RcbiAgICAgICAgLy8gKGZyb20gdGhlIGNsb25lKS5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBET00gTGV2ZWwgMVxuICAgICAgZ2V0TmFtZWRJdGVtKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbbmFtZV07XG4gICAgICB9XG5cbiAgICAgIHNldE5hbWVkSXRlbShub2RlKSB7XG4gICAgICAgIHZhciBvbGROb2RlO1xuICAgICAgICBvbGROb2RlID0gdGhpcy5ub2Rlc1tub2RlLm5vZGVOYW1lXTtcbiAgICAgICAgdGhpcy5ub2Rlc1tub2RlLm5vZGVOYW1lXSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBvbGROb2RlIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZU5hbWVkSXRlbShuYW1lKSB7XG4gICAgICAgIHZhciBvbGROb2RlO1xuICAgICAgICBvbGROb2RlID0gdGhpcy5ub2Rlc1tuYW1lXTtcbiAgICAgICAgZGVsZXRlIHRoaXMubm9kZXNbbmFtZV07XG4gICAgICAgIHJldHVybiBvbGROb2RlIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGl0ZW0oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbT2JqZWN0LmtleXModGhpcy5ub2RlcylbaW5kZXhdXSB8fCBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBET00gbGV2ZWwgMiBmdW5jdGlvbnMgdG8gYmUgaW1wbGVtZW50ZWQgbGF0ZXJcbiAgICAgIGdldE5hbWVkSXRlbU5TKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgfVxuXG4gICAgICBzZXROYW1lZEl0ZW1OUyhub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgfVxuXG4gICAgICByZW1vdmVOYW1lZEl0ZW1OUyhuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICAgIH1cblxuICAgIH07XG5cbiAgICBcbiAgICAvLyBET00gbGV2ZWwgMVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxOYW1lZE5vZGVNYXAucHJvdG90eXBlLCAnbGVuZ3RoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubm9kZXMpLmxlbmd0aCB8fCAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFhNTE5hbWVkTm9kZU1hcDtcblxuICB9KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjQuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgRG9jdW1lbnRQb3NpdGlvbiwgTm9kZVR5cGUsIFhNTENEYXRhLCBYTUxDb21tZW50LCBYTUxEZWNsYXJhdGlvbiwgWE1MRG9jVHlwZSwgWE1MRHVtbXksIFhNTEVsZW1lbnQsIFhNTE5hbWVkTm9kZU1hcCwgWE1MTm9kZSwgWE1MTm9kZUxpc3QsIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiwgWE1MUmF3LCBYTUxUZXh0LCBnZXRWYWx1ZSwgaXNFbXB0eSwgaXNGdW5jdGlvbiwgaXNPYmplY3QsXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIHNwbGljZSA9IFtdLnNwbGljZTtcblxuICAoe2lzT2JqZWN0LCBpc0Z1bmN0aW9uLCBpc0VtcHR5LCBnZXRWYWx1ZX0gPSByZXF1aXJlKCcuL1V0aWxpdHknKSk7XG5cbiAgWE1MRWxlbWVudCA9IG51bGw7XG5cbiAgWE1MQ0RhdGEgPSBudWxsO1xuXG4gIFhNTENvbW1lbnQgPSBudWxsO1xuXG4gIFhNTERlY2xhcmF0aW9uID0gbnVsbDtcblxuICBYTUxEb2NUeXBlID0gbnVsbDtcblxuICBYTUxSYXcgPSBudWxsO1xuXG4gIFhNTFRleHQgPSBudWxsO1xuXG4gIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IG51bGw7XG5cbiAgWE1MRHVtbXkgPSBudWxsO1xuXG4gIE5vZGVUeXBlID0gbnVsbDtcblxuICBYTUxOb2RlTGlzdCA9IG51bGw7XG5cbiAgWE1MTmFtZWROb2RlTWFwID0gbnVsbDtcblxuICBEb2N1bWVudFBvc2l0aW9uID0gbnVsbDtcblxuICAvLyBSZXByZXNlbnRzIGEgZ2VuZXJpYyBYTWwgZWxlbWVudFxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTE5vZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgWE1MTm9kZSB7XG4gICAgICAvLyBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiBgWE1MTm9kZWBcblxuICAgICAgLy8gYHBhcmVudGAgdGhlIHBhcmVudCBub2RlXG4gICAgICBjb25zdHJ1Y3RvcihwYXJlbnQxKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50MTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5wYXJlbnQub3B0aW9ucztcbiAgICAgICAgICB0aGlzLnN0cmluZ2lmeSA9IHRoaXMucGFyZW50LnN0cmluZ2lmeTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmJhc2VVUkkgPSBudWxsO1xuICAgICAgICAvLyBmaXJzdCBleGVjdXRpb24sIGxvYWQgZGVwZW5kZW5jaWVzIHRoYXQgYXJlIG90aGVyd2lzZVxuICAgICAgICAvLyBjaXJjdWxhciAoc28gd2UgY2FuJ3QgbG9hZCB0aGVtIGF0IHRoZSB0b3ApXG4gICAgICAgIGlmICghWE1MRWxlbWVudCkge1xuICAgICAgICAgIFhNTEVsZW1lbnQgPSByZXF1aXJlKCcuL1hNTEVsZW1lbnQnKTtcbiAgICAgICAgICBYTUxDRGF0YSA9IHJlcXVpcmUoJy4vWE1MQ0RhdGEnKTtcbiAgICAgICAgICBYTUxDb21tZW50ID0gcmVxdWlyZSgnLi9YTUxDb21tZW50Jyk7XG4gICAgICAgICAgWE1MRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL1hNTERlY2xhcmF0aW9uJyk7XG4gICAgICAgICAgWE1MRG9jVHlwZSA9IHJlcXVpcmUoJy4vWE1MRG9jVHlwZScpO1xuICAgICAgICAgIFhNTFJhdyA9IHJlcXVpcmUoJy4vWE1MUmF3Jyk7XG4gICAgICAgICAgWE1MVGV4dCA9IHJlcXVpcmUoJy4vWE1MVGV4dCcpO1xuICAgICAgICAgIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IHJlcXVpcmUoJy4vWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uJyk7XG4gICAgICAgICAgWE1MRHVtbXkgPSByZXF1aXJlKCcuL1hNTER1bW15Jyk7XG4gICAgICAgICAgTm9kZVR5cGUgPSByZXF1aXJlKCcuL05vZGVUeXBlJyk7XG4gICAgICAgICAgWE1MTm9kZUxpc3QgPSByZXF1aXJlKCcuL1hNTE5vZGVMaXN0Jyk7XG4gICAgICAgICAgWE1MTmFtZWROb2RlTWFwID0gcmVxdWlyZSgnLi9YTUxOYW1lZE5vZGVNYXAnKTtcbiAgICAgICAgICBEb2N1bWVudFBvc2l0aW9uID0gcmVxdWlyZSgnLi9Eb2N1bWVudFBvc2l0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgXG4gICAgICAvLyBTZXRzIHRoZSBwYXJlbnQgbm9kZSBvZiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbiByZWN1cnNpdmVseVxuXG4gICAgICAvLyBgcGFyZW50YCB0aGUgcGFyZW50IG5vZGVcbiAgICAgIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBqLCBsZW4sIHJlZjEsIHJlc3VsdHM7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zID0gcGFyZW50Lm9wdGlvbnM7XG4gICAgICAgICAgdGhpcy5zdHJpbmdpZnkgPSBwYXJlbnQuc3RyaW5naWZ5O1xuICAgICAgICB9XG4gICAgICAgIHJlZjEgPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBjaGlsZCA9IHJlZjFbal07XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGNoaWxkLnNldFBhcmVudCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZXMgYSBjaGlsZCBlbGVtZW50IG5vZGVcblxuICAgICAgLy8gYG5hbWVgIG5vZGUgbmFtZSBvciBhbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgWE1MIHRyZWVcbiAgICAgIC8vIGBhdHRyaWJ1dGVzYCBhbiBvYmplY3QgY29udGFpbmluZyBuYW1lL3ZhbHVlIHBhaXJzIG9mIGF0dHJpYnV0ZXNcbiAgICAgIC8vIGB0ZXh0YCBlbGVtZW50IHRleHRcbiAgICAgIGVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgICB2YXIgY2hpbGROb2RlLCBpdGVtLCBqLCBrLCBrZXksIGxhc3RDaGlsZCwgbGVuLCBsZW4xLCB2YWw7XG4gICAgICAgIGxhc3RDaGlsZCA9IG51bGw7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzID09PSBudWxsICYmICh0ZXh0ID09IG51bGwpKSB7XG4gICAgICAgICAgW2F0dHJpYnV0ZXMsIHRleHRdID0gW3t9LCBudWxsXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlcyA9PSBudWxsKSB7XG4gICAgICAgICAgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZXMgPSBnZXRWYWx1ZShhdHRyaWJ1dGVzKTtcbiAgICAgICAgLy8gc3dhcCBhcmd1bWVudCBvcmRlcjogdGV4dCA8LT4gYXR0cmlidXRlc1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgW3RleHQsIGF0dHJpYnV0ZXNdID0gW2F0dHJpYnV0ZXMsIHRleHRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuYW1lID0gZ2V0VmFsdWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhwYW5kIGlmIGFycmF5XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gbmFtZS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaXRlbSA9IG5hbWVbal07XG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmVsZW1lbnQoaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICAvLyBldmFsdWF0ZSBpZiBmdW5jdGlvblxuICAgICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24obmFtZSkpIHtcbiAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmVsZW1lbnQobmFtZS5hcHBseSgpKTtcbiAgICAgICAgLy8gZXhwYW5kIGlmIG9iamVjdFxuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgICAgZm9yIChrZXkgaW4gbmFtZSkge1xuICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwobmFtZSwga2V5KSkgY29udGludWU7XG4gICAgICAgICAgICB2YWwgPSBuYW1lW2tleV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWwpKSB7XG4gICAgICAgICAgICAgIC8vIGV2YWx1YXRlIGlmIGZ1bmN0aW9uXG4gICAgICAgICAgICAgIHZhbCA9IHZhbC5hcHBseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXNzaWduIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydEF0dEtleSAmJiBrZXkuaW5kZXhPZih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0QXR0S2V5KSA9PT0gMCkge1xuICAgICAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmF0dHJpYnV0ZShrZXkuc3Vic3RyKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRBdHRLZXkubGVuZ3RoKSwgdmFsKTtcbiAgICAgICAgICAgIC8vIHNraXAgZW1wdHkgYXJyYXlzXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuc2VwYXJhdGVBcnJheUl0ZW1zICYmIEFycmF5LmlzQXJyYXkodmFsKSAmJiBpc0VtcHR5KHZhbCkpIHtcbiAgICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5kdW1teSgpO1xuICAgICAgICAgICAgLy8gZW1wdHkgb2JqZWN0cyBwcm9kdWNlIG9uZSBub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgaXNFbXB0eSh2YWwpKSB7XG4gICAgICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudChrZXkpO1xuICAgICAgICAgICAgLy8gc2tpcCBudWxsIGFuZCB1bmRlZmluZWQgbm9kZXNcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5rZWVwTnVsbE5vZGVzICYmICh2YWwgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5kdW1teSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBleHBhbmQgbGlzdCBieSBjcmVhdGluZyBjaGlsZCBub2Rlc1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLnNlcGFyYXRlQXJyYXlJdGVtcyAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgICAgZm9yIChrID0gMCwgbGVuMSA9IHZhbC5sZW5ndGg7IGsgPCBsZW4xOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gdmFsW2tdO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IHt9O1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZVtrZXldID0gaXRlbTtcbiAgICAgICAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmVsZW1lbnQoY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBleHBhbmQgY2hpbGQgbm9kZXMgdW5kZXIgcGFyZW50XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgLy8gaWYgdGhlIGtleSBpcyAjdGV4dCBleHBhbmQgY2hpbGQgbm9kZXMgdW5kZXIgdGhpcyBub2RlIHRvIHN1cHBvcnQgbWl4ZWQgY29udGVudFxuICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pZ25vcmVEZWNvcmF0b3JzICYmIHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRUZXh0S2V5ICYmIGtleS5pbmRleE9mKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRUZXh0S2V5KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudCh2YWwpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudChrZXkpO1xuICAgICAgICAgICAgICAgIGxhc3RDaGlsZC5lbGVtZW50KHZhbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5lbGVtZW50KGtleSwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgbnVsbCBub2Rlc1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMua2VlcE51bGxOb2RlcyAmJiB0ZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5kdW1teSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRleHQgbm9kZVxuICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydFRleHRLZXkgJiYgbmFtZS5pbmRleE9mKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRUZXh0S2V5KSA9PT0gMCkge1xuICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy50ZXh0KHRleHQpO1xuICAgICAgICAgIC8vIGNkYXRhIG5vZGVcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlRGVjb3JhdG9ycyAmJiB0aGlzLnN0cmluZ2lmeS5jb252ZXJ0Q0RhdGFLZXkgJiYgbmFtZS5pbmRleE9mKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRDRGF0YUtleSkgPT09IDApIHtcbiAgICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuY2RhdGEodGV4dCk7XG4gICAgICAgICAgLy8gY29tbWVudCBub2RlXG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydENvbW1lbnRLZXkgJiYgbmFtZS5pbmRleE9mKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRDb21tZW50S2V5KSA9PT0gMCkge1xuICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5jb21tZW50KHRleHQpO1xuICAgICAgICAgIC8vIHJhdyB0ZXh0IG5vZGVcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlRGVjb3JhdG9ycyAmJiB0aGlzLnN0cmluZ2lmeS5jb252ZXJ0UmF3S2V5ICYmIG5hbWUuaW5kZXhPZih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0UmF3S2V5KSA9PT0gMCkge1xuICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5yYXcodGV4dCk7XG4gICAgICAgICAgLy8gcHJvY2Vzc2luZyBpbnN0cnVjdGlvblxuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5pZ25vcmVEZWNvcmF0b3JzICYmIHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRQSUtleSAmJiBuYW1lLmluZGV4T2YodGhpcy5zdHJpbmdpZnkuY29udmVydFBJS2V5KSA9PT0gMCkge1xuICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5pbnN0cnVjdGlvbihuYW1lLnN1YnN0cih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0UElLZXkubGVuZ3RoKSwgdGV4dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgbm9kZVxuICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5ub2RlKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdENoaWxkID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY3JlYXRlIGFueSBlbGVtZW50cyB3aXRoOiBcIiArIG5hbWUgKyBcIi4gXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdENoaWxkO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGVzIGEgY2hpbGQgZWxlbWVudCBub2RlIGJlZm9yZSB0aGUgY3VycmVudCBub2RlXG5cbiAgICAgIC8vIGBuYW1lYCBub2RlIG5hbWUgb3IgYW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIFhNTCB0cmVlXG4gICAgICAvLyBgYXR0cmlidXRlc2AgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmFtZS92YWx1ZSBwYWlycyBvZiBhdHRyaWJ1dGVzXG4gICAgICAvLyBgdGV4dGAgZWxlbWVudCB0ZXh0XG4gICAgICBpbnNlcnRCZWZvcmUobmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgICB2YXIgY2hpbGQsIGksIG5ld0NoaWxkLCByZWZDaGlsZCwgcmVtb3ZlZDtcbiAgICAgICAgLy8gRE9NIGxldmVsIDFcbiAgICAgICAgLy8gaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLCByZWZDaGlsZCkgaW5zZXJ0cyB0aGUgY2hpbGQgbm9kZSBuZXdDaGlsZCBiZWZvcmUgcmVmQ2hpbGRcbiAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCA/IG5hbWUudHlwZSA6IHZvaWQgMCkge1xuICAgICAgICAgIG5ld0NoaWxkID0gbmFtZTtcbiAgICAgICAgICByZWZDaGlsZCA9IGF0dHJpYnV0ZXM7XG4gICAgICAgICAgbmV3Q2hpbGQuc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICAgIGlmIChyZWZDaGlsZCkge1xuICAgICAgICAgICAgLy8gdGVtcG9yYXJpbHkgcmVtb3ZlIGNoaWxkcmVuIHN0YXJ0aW5nICp3aXRoKiByZWZDaGlsZFxuICAgICAgICAgICAgaSA9IGNoaWxkcmVuLmluZGV4T2YocmVmQ2hpbGQpO1xuICAgICAgICAgICAgcmVtb3ZlZCA9IGNoaWxkcmVuLnNwbGljZShpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYWRkIHRoZSBuZXcgY2hpbGRcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3Q2hpbGQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBhZGQgYmFjayByZW1vdmVkIGNoaWxkcmVuIGFmdGVyIG5ldyBjaGlsZFxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoY2hpbGRyZW4sIHJlbW92ZWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ld0NoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ld0NoaWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmlzUm9vdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluc2VydCBlbGVtZW50cyBhdCByb290IGxldmVsLiBcIiArIHRoaXMuZGVidWdJbmZvKG5hbWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gdGVtcG9yYXJpbHkgcmVtb3ZlIGNoaWxkcmVuIHN0YXJ0aW5nICp3aXRoKiB0aGlzXG4gICAgICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBhZGQgdGhlIG5ldyBjaGlsZFxuICAgICAgICAgIGNoaWxkID0gdGhpcy5wYXJlbnQuZWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBhZGQgYmFjayByZW1vdmVkIGNoaWxkcmVuIGFmdGVyIG5ldyBjaGlsZFxuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucGFyZW50LmNoaWxkcmVuLCByZW1vdmVkKTtcbiAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlcyBhIGNoaWxkIGVsZW1lbnQgbm9kZSBhZnRlciB0aGUgY3VycmVudCBub2RlXG5cbiAgICAgIC8vIGBuYW1lYCBub2RlIG5hbWUgb3IgYW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIFhNTCB0cmVlXG4gICAgICAvLyBgYXR0cmlidXRlc2AgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmFtZS92YWx1ZSBwYWlycyBvZiBhdHRyaWJ1dGVzXG4gICAgICAvLyBgdGV4dGAgZWxlbWVudCB0ZXh0XG4gICAgICBpbnNlcnRBZnRlcihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICAgIHZhciBjaGlsZCwgaSwgcmVtb3ZlZDtcbiAgICAgICAgaWYgKHRoaXMuaXNSb290KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluc2VydCBlbGVtZW50cyBhdCByb290IGxldmVsLiBcIiArIHRoaXMuZGVidWdJbmZvKG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gdGVtcG9yYXJpbHkgcmVtb3ZlIGNoaWxkcmVuIHN0YXJ0aW5nICphZnRlciogdGhpc1xuICAgICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpICsgMSk7XG4gICAgICAgIFxuICAgICAgICAvLyBhZGQgdGhlIG5ldyBjaGlsZFxuICAgICAgICBjaGlsZCA9IHRoaXMucGFyZW50LmVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgICAgIFxuICAgICAgICAvLyBhZGQgYmFjayByZW1vdmVkIGNoaWxkcmVuIGFmdGVyIG5ldyBjaGlsZFxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLnBhcmVudC5jaGlsZHJlbiwgcmVtb3ZlZCk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgICAgLy8gRGVsZXRlcyBhIGNoaWxkIGVsZW1lbnQgbm9kZVxuXG4gICAgICByZW1vdmUoKSB7XG4gICAgICAgIHZhciBpLCByZWYxO1xuICAgICAgICBpZiAodGhpcy5pc1Jvb3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVtb3ZlIHRoZSByb290IGVsZW1lbnQuIFwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICAgIHNwbGljZS5hcHBseSh0aGlzLnBhcmVudC5jaGlsZHJlbiwgW2ksIGkgLSBpICsgMV0uY29uY2F0KHJlZjEgPSBbXSkpLCByZWYxO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZXMgYSBub2RlXG5cbiAgICAgIC8vIGBuYW1lYCBuYW1lIG9mIHRoZSBub2RlXG4gICAgICAvLyBgYXR0cmlidXRlc2AgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmFtZS92YWx1ZSBwYWlycyBvZiBhdHRyaWJ1dGVzXG4gICAgICAvLyBgdGV4dGAgZWxlbWVudCB0ZXh0XG4gICAgICBub2RlKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmFtZSA9IGdldFZhbHVlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZXMgfHwgKGF0dHJpYnV0ZXMgPSB7fSk7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSBnZXRWYWx1ZShhdHRyaWJ1dGVzKTtcbiAgICAgICAgLy8gc3dhcCBhcmd1bWVudCBvcmRlcjogdGV4dCA8LT4gYXR0cmlidXRlc1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgW3RleHQsIGF0dHJpYnV0ZXNdID0gW2F0dHJpYnV0ZXMsIHRleHRdO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gbmV3IFhNTEVsZW1lbnQodGhpcywgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgICAgIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICBjaGlsZC50ZXh0KHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlcyBhIHRleHQgbm9kZVxuXG4gICAgICAvLyBgdmFsdWVgIGVsZW1lbnQgdGV4dFxuICAgICAgdGV4dCh2YWx1ZSkge1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gbmV3IFhNTFRleHQodGhpcywgdmFsdWUpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlcyBhIENEQVRBIG5vZGVcblxuICAgICAgLy8gYHZhbHVlYCBlbGVtZW50IHRleHQgd2l0aG91dCBDREFUQSBkZWxpbWl0ZXJzXG4gICAgICBjZGF0YSh2YWx1ZSkge1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIGNoaWxkID0gbmV3IFhNTENEYXRhKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZXMgYSBjb21tZW50IG5vZGVcblxuICAgICAgLy8gYHZhbHVlYCBjb21tZW50IHRleHRcbiAgICAgIGNvbW1lbnQodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICBjaGlsZCA9IG5ldyBYTUxDb21tZW50KHRoaXMsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZXMgYSBjb21tZW50IG5vZGUgYmVmb3JlIHRoZSBjdXJyZW50IG5vZGVcblxuICAgICAgLy8gYHZhbHVlYCBjb21tZW50IHRleHRcbiAgICAgIGNvbW1lbnRCZWZvcmUodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBpLCByZW1vdmVkO1xuICAgICAgICAvLyB0ZW1wb3JhcmlseSByZW1vdmUgY2hpbGRyZW4gc3RhcnRpbmcgKndpdGgqIHRoaXNcbiAgICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICAgIHJlbW92ZWQgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaSk7XG4gICAgICAgIC8vIGFkZCB0aGUgbmV3IGNoaWxkXG4gICAgICAgIGNoaWxkID0gdGhpcy5wYXJlbnQuY29tbWVudCh2YWx1ZSk7XG4gICAgICAgIC8vIGFkZCBiYWNrIHJlbW92ZWQgY2hpbGRyZW4gYWZ0ZXIgbmV3IGNoaWxkXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucGFyZW50LmNoaWxkcmVuLCByZW1vdmVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZXMgYSBjb21tZW50IG5vZGUgYWZ0ZXIgdGhlIGN1cnJlbnQgbm9kZVxuXG4gICAgICAvLyBgdmFsdWVgIGNvbW1lbnQgdGV4dFxuICAgICAgY29tbWVudEFmdGVyKHZhbHVlKSB7XG4gICAgICAgIHZhciBjaGlsZCwgaSwgcmVtb3ZlZDtcbiAgICAgICAgLy8gdGVtcG9yYXJpbHkgcmVtb3ZlIGNoaWxkcmVuIHN0YXJ0aW5nICphZnRlciogdGhpc1xuICAgICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpICsgMSk7XG4gICAgICAgIC8vIGFkZCB0aGUgbmV3IGNoaWxkXG4gICAgICAgIGNoaWxkID0gdGhpcy5wYXJlbnQuY29tbWVudCh2YWx1ZSk7XG4gICAgICAgIC8vIGFkZCBiYWNrIHJlbW92ZWQgY2hpbGRyZW4gYWZ0ZXIgbmV3IGNoaWxkXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucGFyZW50LmNoaWxkcmVuLCByZW1vdmVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZHMgdW5lc2NhcGVkIHJhdyB0ZXh0XG5cbiAgICAgIC8vIGB2YWx1ZWAgdGV4dFxuICAgICAgcmF3KHZhbHVlKSB7XG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgY2hpbGQgPSBuZXcgWE1MUmF3KHRoaXMsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZHMgYSBkdW1teSBub2RlXG4gICAgICBkdW1teSgpIHtcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICBjaGlsZCA9IG5ldyBYTUxEdW1teSh0aGlzKTtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2hlbiBhIG5ldyBub2RlIGlzIGNyZWF0ZWQgaXQgaXMgYWRkZWQgdG8gdGhlIGNoaWxkIG5vZGUgY29sbGVjdGlvbi5cbiAgICAgICAgLy8gSG93ZXZlciwgZHVtbXkgbm9kZXMgYXJlIG5ldmVyIGFkZGVkIHRvIHRoZSBYTUwgdHJlZS4gVGhleSBhcmUgY3JlYXRlZCB3aGlsZVxuICAgICAgICAvLyBjb252ZXJ0aW5nIEpTIG9iamVjdHMgdG8gWE1MIG5vZGVzIGluIG9yZGVyIG5vdCB0byBicmVhayB0aGUgcmVjdXJzaXZlIGZ1bmN0aW9uXG4gICAgICAgIC8vIGNoYWluLiBUaGV5IGNhbiBiZSB0aG91Z2h0IG9mIGFzIGludmlzaWJsZSBub2Rlcy4gVGhleSBjYW4gYmUgdHJhdmVyc2VkIHRocm91Z2hcbiAgICAgICAgLy8gYnkgdXNpbmcgcHJldigpLCBuZXh0KCksIHVwKCksIGV0Yy4gZnVuY3Rpb25zIGJ1dCB0aGV5IGRvIG5vdCBleGlzdHMgaW4gdGhlIHRyZWUuXG5cbiAgICAgICAgLy8gQGNoaWxkcmVuLnB1c2ggY2hpbGRcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGRzIGEgcHJvY2Vzc2luZyBpbnN0cnVjdGlvblxuXG4gICAgICAvLyBgdGFyZ2V0YCBpbnN0cnVjdGlvbiB0YXJnZXRcbiAgICAgIC8vIGB2YWx1ZWAgaW5zdHJ1Y3Rpb24gdmFsdWVcbiAgICAgIGluc3RydWN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGluc1RhcmdldCwgaW5zVmFsdWUsIGluc3RydWN0aW9uLCBqLCBsZW47XG4gICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgIHRhcmdldCA9IGdldFZhbHVlKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7IC8vIGV4cGFuZCBpZiBhcnJheVxuICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHRhcmdldC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaW5zVGFyZ2V0ID0gdGFyZ2V0W2pdO1xuICAgICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbihpbnNUYXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh0YXJnZXQpKSB7IC8vIGV4cGFuZCBpZiBvYmplY3RcbiAgICAgICAgICBmb3IgKGluc1RhcmdldCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHRhcmdldCwgaW5zVGFyZ2V0KSkgY29udGludWU7XG4gICAgICAgICAgICBpbnNWYWx1ZSA9IHRhcmdldFtpbnNUYXJnZXRdO1xuICAgICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbihpbnNUYXJnZXQsIGluc1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmFwcGx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RydWN0aW9uID0gbmV3IFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbih0aGlzLCB0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goaW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGVzIGEgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2RlIGJlZm9yZSB0aGUgY3VycmVudCBub2RlXG5cbiAgICAgIC8vIGB0YXJnZXRgIGluc3RydWN0aW9uIHRhcmdldFxuICAgICAgLy8gYHZhbHVlYCBpbnN0cnVjdGlvbiB2YWx1ZVxuICAgICAgaW5zdHJ1Y3Rpb25CZWZvcmUodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICB2YXIgY2hpbGQsIGksIHJlbW92ZWQ7XG4gICAgICAgIC8vIHRlbXBvcmFyaWx5IHJlbW92ZSBjaGlsZHJlbiBzdGFydGluZyAqd2l0aCogdGhpc1xuICAgICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpKTtcbiAgICAgICAgLy8gYWRkIHRoZSBuZXcgY2hpbGRcbiAgICAgICAgY2hpbGQgPSB0aGlzLnBhcmVudC5pbnN0cnVjdGlvbih0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgLy8gYWRkIGJhY2sgcmVtb3ZlZCBjaGlsZHJlbiBhZnRlciBuZXcgY2hpbGRcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5wYXJlbnQuY2hpbGRyZW4sIHJlbW92ZWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlcyBhIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZSBhZnRlciB0aGUgY3VycmVudCBub2RlXG5cbiAgICAgIC8vIGB0YXJnZXRgIGluc3RydWN0aW9uIHRhcmdldFxuICAgICAgLy8gYHZhbHVlYCBpbnN0cnVjdGlvbiB2YWx1ZVxuICAgICAgaW5zdHJ1Y3Rpb25BZnRlcih0YXJnZXQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBjaGlsZCwgaSwgcmVtb3ZlZDtcbiAgICAgICAgLy8gdGVtcG9yYXJpbHkgcmVtb3ZlIGNoaWxkcmVuIHN0YXJ0aW5nICphZnRlciogdGhpc1xuICAgICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpICsgMSk7XG4gICAgICAgIC8vIGFkZCB0aGUgbmV3IGNoaWxkXG4gICAgICAgIGNoaWxkID0gdGhpcy5wYXJlbnQuaW5zdHJ1Y3Rpb24odGFyZ2V0LCB2YWx1ZSk7XG4gICAgICAgIC8vIGFkZCBiYWNrIHJlbW92ZWQgY2hpbGRyZW4gYWZ0ZXIgbmV3IGNoaWxkXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucGFyZW50LmNoaWxkcmVuLCByZW1vdmVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZXMgdGhlIHhtbCBkZWNsYXJhdGlvblxuXG4gICAgICAvLyBgdmVyc2lvbmAgQSB2ZXJzaW9uIG51bWJlciBzdHJpbmcsIGUuZy4gMS4wXG4gICAgICAvLyBgZW5jb2RpbmdgIEVuY29kaW5nIGRlY2xhcmF0aW9uLCBlLmcuIFVURi04XG4gICAgICAvLyBgc3RhbmRhbG9uZWAgc3RhbmRhbG9uZSBkb2N1bWVudCBkZWNsYXJhdGlvbjogdHJ1ZSBvciBmYWxzZVxuICAgICAgZGVjbGFyYXRpb24odmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpIHtcbiAgICAgICAgdmFyIGRvYywgeG1sZGVjO1xuICAgICAgICBkb2MgPSB0aGlzLmRvY3VtZW50KCk7XG4gICAgICAgIHhtbGRlYyA9IG5ldyBYTUxEZWNsYXJhdGlvbihkb2MsIHZlcnNpb24sIGVuY29kaW5nLCBzdGFuZGFsb25lKTtcbiAgICAgICAgLy8gUmVwbGFjZSBYTUwgZGVjbGFyYXRpb24gaWYgZXhpc3RzLCBvdGhlcndpc2UgaW5zZXJ0IGF0IHRvcFxuICAgICAgICBpZiAoZG9jLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRvYy5jaGlsZHJlbi51bnNoaWZ0KHhtbGRlYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9jLmNoaWxkcmVuWzBdLnR5cGUgPT09IE5vZGVUeXBlLkRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgZG9jLmNoaWxkcmVuWzBdID0geG1sZGVjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvYy5jaGlsZHJlbi51bnNoaWZ0KHhtbGRlYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvYy5yb290KCkgfHwgZG9jO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGVzIHRoZSBkb2N1bWVudCB0eXBlIGRlY2xhcmF0aW9uXG5cbiAgICAgIC8vIGBwdWJJRGAgdGhlIHB1YmxpYyBpZGVudGlmaWVyIG9mIHRoZSBleHRlcm5hbCBzdWJzZXRcbiAgICAgIC8vIGBzeXNJRGAgdGhlIHN5c3RlbSBpZGVudGlmaWVyIG9mIHRoZSBleHRlcm5hbCBzdWJzZXRcbiAgICAgIGR0ZChwdWJJRCwgc3lzSUQpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBkb2MsIGRvY3R5cGUsIGksIGosIGssIGxlbiwgbGVuMSwgcmVmMSwgcmVmMjtcbiAgICAgICAgZG9jID0gdGhpcy5kb2N1bWVudCgpO1xuICAgICAgICBkb2N0eXBlID0gbmV3IFhNTERvY1R5cGUoZG9jLCBwdWJJRCwgc3lzSUQpO1xuICAgICAgICByZWYxID0gZG9jLmNoaWxkcmVuO1xuICAgICAgICAvLyBSZXBsYWNlIERURCBpZiBleGlzdHNcbiAgICAgICAgZm9yIChpID0gaiA9IDAsIGxlbiA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWYxW2ldO1xuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBOb2RlVHlwZS5Eb2NUeXBlKSB7XG4gICAgICAgICAgICBkb2MuY2hpbGRyZW5baV0gPSBkb2N0eXBlO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3R5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlZjIgPSBkb2MuY2hpbGRyZW47XG4gICAgICAgIC8vIGluc2VydCBiZWZvcmUgcm9vdCBub2RlIGlmIHRoZSByb290IG5vZGUgZXhpc3RzXG4gICAgICAgIGZvciAoaSA9IGsgPSAwLCBsZW4xID0gcmVmMi5sZW5ndGg7IGsgPCBsZW4xOyBpID0gKytrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWYyW2ldO1xuICAgICAgICAgIGlmIChjaGlsZC5pc1Jvb3QpIHtcbiAgICAgICAgICAgIGRvYy5jaGlsZHJlbi5zcGxpY2UoaSwgMCwgZG9jdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gZG9jdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlIGFwcGVuZCB0byBlbmRcbiAgICAgICAgZG9jLmNoaWxkcmVuLnB1c2goZG9jdHlwZSk7XG4gICAgICAgIHJldHVybiBkb2N0eXBlO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXRzIHRoZSBwYXJlbnQgbm9kZVxuICAgICAgdXAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUm9vdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByb290IG5vZGUgaGFzIG5vIHBhcmVudC4gVXNlIGRvYygpIGlmIHlvdSBuZWVkIHRvIGdldCB0aGUgZG9jdW1lbnQgb2JqZWN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldHMgdGhlIHJvb3Qgbm9kZVxuICAgICAgcm9vdCgpIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIG5vZGUgPSB0aGlzO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IE5vZGVUeXBlLkRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5yb290T2JqZWN0O1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5pc1Jvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEdldHMgdGhlIG5vZGUgcmVwcmVzZW50aW5nIHRoZSBYTUwgZG9jdW1lbnRcbiAgICAgIGRvY3VtZW50KCkge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgbm9kZSA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEVuZHMgdGhlIGRvY3VtZW50IGFuZCBjb252ZXJ0cyBzdHJpbmdcbiAgICAgIGVuZChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50KCkuZW5kKG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXRzIHRoZSBwcmV2aW91cyBub2RlXG4gICAgICBwcmV2KCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGlmIChpIDwgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgYXQgdGhlIGZpcnN0IG5vZGUuIFwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkcmVuW2kgLSAxXTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0cyB0aGUgbmV4dCBub2RlXG4gICAgICBuZXh0KCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGlmIChpID09PSAtMSB8fCBpID09PSB0aGlzLnBhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBhdCB0aGUgbGFzdCBub2RlLiBcIiArIHRoaXMuZGVidWdJbmZvKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZHJlbltpICsgMV07XG4gICAgICB9XG5cbiAgICAgIC8vIEltcG9ydHMgY2xvbmVkIHJvb3QgZnJvbSBhbm90aGVyIFhNTCBkb2N1bWVudFxuXG4gICAgICAvLyBgZG9jYCB0aGUgWE1MIGRvY3VtZW50IHRvIGluc2VydCBub2RlcyBmcm9tXG4gICAgICBpbXBvcnREb2N1bWVudChkb2MpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBjbG9uZWRSb290LCBqLCBsZW4sIHJlZjE7XG4gICAgICAgIGNsb25lZFJvb3QgPSBkb2Mucm9vdCgpLmNsb25lKCk7XG4gICAgICAgIGNsb25lZFJvb3QucGFyZW50ID0gdGhpcztcbiAgICAgICAgY2xvbmVkUm9vdC5pc1Jvb3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNsb25lZFJvb3QpO1xuICAgICAgICAvLyBzZXQgcHJvcGVydGllcyBpZiBpbXBvcnRlZCBlbGVtZW50IGJlY29tZXMgdGhlIHJvb3Qgbm9kZVxuICAgICAgICBpZiAodGhpcy50eXBlID09PSBOb2RlVHlwZS5Eb2N1bWVudCkge1xuICAgICAgICAgIGNsb25lZFJvb3QuaXNSb290ID0gdHJ1ZTtcbiAgICAgICAgICBjbG9uZWRSb290LmRvY3VtZW50T2JqZWN0ID0gdGhpcztcbiAgICAgICAgICB0aGlzLnJvb3RPYmplY3QgPSBjbG9uZWRSb290O1xuICAgICAgICAgIC8vIHNldCBkdGQgbmFtZVxuICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICByZWYxID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IHJlZjEubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgY2hpbGQgPSByZWYxW2pdO1xuICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gTm9kZVR5cGUuRG9jVHlwZSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLm5hbWUgPSBjbG9uZWRSb290Lm5hbWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIFxuICAgICAgLy8gUmV0dXJucyBkZWJ1ZyBzdHJpbmcgZm9yIHRoaXMgbm9kZVxuICAgICAgZGVidWdJbmZvKG5hbWUpIHtcbiAgICAgICAgdmFyIHJlZjEsIHJlZjI7XG4gICAgICAgIG5hbWUgPSBuYW1lIHx8IHRoaXMubmFtZTtcbiAgICAgICAgaWYgKChuYW1lID09IG51bGwpICYmICEoKHJlZjEgPSB0aGlzLnBhcmVudCkgIT0gbnVsbCA/IHJlZjEubmFtZSA6IHZvaWQgMCkpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gXCJwYXJlbnQ6IDxcIiArIHRoaXMucGFyZW50Lm5hbWUgKyBcIj5cIjtcbiAgICAgICAgfSBlbHNlIGlmICghKChyZWYyID0gdGhpcy5wYXJlbnQpICE9IG51bGwgPyByZWYyLm5hbWUgOiB2b2lkIDApKSB7XG4gICAgICAgICAgcmV0dXJuIFwibm9kZTogPFwiICsgbmFtZSArIFwiPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBcIm5vZGU6IDxcIiArIG5hbWUgKyBcIj4sIHBhcmVudDogPFwiICsgdGhpcy5wYXJlbnQubmFtZSArIFwiPlwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFsaWFzZXNcbiAgICAgIGVsZShuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgICB9XG5cbiAgICAgIG5vZChuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHR4dCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZGF0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNkYXRhKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgY29tKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpbnModGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbih0YXJnZXQsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZG9jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudCgpO1xuICAgICAgfVxuXG4gICAgICBkZWModmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjbGFyYXRpb24odmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpO1xuICAgICAgfVxuXG4gICAgICBlKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICAgIH1cblxuICAgICAgbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2RhdGEodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBjKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGkodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbih0YXJnZXQsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXAoKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2FuIGJlIGRlcHJlY2F0ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZVxuICAgICAgaW1wb3J0WE1MQnVpbGRlcihkb2MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0RG9jdW1lbnQoZG9jKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkcyBvciBtb2RpZmllcyBhbiBhdHRyaWJ1dGUuXG5cbiAgICAgIC8vIGBuYW1lYCBhdHRyaWJ1dGUgbmFtZVxuICAgICAgLy8gYHZhbHVlYCBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgIGF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdHRyaWJ1dGUoKSBhcHBsaWVzIHRvIGVsZW1lbnQgbm9kZXMgb25seS5cIik7XG4gICAgICB9XG5cbiAgICAgIGF0dChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBhKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZXMgYW4gYXR0cmlidXRlXG5cbiAgICAgIC8vIGBuYW1lYCBhdHRyaWJ1dGUgbmFtZVxuICAgICAgcmVtb3ZlQXR0cmlidXRlKG5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXR0cmlidXRlKCkgYXBwbGllcyB0byBlbGVtZW50IG5vZGVzIG9ubHkuXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBET00gbGV2ZWwgMSBmdW5jdGlvbnMgdG8gYmUgaW1wbGVtZW50ZWQgbGF0ZXJcbiAgICAgIHJlcGxhY2VDaGlsZChuZXdDaGlsZCwgb2xkQ2hpbGQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBET00gbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5cIiArIHRoaXMuZGVidWdJbmZvKCkpO1xuICAgICAgfVxuXG4gICAgICByZW1vdmVDaGlsZChvbGRDaGlsZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGFwcGVuZENoaWxkKG5ld0NoaWxkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgaGFzQ2hpbGROb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAwO1xuICAgICAgfVxuXG4gICAgICBjbG9uZU5vZGUoZGVlcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIG5vcm1hbGl6ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBET00gbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5cIiArIHRoaXMuZGVidWdJbmZvKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBET00gbGV2ZWwgMlxuICAgICAgaXNTdXBwb3J0ZWQoZmVhdHVyZSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaGFzQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlicy5sZW5ndGggIT09IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIERPTSBsZXZlbCAzIGZ1bmN0aW9ucyB0byBiZSBpbXBsZW1lbnRlZCBsYXRlclxuICAgICAgY29tcGFyZURvY3VtZW50UG9zaXRpb24ob3RoZXIpIHtcbiAgICAgICAgdmFyIHJlZiwgcmVzO1xuICAgICAgICByZWYgPSB0aGlzO1xuICAgICAgICBpZiAocmVmID09PSBvdGhlcikge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZG9jdW1lbnQoKSAhPT0gb3RoZXIuZG9jdW1lbnQoKSkge1xuICAgICAgICAgIHJlcyA9IERvY3VtZW50UG9zaXRpb24uRGlzY29ubmVjdGVkIHwgRG9jdW1lbnRQb3NpdGlvbi5JbXBsZW1lbnRhdGlvblNwZWNpZmljO1xuICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC41KSB7XG4gICAgICAgICAgICByZXMgfD0gRG9jdW1lbnRQb3NpdGlvbi5QcmVjZWRpbmc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyB8PSBEb2N1bWVudFBvc2l0aW9uLkZvbGxvd2luZztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIGlmIChyZWYuaXNBbmNlc3RvcihvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gRG9jdW1lbnRQb3NpdGlvbi5Db250YWlucyB8IERvY3VtZW50UG9zaXRpb24uUHJlY2VkaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZi5pc0Rlc2NlbmRhbnQob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIERvY3VtZW50UG9zaXRpb24uQ29udGFpbnMgfCBEb2N1bWVudFBvc2l0aW9uLkZvbGxvd2luZztcbiAgICAgICAgfSBlbHNlIGlmIChyZWYuaXNQcmVjZWRpbmcob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIERvY3VtZW50UG9zaXRpb24uUHJlY2VkaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBEb2N1bWVudFBvc2l0aW9uLkZvbGxvd2luZztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpc1NhbWVOb2RlKG90aGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgbG9va3VwUHJlZml4KG5hbWVzcGFjZVVSSSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGlzRGVmYXVsdE5hbWVzcGFjZShuYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBET00gbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5cIiArIHRoaXMuZGVidWdJbmZvKCkpO1xuICAgICAgfVxuXG4gICAgICBsb29rdXBOYW1lc3BhY2VVUkkocHJlZml4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgaXNFcXVhbE5vZGUobm9kZSkge1xuICAgICAgICB2YXIgaSwgaiwgcmVmMTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IHRoaXMubm9kZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmMSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgKDAgPD0gcmVmMSA/IGogPD0gcmVmMSA6IGogPj0gcmVmMSk7IGkgPSAwIDw9IHJlZjEgPyArK2ogOiAtLWopIHtcbiAgICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW5baV0uaXNFcXVhbE5vZGUobm9kZS5jaGlsZHJlbltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGdldEZlYXR1cmUoZmVhdHVyZSwgdmVyc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIHNldFVzZXJEYXRhKGtleSwgZGF0YSwgaGFuZGxlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIGdldFVzZXJEYXRhKGtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBvdGhlciBpcyBhbiBpbmNsdXNpdmUgZGVzY2VuZGFudCBvZiBub2RlLFxuICAgICAgLy8gYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgIGNvbnRhaW5zKG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG90aGVyID09PSB0aGlzIHx8IHRoaXMuaXNEZXNjZW5kYW50KG90aGVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gQW4gb2JqZWN0IEEgaXMgY2FsbGVkIGEgZGVzY2VuZGFudCBvZiBhbiBvYmplY3QgQiwgaWYgZWl0aGVyIEEgaXMgXG4gICAgICAvLyBhIGNoaWxkIG9mIEIgb3IgQSBpcyBhIGNoaWxkIG9mIGFuIG9iamVjdCBDIHRoYXQgaXMgYSBkZXNjZW5kYW50IG9mIEIuXG4gICAgICBpc0Rlc2NlbmRhbnQobm9kZSkge1xuICAgICAgICB2YXIgY2hpbGQsIGlzRGVzY2VuZGFudENoaWxkLCBqLCBsZW4sIHJlZjE7XG4gICAgICAgIHJlZjEgPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWYxW2pdO1xuICAgICAgICAgIGlmIChub2RlID09PSBjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzRGVzY2VuZGFudENoaWxkID0gY2hpbGQuaXNEZXNjZW5kYW50KG5vZGUpO1xuICAgICAgICAgIGlmIChpc0Rlc2NlbmRhbnRDaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQW4gb2JqZWN0IEEgaXMgY2FsbGVkIGFuIGFuY2VzdG9yIG9mIGFuIG9iamVjdCBCIGlmIGFuZCBvbmx5IGlmXG4gICAgICAvLyBCIGlzIGEgZGVzY2VuZGFudCBvZiBBLlxuICAgICAgaXNBbmNlc3Rvcihub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmlzRGVzY2VuZGFudCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gQW4gb2JqZWN0IEEgaXMgcHJlY2VkaW5nIGFuIG9iamVjdCBCIGlmIEEgYW5kIEIgYXJlIGluIHRoZSBcbiAgICAgIC8vIHNhbWUgdHJlZSBhbmQgQSBjb21lcyBiZWZvcmUgQiBpbiB0cmVlIG9yZGVyLlxuICAgICAgaXNQcmVjZWRpbmcobm9kZSkge1xuICAgICAgICB2YXIgbm9kZVBvcywgdGhpc1BvcztcbiAgICAgICAgbm9kZVBvcyA9IHRoaXMudHJlZVBvc2l0aW9uKG5vZGUpO1xuICAgICAgICB0aGlzUG9zID0gdGhpcy50cmVlUG9zaXRpb24odGhpcyk7XG4gICAgICAgIGlmIChub2RlUG9zID09PSAtMSB8fCB0aGlzUG9zID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZVBvcyA8IHRoaXNQb3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQW4gb2JqZWN0IEEgaXMgZm9sbGxvd2luZyBhbiBvYmplY3QgQiBpZiBBIGFuZCBCIGFyZSBpbiB0aGUgXG4gICAgICAvLyBzYW1lIHRyZWUgYW5kIEEgY29tZXMgYWZ0ZXIgQiBpbiB0cmVlIG9yZGVyLlxuICAgICAgaXNGb2xsb3dpbmcobm9kZSkge1xuICAgICAgICB2YXIgbm9kZVBvcywgdGhpc1BvcztcbiAgICAgICAgbm9kZVBvcyA9IHRoaXMudHJlZVBvc2l0aW9uKG5vZGUpO1xuICAgICAgICB0aGlzUG9zID0gdGhpcy50cmVlUG9zaXRpb24odGhpcyk7XG4gICAgICAgIGlmIChub2RlUG9zID09PSAtMSB8fCB0aGlzUG9zID09PSAtMSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZVBvcyA+IHRoaXNQb3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJucyB0aGUgcHJlb3JkZXIgcG9zaXRpb24gb2YgdGhlIGdpdmVuIG5vZGUgaW4gdGhlIHRyZWUsIG9yIC0xXG4gICAgICAvLyBpZiB0aGUgbm9kZSBpcyBub3QgaW4gdGhlIHRyZWUuXG4gICAgICB0cmVlUG9zaXRpb24obm9kZSkge1xuICAgICAgICB2YXIgZm91bmQsIHBvcztcbiAgICAgICAgcG9zID0gMDtcbiAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb3JlYWNoVHJlZU5vZGUodGhpcy5kb2N1bWVudCgpLCBmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBpZiAoIWZvdW5kICYmIGNoaWxkTm9kZSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBcbiAgICAgIC8vIERlcHRoLWZpcnN0IHByZW9yZGVyIHRyYXZlcnNhbCB0aHJvdWdoIHRoZSBYTUwgdHJlZVxuICAgICAgZm9yZWFjaFRyZWVOb2RlKG5vZGUsIGZ1bmMpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBqLCBsZW4sIHJlZjEsIHJlcztcbiAgICAgICAgbm9kZSB8fCAobm9kZSA9IHRoaXMuZG9jdW1lbnQoKSk7XG4gICAgICAgIHJlZjEgPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWYxW2pdO1xuICAgICAgICAgIGlmIChyZXMgPSBmdW5jKGNoaWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gdGhpcy5mb3JlYWNoVHJlZU5vZGUoY2hpbGQsIGZ1bmMpO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIERPTSBsZXZlbCAxXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTE5vZGUucHJvdG90eXBlLCAnbm9kZU5hbWUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTE5vZGUucHJvdG90eXBlLCAnbm9kZVR5cGUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTE5vZGUucHJvdG90eXBlLCAnbm9kZVZhbHVlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MTm9kZS5wcm90b3R5cGUsICdwYXJlbnROb2RlJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTE5vZGUucHJvdG90eXBlLCAnY2hpbGROb2RlcycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGlsZE5vZGVMaXN0IHx8ICF0aGlzLmNoaWxkTm9kZUxpc3Qubm9kZXMpIHtcbiAgICAgICAgICB0aGlzLmNoaWxkTm9kZUxpc3QgPSBuZXcgWE1MTm9kZUxpc3QodGhpcy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2RlTGlzdDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShYTUxOb2RlLnByb3RvdHlwZSwgJ2ZpcnN0Q2hpbGQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXSB8fCBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTE5vZGUucHJvdG90eXBlLCAnbGFzdENoaWxkJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTE5vZGUucHJvdG90eXBlLCAncHJldmlvdXNTaWJsaW5nJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGRyZW5baSAtIDFdIHx8IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MTm9kZS5wcm90b3R5cGUsICduZXh0U2libGluZycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkcmVuW2kgKyAxXSB8fCBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTE5vZGUucHJvdG90eXBlLCAnb3duZXJEb2N1bWVudCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50KCkgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIERPTSBsZXZlbCAzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTE5vZGUucHJvdG90eXBlLCAndGV4dENvbnRlbnQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hpbGQsIGosIGxlbiwgcmVmMSwgc3RyO1xuICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCB8fCB0aGlzLm5vZGVUeXBlID09PSBOb2RlVHlwZS5Eb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgICAgc3RyID0gJyc7XG4gICAgICAgICAgcmVmMSA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgY2hpbGQgPSByZWYxW2pdO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgIHN0ciArPSBjaGlsZC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBET00gbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5cIiArIHRoaXMuZGVidWdJbmZvKCkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFhNTE5vZGU7XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi40LjFcbihmdW5jdGlvbigpIHtcbiAgLy8gUmVwcmVzZW50cyBhIGxpc3Qgb2Ygbm9kZXNcbiAgdmFyIFhNTE5vZGVMaXN0O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MTm9kZUxpc3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgWE1MTm9kZUxpc3Qge1xuICAgICAgLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYFhNTE5vZGVMaXN0YFxuICAgICAgLy8gVGhpcyBpcyBqdXN0IGEgd3JhcHBlciBhcm91bmQgYW4gb3JkaW5hcnlcbiAgICAgIC8vIEpTIGFycmF5LlxuXG4gICAgICAvLyBgbm9kZXNgIHRoZSBhcnJheSBjb250YWluaW5nIG5vZGVzLlxuICAgICAgY29uc3RydWN0b3Iobm9kZXMpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGEgZGVlcCBjbG9uZSBvZiBgdGhpc2BcblxuICAgICAgY2xvbmUoKSB7XG4gICAgICAgIC8vIHRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSBjbG9uZWQgc2luY2UgaXQgd3JhcHNcbiAgICAgICAgLy8gYXJvdW5kIGEgZ2l2ZW4gYXJyYXkuIFRoZSBjYWxsaW5nIGZ1bmN0aW9uIHNob3VsZCBjaGVja1xuICAgICAgICAvLyB3aGV0aGVyIHRoZSB3cmFwcGVkIGFycmF5IGlzIG51bGwgYW5kIHN1cHBseSBhIG5ldyBhcnJheVxuICAgICAgICAvLyAoZnJvbSB0aGUgY2xvbmUpLlxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIERPTSBMZXZlbCAxXG4gICAgICBpdGVtKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzW2luZGV4XSB8fCBudWxsO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIERPTSBsZXZlbCAxXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTE5vZGVMaXN0LnByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aCB8fCAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIFhNTE5vZGVMaXN0O1xuXG4gIH0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuNC4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBOb2RlVHlwZSwgWE1MQ2hhcmFjdGVyRGF0YSwgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uO1xuXG4gIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9Ob2RlVHlwZScpO1xuXG4gIFhNTENoYXJhY3RlckRhdGEgPSByZXF1aXJlKCcuL1hNTENoYXJhY3RlckRhdGEnKTtcblxuICAvLyBSZXByZXNlbnRzIGEgcHJvY2Vzc2luZyBpbnN0cnVjdGlvblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IGNsYXNzIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiBleHRlbmRzIFhNTENoYXJhY3RlckRhdGEge1xuICAgIC8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIGBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25gXG5cbiAgICAvLyBgcGFyZW50YCB0aGUgcGFyZW50IG5vZGVcbiAgICAvLyBgdGFyZ2V0YCBpbnN0cnVjdGlvbiB0YXJnZXRcbiAgICAvLyBgdmFsdWVgIGluc3RydWN0aW9uIHZhbHVlXG4gICAgY29uc3RydWN0b3IocGFyZW50LCB0YXJnZXQsIHZhbHVlKSB7XG4gICAgICBzdXBlcihwYXJlbnQpO1xuICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgaW5zdHJ1Y3Rpb24gdGFyZ2V0LiBcIiArIHRoaXMuZGVidWdJbmZvKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy50eXBlID0gTm9kZVR5cGUuUHJvY2Vzc2luZ0luc3RydWN0aW9uO1xuICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLnN0cmluZ2lmeS5pbnNUYXJnZXQodGFyZ2V0KTtcbiAgICAgIHRoaXMubmFtZSA9IHRoaXMudGFyZ2V0O1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5pbnNWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGRlZXAgY2xvbmUgb2YgYHRoaXNgXG4gICAgY2xvbmUoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0cyB0aGUgWE1MIGZyYWdtZW50IHRvIHN0cmluZ1xuXG4gICAgLy8gYG9wdGlvbnMucHJldHR5YCBwcmV0dHkgcHJpbnRzIHRoZSByZXN1bHRcbiAgICAvLyBgb3B0aW9ucy5pbmRlbnRgIGluZGVudGF0aW9uIGZvciBwcmV0dHkgcHJpbnRcbiAgICAvLyBgb3B0aW9ucy5vZmZzZXRgIGhvdyBtYW55IGluZGVudGF0aW9ucyB0byBhZGQgdG8gZXZlcnkgbGluZSBmb3IgcHJldHR5IHByaW50XG4gICAgLy8gYG9wdGlvbnMubmV3bGluZWAgbmV3bGluZSBzZXF1ZW5jZSBmb3IgcHJldHR5IHByaW50XG4gICAgdG9TdHJpbmcob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy53cml0ZXIucHJvY2Vzc2luZ0luc3RydWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy53cml0ZXIuZmlsdGVyT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgfVxuXG4gICAgaXNFcXVhbE5vZGUobm9kZSkge1xuICAgICAgaWYgKCFzdXBlci5pc0VxdWFsTm9kZShub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS50YXJnZXQgIT09IHRoaXMudGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjQuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgTm9kZVR5cGUsIFhNTE5vZGUsIFhNTFJhdztcblxuICBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vTm9kZVR5cGUnKTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgLy8gUmVwcmVzZW50cyBhICByYXcgbm9kZVxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFJhdyA9IGNsYXNzIFhNTFJhdyBleHRlbmRzIFhNTE5vZGUge1xuICAgIC8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIGBYTUxSYXdgXG5cbiAgICAvLyBgdGV4dGAgcmF3IHRleHRcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHRleHQpIHtcbiAgICAgIHN1cGVyKHBhcmVudCk7XG4gICAgICBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmF3IHRleHQuIFwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnR5cGUgPSBOb2RlVHlwZS5SYXc7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5zdHJpbmdpZnkucmF3KHRleHQpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZXMgYW5kIHJldHVybnMgYSBkZWVwIGNsb25lIG9mIGB0aGlzYFxuICAgIGNsb25lKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydHMgdGhlIFhNTCBmcmFnbWVudCB0byBzdHJpbmdcblxuICAgIC8vIGBvcHRpb25zLnByZXR0eWAgcHJldHR5IHByaW50cyB0aGUgcmVzdWx0XG4gICAgLy8gYG9wdGlvbnMuaW5kZW50YCBpbmRlbnRhdGlvbiBmb3IgcHJldHR5IHByaW50XG4gICAgLy8gYG9wdGlvbnMub2Zmc2V0YCBob3cgbWFueSBpbmRlbnRhdGlvbnMgdG8gYWRkIHRvIGV2ZXJ5IGxpbmUgZm9yIHByZXR0eSBwcmludFxuICAgIC8vIGBvcHRpb25zLm5ld2xpbmVgIG5ld2xpbmUgc2VxdWVuY2UgZm9yIHByZXR0eSBwcmludFxuICAgIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnJhdyh0aGlzLCB0aGlzLm9wdGlvbnMud3JpdGVyLmZpbHRlck9wdGlvbnMob3B0aW9ucykpO1xuICAgIH1cblxuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjQuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgTm9kZVR5cGUsIFdyaXRlclN0YXRlLCBYTUxTdHJlYW1Xcml0ZXIsIFhNTFdyaXRlckJhc2UsXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9Ob2RlVHlwZScpO1xuXG4gIFhNTFdyaXRlckJhc2UgPSByZXF1aXJlKCcuL1hNTFdyaXRlckJhc2UnKTtcblxuICBXcml0ZXJTdGF0ZSA9IHJlcXVpcmUoJy4vV3JpdGVyU3RhdGUnKTtcblxuICAvLyBQcmludHMgWE1MIG5vZGVzIHRvIGEgc3RyZWFtXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MU3RyZWFtV3JpdGVyID0gY2xhc3MgWE1MU3RyZWFtV3JpdGVyIGV4dGVuZHMgWE1MV3JpdGVyQmFzZSB7XG4gICAgLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYFhNTFN0cmVhbVdyaXRlcmBcblxuICAgIC8vIGBzdHJlYW1gIG91dHB1dCBzdHJlYW1cbiAgICAvLyBgb3B0aW9ucy5wcmV0dHlgIHByZXR0eSBwcmludHMgdGhlIHJlc3VsdFxuICAgIC8vIGBvcHRpb25zLmluZGVudGAgaW5kZW50YXRpb24gc3RyaW5nXG4gICAgLy8gYG9wdGlvbnMubmV3bGluZWAgbmV3bGluZSBzZXF1ZW5jZVxuICAgIC8vIGBvcHRpb25zLm9mZnNldGAgYSBmaXhlZCBudW1iZXIgb2YgaW5kZW50YXRpb25zIHRvIGFkZCB0byBldmVyeSBsaW5lXG4gICAgLy8gYG9wdGlvbnMuYWxsb3dFbXB0eWAgZG8gbm90IHNlbGYgY2xvc2UgZW1wdHkgZWxlbWVudCB0YWdzXG4gICAgLy8gJ29wdGlvbnMuZG9udFByZXR0eVRleHROb2RlcycgaWYgYW55IHRleHQgaXMgcHJlc2VudCBpbiBub2RlLCBkb24ndCBpbmRlbnQgb3IgTEZcbiAgICAvLyBgb3B0aW9ucy5zcGFjZUJlZm9yZVNsYXNoYCBhZGQgYSBzcGFjZSBiZWZvcmUgdGhlIGNsb3Npbmcgc2xhc2ggb2YgZW1wdHkgZWxlbWVudHNcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW0sIG9wdGlvbnMpIHtcbiAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgfVxuXG4gICAgZW5kbGluZShub2RlLCBvcHRpb25zLCBsZXZlbCkge1xuICAgICAgaWYgKG5vZGUuaXNMYXN0Um9vdE5vZGUgJiYgb3B0aW9ucy5zdGF0ZSA9PT0gV3JpdGVyU3RhdGUuQ2xvc2VUYWcpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuZGxpbmUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRvY3VtZW50KGRvYywgb3B0aW9ucykge1xuICAgICAgdmFyIGNoaWxkLCBpLCBqLCBrLCBsZW4xLCBsZW4yLCByZWYsIHJlZjEsIHJlc3VsdHM7XG4gICAgICByZWYgPSBkb2MuY2hpbGRyZW47XG4gICAgICAvLyBzZXQgYSBmbGFnIHNvIHRoYXQgd2UgZG9uJ3QgaW5zZXJ0IGEgbmV3bGluZSBhZnRlciB0aGUgbGFzdCByb290IGxldmVsIG5vZGUgXG4gICAgICBmb3IgKGkgPSBqID0gMCwgbGVuMSA9IHJlZi5sZW5ndGg7IGogPCBsZW4xOyBpID0gKytqKSB7XG4gICAgICAgIGNoaWxkID0gcmVmW2ldO1xuICAgICAgICBjaGlsZC5pc0xhc3RSb290Tm9kZSA9IGkgPT09IGRvYy5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IHRoaXMuZmlsdGVyT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHJlZjEgPSBkb2MuY2hpbGRyZW47XG4gICAgICByZXN1bHRzID0gW107XG4gICAgICBmb3IgKGsgPSAwLCBsZW4yID0gcmVmMS5sZW5ndGg7IGsgPCBsZW4yOyBrKyspIHtcbiAgICAgICAgY2hpbGQgPSByZWYxW2tdO1xuICAgICAgICByZXN1bHRzLnB1c2godGhpcy53cml0ZUNoaWxkTm9kZShjaGlsZCwgb3B0aW9ucywgMCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgY2RhdGEobm9kZSwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZShzdXBlci5jZGF0YShub2RlLCBvcHRpb25zLCBsZXZlbCkpO1xuICAgIH1cblxuICAgIGNvbW1lbnQobm9kZSwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZShzdXBlci5jb21tZW50KG5vZGUsIG9wdGlvbnMsIGxldmVsKSk7XG4gICAgfVxuXG4gICAgZGVjbGFyYXRpb24obm9kZSwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZShzdXBlci5kZWNsYXJhdGlvbihub2RlLCBvcHRpb25zLCBsZXZlbCkpO1xuICAgIH1cblxuICAgIGRvY1R5cGUobm9kZSwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHZhciBjaGlsZCwgaiwgbGVuMSwgcmVmO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICB0aGlzLm9wZW5Ob2RlKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5PcGVuVGFnO1xuICAgICAgdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5pbmRlbnQobm9kZSwgb3B0aW9ucywgbGV2ZWwpKTtcbiAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCc8IURPQ1RZUEUgJyArIG5vZGUucm9vdCgpLm5hbWUpO1xuICAgICAgLy8gZXh0ZXJuYWwgaWRlbnRpZmllclxuICAgICAgaWYgKG5vZGUucHViSUQgJiYgbm9kZS5zeXNJRCkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnIFBVQkxJQyBcIicgKyBub2RlLnB1YklEICsgJ1wiIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5zeXNJRCkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnIFNZU1RFTSBcIicgKyBub2RlLnN5c0lEICsgJ1wiJyk7XG4gICAgICB9XG4gICAgICAvLyBpbnRlcm5hbCBzdWJzZXRcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJyBbJyk7XG4gICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKHRoaXMuZW5kbGluZShub2RlLCBvcHRpb25zLCBsZXZlbCkpO1xuICAgICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuSW5zaWRlVGFnO1xuICAgICAgICByZWYgPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gcmVmLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgICAgIGNoaWxkID0gcmVmW2pdO1xuICAgICAgICAgIHRoaXMud3JpdGVDaGlsZE5vZGUoY2hpbGQsIG9wdGlvbnMsIGxldmVsICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkNsb3NlVGFnO1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnXScpO1xuICAgICAgfVxuICAgICAgLy8gY2xvc2UgdGFnXG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuQ2xvc2VUYWc7XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZShvcHRpb25zLnNwYWNlQmVmb3JlU2xhc2ggKyAnPicpO1xuICAgICAgdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5lbmRsaW5lKG5vZGUsIG9wdGlvbnMsIGxldmVsKSk7XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuTm9uZTtcbiAgICAgIHJldHVybiB0aGlzLmNsb3NlTm9kZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgZWxlbWVudChub2RlLCBvcHRpb25zLCBsZXZlbCkge1xuICAgICAgdmFyIGF0dCwgYXR0TGVuLCBjaGlsZCwgY2hpbGROb2RlQ291bnQsIGZpcnN0Q2hpbGROb2RlLCBqLCBsZW4sIGxlbjEsIG5hbWUsIHByZXR0eVN1cHByZXNzZWQsIHIsIHJhdHQsIHJlZiwgcmVmMSwgcmVmMiwgcmxpbmU7XG4gICAgICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgICAgIC8vIG9wZW4gdGFnXG4gICAgICB0aGlzLm9wZW5Ob2RlKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5PcGVuVGFnO1xuICAgICAgciA9IHRoaXMuaW5kZW50KG5vZGUsIG9wdGlvbnMsIGxldmVsKSArICc8JyArIG5vZGUubmFtZTtcbiAgICAgIC8vIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChvcHRpb25zLnByZXR0eSAmJiBvcHRpb25zLndpZHRoID4gMCkge1xuICAgICAgICBsZW4gPSByLmxlbmd0aDtcbiAgICAgICAgcmVmID0gbm9kZS5hdHRyaWJzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmKSB7XG4gICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBuYW1lKSkgY29udGludWU7XG4gICAgICAgICAgYXR0ID0gcmVmW25hbWVdO1xuICAgICAgICAgIHJhdHQgPSB0aGlzLmF0dHJpYnV0ZShhdHQsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgICAgICBhdHRMZW4gPSByYXR0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAobGVuICsgYXR0TGVuID4gb3B0aW9ucy53aWR0aCkge1xuICAgICAgICAgICAgcmxpbmUgPSB0aGlzLmluZGVudChub2RlLCBvcHRpb25zLCBsZXZlbCArIDEpICsgcmF0dDtcbiAgICAgICAgICAgIHIgKz0gdGhpcy5lbmRsaW5lKG5vZGUsIG9wdGlvbnMsIGxldmVsKSArIHJsaW5lO1xuICAgICAgICAgICAgbGVuID0gcmxpbmUubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBybGluZSA9ICcgJyArIHJhdHQ7XG4gICAgICAgICAgICByICs9IHJsaW5lO1xuICAgICAgICAgICAgbGVuICs9IHJsaW5lLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZjEgPSBub2RlLmF0dHJpYnM7XG4gICAgICAgIGZvciAobmFtZSBpbiByZWYxKSB7XG4gICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmMSwgbmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIGF0dCA9IHJlZjFbbmFtZV07XG4gICAgICAgICAgciArPSB0aGlzLmF0dHJpYnV0ZShhdHQsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zdHJlYW0ud3JpdGUocik7XG4gICAgICBjaGlsZE5vZGVDb3VudCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgZmlyc3RDaGlsZE5vZGUgPSBjaGlsZE5vZGVDb3VudCA9PT0gMCA/IG51bGwgOiBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgaWYgKGNoaWxkTm9kZUNvdW50ID09PSAwIHx8IG5vZGUuY2hpbGRyZW4uZXZlcnkoZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gKGUudHlwZSA9PT0gTm9kZVR5cGUuVGV4dCB8fCBlLnR5cGUgPT09IE5vZGVUeXBlLlJhdyB8fCBlLnR5cGUgPT09IE5vZGVUeXBlLkNEYXRhKSAmJiBlLnZhbHVlID09PSAnJztcbiAgICAgIH0pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnRcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dFbXB0eSkge1xuICAgICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCc+Jyk7XG4gICAgICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkNsb3NlVGFnO1xuICAgICAgICAgIHRoaXMuc3RyZWFtLndyaXRlKCc8LycgKyBub2RlLm5hbWUgKyAnPicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5DbG9zZVRhZztcbiAgICAgICAgICB0aGlzLnN0cmVhbS53cml0ZShvcHRpb25zLnNwYWNlQmVmb3JlU2xhc2ggKyAnLz4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnByZXR0eSAmJiBjaGlsZE5vZGVDb3VudCA9PT0gMSAmJiAoZmlyc3RDaGlsZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuVGV4dCB8fCBmaXJzdENoaWxkTm9kZS50eXBlID09PSBOb2RlVHlwZS5SYXcgfHwgZmlyc3RDaGlsZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuQ0RhdGEpICYmIChmaXJzdENoaWxkTm9kZS52YWx1ZSAhPSBudWxsKSkge1xuICAgICAgICAvLyBkbyBub3QgaW5kZW50IHRleHQtb25seSBub2Rlc1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnPicpO1xuICAgICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuSW5zaWRlVGFnO1xuICAgICAgICBvcHRpb25zLnN1cHByZXNzUHJldHR5Q291bnQrKztcbiAgICAgICAgcHJldHR5U3VwcHJlc3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMud3JpdGVDaGlsZE5vZGUoZmlyc3RDaGlsZE5vZGUsIG9wdGlvbnMsIGxldmVsICsgMSk7XG4gICAgICAgIG9wdGlvbnMuc3VwcHJlc3NQcmV0dHlDb3VudC0tO1xuICAgICAgICBwcmV0dHlTdXBwcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5DbG9zZVRhZztcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoJzwvJyArIG5vZGUubmFtZSArICc+Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZSgnPicgKyB0aGlzLmVuZGxpbmUobm9kZSwgb3B0aW9ucywgbGV2ZWwpKTtcbiAgICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkluc2lkZVRhZztcbiAgICAgICAgcmVmMiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgIC8vIGlubmVyIHRhZ3NcbiAgICAgICAgZm9yIChqID0gMCwgbGVuMSA9IHJlZjIubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWYyW2pdO1xuICAgICAgICAgIHRoaXMud3JpdGVDaGlsZE5vZGUoY2hpbGQsIG9wdGlvbnMsIGxldmVsICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xvc2UgdGFnXG4gICAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5DbG9zZVRhZztcbiAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUodGhpcy5pbmRlbnQobm9kZSwgb3B0aW9ucywgbGV2ZWwpICsgJzwvJyArIG5vZGUubmFtZSArICc+Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0cmVhbS53cml0ZSh0aGlzLmVuZGxpbmUobm9kZSwgb3B0aW9ucywgbGV2ZWwpKTtcbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5Ob25lO1xuICAgICAgcmV0dXJuIHRoaXMuY2xvc2VOb2RlKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb24obm9kZSwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZShzdXBlci5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24obm9kZSwgb3B0aW9ucywgbGV2ZWwpKTtcbiAgICB9XG5cbiAgICByYXcobm9kZSwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZShzdXBlci5yYXcobm9kZSwgb3B0aW9ucywgbGV2ZWwpKTtcbiAgICB9XG5cbiAgICB0ZXh0KG5vZGUsIG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUoc3VwZXIudGV4dChub2RlLCBvcHRpb25zLCBsZXZlbCkpO1xuICAgIH1cblxuICAgIGR0ZEF0dExpc3Qobm9kZSwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZShzdXBlci5kdGRBdHRMaXN0KG5vZGUsIG9wdGlvbnMsIGxldmVsKSk7XG4gICAgfVxuXG4gICAgZHRkRWxlbWVudChub2RlLCBvcHRpb25zLCBsZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHN1cGVyLmR0ZEVsZW1lbnQobm9kZSwgb3B0aW9ucywgbGV2ZWwpKTtcbiAgICB9XG5cbiAgICBkdGRFbnRpdHkobm9kZSwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZShzdXBlci5kdGRFbnRpdHkobm9kZSwgb3B0aW9ucywgbGV2ZWwpKTtcbiAgICB9XG5cbiAgICBkdGROb3RhdGlvbihub2RlLCBvcHRpb25zLCBsZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKHN1cGVyLmR0ZE5vdGF0aW9uKG5vZGUsIG9wdGlvbnMsIGxldmVsKSk7XG4gICAgfVxuXG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuNC4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxTdHJpbmdXcml0ZXIsIFhNTFdyaXRlckJhc2U7XG5cbiAgWE1MV3JpdGVyQmFzZSA9IHJlcXVpcmUoJy4vWE1MV3JpdGVyQmFzZScpO1xuXG4gIC8vIFByaW50cyBYTUwgbm9kZXMgYXMgcGxhaW4gdGV4dFxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFN0cmluZ1dyaXRlciA9IGNsYXNzIFhNTFN0cmluZ1dyaXRlciBleHRlbmRzIFhNTFdyaXRlckJhc2Uge1xuICAgIC8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIGBYTUxTdHJpbmdXcml0ZXJgXG5cbiAgICAvLyBgb3B0aW9ucy5wcmV0dHlgIHByZXR0eSBwcmludHMgdGhlIHJlc3VsdFxuICAgIC8vIGBvcHRpb25zLmluZGVudGAgaW5kZW50YXRpb24gc3RyaW5nXG4gICAgLy8gYG9wdGlvbnMubmV3bGluZWAgbmV3bGluZSBzZXF1ZW5jZVxuICAgIC8vIGBvcHRpb25zLm9mZnNldGAgYSBmaXhlZCBudW1iZXIgb2YgaW5kZW50YXRpb25zIHRvIGFkZCB0byBldmVyeSBsaW5lXG4gICAgLy8gYG9wdGlvbnMuYWxsb3dFbXB0eWAgZG8gbm90IHNlbGYgY2xvc2UgZW1wdHkgZWxlbWVudCB0YWdzXG4gICAgLy8gJ29wdGlvbnMuZG9udFByZXR0eVRleHROb2RlcycgaWYgYW55IHRleHQgaXMgcHJlc2VudCBpbiBub2RlLCBkb24ndCBpbmRlbnQgb3IgTEZcbiAgICAvLyBgb3B0aW9ucy5zcGFjZUJlZm9yZVNsYXNoYCBhZGQgYSBzcGFjZSBiZWZvcmUgdGhlIGNsb3Npbmcgc2xhc2ggb2YgZW1wdHkgZWxlbWVudHNcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG5cbiAgICBkb2N1bWVudChkb2MsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgbGVuLCByLCByZWY7XG4gICAgICBvcHRpb25zID0gdGhpcy5maWx0ZXJPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgciA9ICcnO1xuICAgICAgcmVmID0gZG9jLmNoaWxkcmVuO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gcmVmW2ldO1xuICAgICAgICByICs9IHRoaXMud3JpdGVDaGlsZE5vZGUoY2hpbGQsIG9wdGlvbnMsIDApO1xuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIG5ld2xpbmVcbiAgICAgIGlmIChvcHRpb25zLnByZXR0eSAmJiByLnNsaWNlKC1vcHRpb25zLm5ld2xpbmUubGVuZ3RoKSA9PT0gb3B0aW9ucy5uZXdsaW5lKSB7XG4gICAgICAgIHIgPSByLnNsaWNlKDAsIC1vcHRpb25zLm5ld2xpbmUubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjQuMVxuKGZ1bmN0aW9uKCkge1xuICAvLyBDb252ZXJ0cyB2YWx1ZXMgdG8gc3RyaW5nc1xuICB2YXIgWE1MU3RyaW5naWZpZXIsXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MU3RyaW5naWZpZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgWE1MU3RyaW5naWZpZXIge1xuICAgICAgLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYFhNTFN0cmluZ2lmaWVyYFxuXG4gICAgICAvLyBgb3B0aW9ucy52ZXJzaW9uYCBUaGUgdmVyc2lvbiBudW1iZXIgc3RyaW5nIG9mIHRoZSBYTUwgc3BlYyB0byB2YWxpZGF0ZSBhZ2FpbnN0LCBlLmcuIDEuMFxuICAgICAgLy8gYG9wdGlvbnMubm9Eb3VibGVFbmNvZGluZ2Agd2hldGhlciBleGlzdGluZyBodG1sIGVudGl0aWVzIGFyZSBlbmNvZGVkOiB0cnVlIG9yIGZhbHNlXG4gICAgICAvLyBgb3B0aW9ucy5zdHJpbmdpZnlgIGEgc2V0IG9mIGZ1bmN0aW9ucyB0byB1c2UgZm9yIGNvbnZlcnRpbmcgdmFsdWVzIHRvIHN0cmluZ3NcbiAgICAgIC8vIGBvcHRpb25zLm5vVmFsaWRhdGlvbmAgd2hldGhlciB2YWx1ZXMgd2lsbCBiZSB2YWxpZGF0ZWQgYW5kIGVzY2FwZWQgb3IgcmV0dXJuZWQgYXMgaXNcbiAgICAgIC8vIGBvcHRpb25zLmludmFsaWRDaGFyUmVwbGFjZW1lbnRgIGEgY2hhcmFjdGVyIHRvIHJlcGxhY2UgaW52YWxpZCBjaGFyYWN0ZXJzIGFuZCBkaXNhYmxlIGNoYXJhY3RlciB2YWxpZGF0aW9uXG4gICAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBrZXksIHJlZiwgdmFsdWU7XG4gICAgICAgIC8vIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBzdHJpbmcgY29udGFpbnMgbGVnYWwgY2hhcmFjdGVyc1xuICAgICAgICAvLyBGYWlscyB3aXRoIGFuIGV4Y2VwdGlvbiBvbiBlcnJvclxuXG4gICAgICAgIC8vIGBzdHJgIHRoZSBzdHJpbmcgdG8gY2hlY2tcbiAgICAgICAgdGhpcy5hc3NlcnRMZWdhbENoYXIgPSB0aGlzLmFzc2VydExlZ2FsQ2hhci5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIGxlZ2FsIGNoYXJhY3RlcnMgZm9yIGEgbmFtZVxuICAgICAgICAvLyBGYWlscyB3aXRoIGFuIGV4Y2VwdGlvbiBvbiBlcnJvclxuXG4gICAgICAgIC8vIGBzdHJgIHRoZSBzdHJpbmcgdG8gY2hlY2tcbiAgICAgICAgdGhpcy5hc3NlcnRMZWdhbE5hbWUgPSB0aGlzLmFzc2VydExlZ2FsTmFtZS5iaW5kKHRoaXMpO1xuICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnZlcnNpb24gPSAnMS4wJztcbiAgICAgICAgfVxuICAgICAgICByZWYgPSBvcHRpb25zLnN0cmluZ2lmeSB8fCB7fTtcbiAgICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICB2YWx1ZSA9IHJlZltrZXldO1xuICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERlZmF1bHRzXG4gICAgICBuYW1lKHZhbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vVmFsaWRhdGlvbikge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0TGVnYWxOYW1lKCcnICsgdmFsIHx8ICcnKTtcbiAgICAgIH1cblxuICAgICAgdGV4dCh2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub1ZhbGlkYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2VydExlZ2FsQ2hhcih0aGlzLnRleHRFc2NhcGUoJycgKyB2YWwgfHwgJycpKTtcbiAgICAgIH1cblxuICAgICAgY2RhdGEodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9WYWxpZGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoJ11dPicsICddXV1dPjwhW0NEQVRBWz4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0TGVnYWxDaGFyKHZhbCk7XG4gICAgICB9XG5cbiAgICAgIGNvbW1lbnQodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9WYWxpZGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgICAgaWYgKHZhbC5tYXRjaCgvLS0vKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbW1lbnQgdGV4dCBjYW5ub3QgY29udGFpbiBkb3VibGUtaHlwZW46IFwiICsgdmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3NlcnRMZWdhbENoYXIodmFsKTtcbiAgICAgIH1cblxuICAgICAgcmF3KHZhbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vVmFsaWRhdGlvbikge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgICAgfVxuXG4gICAgICBhdHRWYWx1ZSh2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub1ZhbGlkYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2VydExlZ2FsQ2hhcih0aGlzLmF0dEVzY2FwZSh2YWwgPSAnJyArIHZhbCB8fCAnJykpO1xuICAgICAgfVxuXG4gICAgICBpbnNUYXJnZXQodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9WYWxpZGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3NlcnRMZWdhbENoYXIoJycgKyB2YWwgfHwgJycpO1xuICAgICAgfVxuXG4gICAgICBpbnNWYWx1ZSh2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub1ZhbGlkYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9ICcnICsgdmFsIHx8ICcnO1xuICAgICAgICBpZiAodmFsLm1hdGNoKC9cXD8+LykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gdmFsdWU6IFwiICsgdmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3NlcnRMZWdhbENoYXIodmFsKTtcbiAgICAgIH1cblxuICAgICAgeG1sVmVyc2lvbih2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub1ZhbGlkYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHZhbCA9ICcnICsgdmFsIHx8ICcnO1xuICAgICAgICBpZiAoIXZhbC5tYXRjaCgvMVxcLlswLTldKy8pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2ZXJzaW9uIG51bWJlcjogXCIgKyB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG5cbiAgICAgIHhtbEVuY29kaW5nKHZhbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vVmFsaWRhdGlvbikge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gJycgKyB2YWwgfHwgJyc7XG4gICAgICAgIGlmICghdmFsLm1hdGNoKC9eW0EtWmEtel0oPzpbQS1aYS16MC05Ll8tXSkqJC8pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbmNvZGluZzogXCIgKyB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2VydExlZ2FsQ2hhcih2YWwpO1xuICAgICAgfVxuXG4gICAgICB4bWxTdGFuZGFsb25lKHZhbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vVmFsaWRhdGlvbikge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgIHJldHVybiBcInllc1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBcIm5vXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZHRkUHViSUQodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9WYWxpZGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3NlcnRMZWdhbENoYXIoJycgKyB2YWwgfHwgJycpO1xuICAgICAgfVxuXG4gICAgICBkdGRTeXNJRCh2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub1ZhbGlkYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2VydExlZ2FsQ2hhcignJyArIHZhbCB8fCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGR0ZEVsZW1lbnRWYWx1ZSh2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub1ZhbGlkYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2VydExlZ2FsQ2hhcignJyArIHZhbCB8fCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGR0ZEF0dFR5cGUodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9WYWxpZGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3NlcnRMZWdhbENoYXIoJycgKyB2YWwgfHwgJycpO1xuICAgICAgfVxuXG4gICAgICBkdGRBdHREZWZhdWx0KHZhbCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vVmFsaWRhdGlvbikge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0TGVnYWxDaGFyKCcnICsgdmFsIHx8ICcnKTtcbiAgICAgIH1cblxuICAgICAgZHRkRW50aXR5VmFsdWUodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9WYWxpZGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3NlcnRMZWdhbENoYXIoJycgKyB2YWwgfHwgJycpO1xuICAgICAgfVxuXG4gICAgICBkdGRORGF0YSh2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub1ZhbGlkYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2VydExlZ2FsQ2hhcignJyArIHZhbCB8fCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGFzc2VydExlZ2FsQ2hhcihzdHIpIHtcbiAgICAgICAgdmFyIHJlZ2V4LCByZXM7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9WYWxpZGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZlcnNpb24gPT09ICcxLjAnKSB7XG4gICAgICAgICAgLy8gVmFsaWQgY2hhcmFjdGVycyBmcm9tIGh0dHBzOi8vd3d3LnczLm9yZy9UUi94bWwvI2NoYXJzZXRzXG4gICAgICAgICAgLy8gYW55IFVuaWNvZGUgY2hhcmFjdGVyLCBleGNsdWRpbmcgdGhlIHN1cnJvZ2F0ZSBibG9ja3MsIEZGRkUsIGFuZCBGRkZGLlxuICAgICAgICAgIC8vICN4OSB8ICN4QSB8ICN4RCB8IFsjeDIwLSN4RDdGRl0gfCBbI3hFMDAwLSN4RkZGRF0gfCBbI3gxMDAwMC0jeDEwRkZGRl1cbiAgICAgICAgICAvLyBUaGlzIEVTNSBjb21wYXRpYmxlIFJlZ2V4cCBoYXMgYmVlbiBnZW5lcmF0ZWQgdXNpbmcgdGhlIFwicmVnZW5lcmF0ZVwiIE5QTSBtb2R1bGU6XG4gICAgICAgICAgLy8gICBsZXQgeG1sXzEwX0ludmFsaWRDaGFycyA9IHJlZ2VuZXJhdGUoKVxuICAgICAgICAgIC8vICAgICAuYWRkUmFuZ2UoMHgwMDAwLCAweDAwMDgpXG4gICAgICAgICAgLy8gICAgIC5hZGQoMHgwMDBCLCAweDAwMEMpXG4gICAgICAgICAgLy8gICAgIC5hZGRSYW5nZSgweDAwMEUsIDB4MDAxRilcbiAgICAgICAgICAvLyAgICAgLmFkZFJhbmdlKDB4RDgwMCwgMHhERkZGKVxuICAgICAgICAgIC8vICAgICAuYWRkUmFuZ2UoMHhGRkZFLCAweEZGRkYpXG4gICAgICAgICAgcmVnZXggPSAvW1xcMC1cXHgwOFxceDBCXFxmXFx4MEUtXFx4MUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vZztcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmludmFsaWRDaGFyUmVwbGFjZW1lbnQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UocmVnZXgsIHRoaXMub3B0aW9ucy5pbnZhbGlkQ2hhclJlcGxhY2VtZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlcyA9IHN0ci5tYXRjaChyZWdleCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGFyYWN0ZXIgaW4gc3RyaW5nOiAke3N0cn0gYXQgaW5kZXggJHtyZXMuaW5kZXh9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy52ZXJzaW9uID09PSAnMS4xJykge1xuICAgICAgICAgIC8vIFZhbGlkIGNoYXJhY3RlcnMgZnJvbSBodHRwczovL3d3dy53My5vcmcvVFIveG1sMTEvI2NoYXJzZXRzXG4gICAgICAgICAgLy8gYW55IFVuaWNvZGUgY2hhcmFjdGVyLCBleGNsdWRpbmcgdGhlIHN1cnJvZ2F0ZSBibG9ja3MsIEZGRkUsIGFuZCBGRkZGLlxuICAgICAgICAgIC8vIFsjeDEtI3hEN0ZGXSB8IFsjeEUwMDAtI3hGRkZEXSB8IFsjeDEwMDAwLSN4MTBGRkZGXVxuICAgICAgICAgIC8vIFRoaXMgRVM1IGNvbXBhdGlibGUgUmVnZXhwIGhhcyBiZWVuIGdlbmVyYXRlZCB1c2luZyB0aGUgXCJyZWdlbmVyYXRlXCIgTlBNIG1vZHVsZTpcbiAgICAgICAgICAvLyAgIGxldCB4bWxfMTFfSW52YWxpZENoYXJzID0gcmVnZW5lcmF0ZSgpXG4gICAgICAgICAgLy8gICAgIC5hZGQoMHgwMDAwKVxuICAgICAgICAgIC8vICAgICAuYWRkUmFuZ2UoMHhEODAwLCAweERGRkYpXG4gICAgICAgICAgLy8gICAgIC5hZGRSYW5nZSgweEZGRkUsIDB4RkZGRilcbiAgICAgICAgICByZWdleCA9IC9bXFwwXFx1RkZGRVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdL2c7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbnZhbGlkQ2hhclJlcGxhY2VtZW50ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKHJlZ2V4LCB0aGlzLm9wdGlvbnMuaW52YWxpZENoYXJSZXBsYWNlbWVudCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXMgPSBzdHIubWF0Y2gocmVnZXgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hhcmFjdGVyIGluIHN0cmluZzogJHtzdHJ9IGF0IGluZGV4ICR7cmVzLmluZGV4fWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnRMZWdhbE5hbWUoc3RyKSB7XG4gICAgICAgIHZhciByZWdleDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub1ZhbGlkYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIHN0ciA9IHRoaXMuYXNzZXJ0TGVnYWxDaGFyKHN0cik7XG4gICAgICAgIHJlZ2V4ID0gL14oWzpBLVpfYS16XFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF18W1xcdUQ4MDAtXFx1REI3Rl1bXFx1REMwMC1cXHVERkZGXSkoW1xceDJEXFwuMC06QS1aX2EtelxceEI3XFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXXxbXFx1RDgwMC1cXHVEQjdGXVtcXHVEQzAwLVxcdURGRkZdKSokLztcbiAgICAgICAgaWYgKCFzdHIubWF0Y2gocmVnZXgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYXJhY3RlciBpbiBuYW1lOiAke3N0cn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuXG4gICAgICAvLyBFc2NhcGVzIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0ZXh0XG5cbiAgICAgIC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAwL1dELXhtbC1jMTRuLTIwMDAwMTE5Lmh0bWwjY2hhcmVzY2FwaW5nXG5cbiAgICAgIC8vIGBzdHJgIHRoZSBzdHJpbmcgdG8gZXNjYXBlXG4gICAgICB0ZXh0RXNjYXBlKHN0cikge1xuICAgICAgICB2YXIgYW1wcmVnZXg7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9WYWxpZGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgICAgICBhbXByZWdleCA9IHRoaXMub3B0aW9ucy5ub0RvdWJsZUVuY29kaW5nID8gLyg/ISYobHR8Z3R8YW1wfGFwb3N8cXVvdCk7KSYvZyA6IC8mL2c7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShhbXByZWdleCwgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cXHIvZywgJyYjeEQ7Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVzY2FwZXMgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGF0dHJpYnV0ZSB2YWx1ZXNcblxuICAgICAgLy8gU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDAvV0QteG1sLWMxNG4tMjAwMDAxMTkuaHRtbCNjaGFyZXNjYXBpbmdcblxuICAgICAgLy8gYHN0cmAgdGhlIHN0cmluZyB0byBlc2NhcGVcbiAgICAgIGF0dEVzY2FwZShzdHIpIHtcbiAgICAgICAgdmFyIGFtcHJlZ2V4O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vVmFsaWRhdGlvbikge1xuICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgYW1wcmVnZXggPSB0aGlzLm9wdGlvbnMubm9Eb3VibGVFbmNvZGluZyA/IC8oPyEmKGx0fGd0fGFtcHxhcG9zfHF1b3QpOykmL2cgOiAvJi9nO1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoYW1wcmVnZXgsICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykucmVwbGFjZSgvXFx0L2csICcmI3g5OycpLnJlcGxhY2UoL1xcbi9nLCAnJiN4QTsnKS5yZXBsYWNlKC9cXHIvZywgJyYjeEQ7Jyk7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgLy8gc3RyaW5ncyB0byBtYXRjaCB3aGlsZSBjb252ZXJ0aW5nIGZyb20gSlMgb2JqZWN0c1xuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb252ZXJ0QXR0S2V5ID0gJ0AnO1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNvbnZlcnRQSUtleSA9ICc/JztcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb252ZXJ0VGV4dEtleSA9ICcjdGV4dCc7XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuY29udmVydENEYXRhS2V5ID0gJyNjZGF0YSc7XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuY29udmVydENvbW1lbnRLZXkgPSAnI2NvbW1lbnQnO1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNvbnZlcnRSYXdLZXkgPSAnI3Jhdyc7XG5cbiAgICByZXR1cm4gWE1MU3RyaW5naWZpZXI7XG5cbiAgfSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMi40LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIE5vZGVUeXBlLCBYTUxDaGFyYWN0ZXJEYXRhLCBYTUxUZXh0O1xuXG4gIE5vZGVUeXBlID0gcmVxdWlyZSgnLi9Ob2RlVHlwZScpO1xuXG4gIFhNTENoYXJhY3RlckRhdGEgPSByZXF1aXJlKCcuL1hNTENoYXJhY3RlckRhdGEnKTtcblxuICAvLyBSZXByZXNlbnRzIGEgdGV4dCBub2RlXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MVGV4dCA9IChmdW5jdGlvbigpIHtcbiAgICBjbGFzcyBYTUxUZXh0IGV4dGVuZHMgWE1MQ2hhcmFjdGVyRGF0YSB7XG4gICAgICAvLyBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiBgWE1MVGV4dGBcblxuICAgICAgLy8gYHRleHRgIGVsZW1lbnQgdGV4dFxuICAgICAgY29uc3RydWN0b3IocGFyZW50LCB0ZXh0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCk7XG4gICAgICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGVsZW1lbnQgdGV4dC4gXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSBcIiN0ZXh0XCI7XG4gICAgICAgIHRoaXMudHlwZSA9IE5vZGVUeXBlLlRleHQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS50ZXh0KHRleHQpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGEgZGVlcCBjbG9uZSBvZiBgdGhpc2BcbiAgICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29udmVydHMgdGhlIFhNTCBmcmFnbWVudCB0byBzdHJpbmdcblxuICAgICAgLy8gYG9wdGlvbnMucHJldHR5YCBwcmV0dHkgcHJpbnRzIHRoZSByZXN1bHRcbiAgICAgIC8vIGBvcHRpb25zLmluZGVudGAgaW5kZW50YXRpb24gZm9yIHByZXR0eSBwcmludFxuICAgICAgLy8gYG9wdGlvbnMub2Zmc2V0YCBob3cgbWFueSBpbmRlbnRhdGlvbnMgdG8gYWRkIHRvIGV2ZXJ5IGxpbmUgZm9yIHByZXR0eSBwcmludFxuICAgICAgLy8gYG9wdGlvbnMubmV3bGluZWAgbmV3bGluZSBzZXF1ZW5jZSBmb3IgcHJldHR5IHByaW50XG4gICAgICB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud3JpdGVyLnRleHQodGhpcywgdGhpcy5vcHRpb25zLndyaXRlci5maWx0ZXJPcHRpb25zKG9wdGlvbnMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gRE9NIGxldmVsIDEgZnVuY3Rpb25zIHRvIGJlIGltcGxlbWVudGVkIGxhdGVyXG4gICAgICBzcGxpdFRleHQob2Zmc2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgRE9NIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIgKyB0aGlzLmRlYnVnSW5mbygpKTtcbiAgICAgIH1cblxuICAgICAgLy8gRE9NIGxldmVsIDMgZnVuY3Rpb25zIHRvIGJlIGltcGxlbWVudGVkIGxhdGVyXG4gICAgICByZXBsYWNlV2hvbGVUZXh0KGNvbnRlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBET00gbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZC5cIiArIHRoaXMuZGVidWdJbmZvKCkpO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8vIERPTSBsZXZlbCAzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFhNTFRleHQucHJvdG90eXBlLCAnaXNFbGVtZW50Q29udGVudFdoaXRlc3BhY2UnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIERPTSBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlwiICsgdGhpcy5kZWJ1Z0luZm8oKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWE1MVGV4dC5wcm90b3R5cGUsICd3aG9sZVRleHQnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbmV4dCwgcHJldiwgc3RyO1xuICAgICAgICBzdHIgPSAnJztcbiAgICAgICAgcHJldiA9IHRoaXMucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB3aGlsZSAocHJldikge1xuICAgICAgICAgIHN0ciA9IHByZXYuZGF0YSArIHN0cjtcbiAgICAgICAgICBwcmV2ID0gcHJldi5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IHRoaXMuZGF0YTtcbiAgICAgICAgbmV4dCA9IHRoaXMubmV4dFNpYmxpbmc7XG4gICAgICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICAgICAgc3RyID0gc3RyICsgbmV4dC5kYXRhO1xuICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gWE1MVGV4dDtcblxuICB9KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAyLjQuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgTm9kZVR5cGUsIFdyaXRlclN0YXRlLCBYTUxDRGF0YSwgWE1MQ29tbWVudCwgWE1MRFREQXR0TGlzdCwgWE1MRFRERWxlbWVudCwgWE1MRFRERW50aXR5LCBYTUxEVEROb3RhdGlvbiwgWE1MRGVjbGFyYXRpb24sIFhNTERvY1R5cGUsIFhNTER1bW15LCBYTUxFbGVtZW50LCBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIFhNTFJhdywgWE1MVGV4dCwgWE1MV3JpdGVyQmFzZSwgYXNzaWduLFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICAoe2Fzc2lnbn0gPSByZXF1aXJlKCcuL1V0aWxpdHknKSk7XG5cbiAgTm9kZVR5cGUgPSByZXF1aXJlKCcuL05vZGVUeXBlJyk7XG5cbiAgWE1MRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL1hNTERlY2xhcmF0aW9uJyk7XG5cbiAgWE1MRG9jVHlwZSA9IHJlcXVpcmUoJy4vWE1MRG9jVHlwZScpO1xuXG4gIFhNTENEYXRhID0gcmVxdWlyZSgnLi9YTUxDRGF0YScpO1xuXG4gIFhNTENvbW1lbnQgPSByZXF1aXJlKCcuL1hNTENvbW1lbnQnKTtcblxuICBYTUxFbGVtZW50ID0gcmVxdWlyZSgnLi9YTUxFbGVtZW50Jyk7XG5cbiAgWE1MUmF3ID0gcmVxdWlyZSgnLi9YTUxSYXcnKTtcblxuICBYTUxUZXh0ID0gcmVxdWlyZSgnLi9YTUxUZXh0Jyk7XG5cbiAgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gcmVxdWlyZSgnLi9YTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24nKTtcblxuICBYTUxEdW1teSA9IHJlcXVpcmUoJy4vWE1MRHVtbXknKTtcblxuICBYTUxEVERBdHRMaXN0ID0gcmVxdWlyZSgnLi9YTUxEVERBdHRMaXN0Jyk7XG5cbiAgWE1MRFRERWxlbWVudCA9IHJlcXVpcmUoJy4vWE1MRFRERWxlbWVudCcpO1xuXG4gIFhNTERUREVudGl0eSA9IHJlcXVpcmUoJy4vWE1MRFRERW50aXR5Jyk7XG5cbiAgWE1MRFRETm90YXRpb24gPSByZXF1aXJlKCcuL1hNTERURE5vdGF0aW9uJyk7XG5cbiAgV3JpdGVyU3RhdGUgPSByZXF1aXJlKCcuL1dyaXRlclN0YXRlJyk7XG5cbiAgLy8gQmFzZSBjbGFzcyBmb3IgWE1MIHdyaXRlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxXcml0ZXJCYXNlID0gY2xhc3MgWE1MV3JpdGVyQmFzZSB7XG4gICAgLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYFhNTFdyaXRlckJhc2VgXG5cbiAgICAvLyBgb3B0aW9ucy5wcmV0dHlgIHByZXR0eSBwcmludHMgdGhlIHJlc3VsdFxuICAgIC8vIGBvcHRpb25zLmluZGVudGAgaW5kZW50YXRpb24gc3RyaW5nXG4gICAgLy8gYG9wdGlvbnMubmV3bGluZWAgbmV3bGluZSBzZXF1ZW5jZVxuICAgIC8vIGBvcHRpb25zLm9mZnNldGAgYSBmaXhlZCBudW1iZXIgb2YgaW5kZW50YXRpb25zIHRvIGFkZCB0byBldmVyeSBsaW5lXG4gICAgLy8gYG9wdGlvbnMud2lkdGhgIG1heGltdW0gY29sdW1uIHdpZHRoXG4gICAgLy8gYG9wdGlvbnMuYWxsb3dFbXB0eWAgZG8gbm90IHNlbGYgY2xvc2UgZW1wdHkgZWxlbWVudCB0YWdzXG4gICAgLy8gJ29wdGlvbnMuZG9udFByZXR0eVRleHROb2RlcycgaWYgYW55IHRleHQgaXMgcHJlc2VudCBpbiBub2RlLCBkb24ndCBpbmRlbnQgb3IgTEZcbiAgICAvLyBgb3B0aW9ucy5zcGFjZUJlZm9yZVNsYXNoYCBhZGQgYSBzcGFjZSBiZWZvcmUgdGhlIGNsb3Npbmcgc2xhc2ggb2YgZW1wdHkgZWxlbWVudHNcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICB2YXIga2V5LCByZWYsIHZhbHVlO1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICByZWYgPSBvcHRpb25zLndyaXRlciB8fCB7fTtcbiAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICB2YWx1ZSA9IHJlZltrZXldO1xuICAgICAgICB0aGlzW1wiX1wiICsga2V5XSA9IHRoaXNba2V5XTtcbiAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmlsdGVycyB3cml0ZXIgb3B0aW9ucyBhbmQgcHJvdmlkZXMgZGVmYXVsdHNcblxuICAgIC8vIGBvcHRpb25zYCB3cml0ZXIgb3B0aW9uc1xuICAgIGZpbHRlck9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIGZpbHRlcmVkT3B0aW9ucywgcmVmLCByZWYxLCByZWYyLCByZWYzLCByZWY0LCByZWY1LCByZWY2LCByZWY3O1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ24oe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICBmaWx0ZXJlZE9wdGlvbnMgPSB7XG4gICAgICAgIHdyaXRlcjogdGhpc1xuICAgICAgfTtcbiAgICAgIGZpbHRlcmVkT3B0aW9ucy5wcmV0dHkgPSBvcHRpb25zLnByZXR0eSB8fCBmYWxzZTtcbiAgICAgIGZpbHRlcmVkT3B0aW9ucy5hbGxvd0VtcHR5ID0gb3B0aW9ucy5hbGxvd0VtcHR5IHx8IGZhbHNlO1xuICAgICAgZmlsdGVyZWRPcHRpb25zLmluZGVudCA9IChyZWYgPSBvcHRpb25zLmluZGVudCkgIT0gbnVsbCA/IHJlZiA6ICcgICc7XG4gICAgICBmaWx0ZXJlZE9wdGlvbnMubmV3bGluZSA9IChyZWYxID0gb3B0aW9ucy5uZXdsaW5lKSAhPSBudWxsID8gcmVmMSA6ICdcXG4nO1xuICAgICAgZmlsdGVyZWRPcHRpb25zLm9mZnNldCA9IChyZWYyID0gb3B0aW9ucy5vZmZzZXQpICE9IG51bGwgPyByZWYyIDogMDtcbiAgICAgIGZpbHRlcmVkT3B0aW9ucy53aWR0aCA9IChyZWYzID0gb3B0aW9ucy53aWR0aCkgIT0gbnVsbCA/IHJlZjMgOiAwO1xuICAgICAgZmlsdGVyZWRPcHRpb25zLmRvbnRQcmV0dHlUZXh0Tm9kZXMgPSAocmVmNCA9IChyZWY1ID0gb3B0aW9ucy5kb250UHJldHR5VGV4dE5vZGVzKSAhPSBudWxsID8gcmVmNSA6IG9wdGlvbnMuZG9udHByZXR0eXRleHRub2RlcykgIT0gbnVsbCA/IHJlZjQgOiAwO1xuICAgICAgZmlsdGVyZWRPcHRpb25zLnNwYWNlQmVmb3JlU2xhc2ggPSAocmVmNiA9IChyZWY3ID0gb3B0aW9ucy5zcGFjZUJlZm9yZVNsYXNoKSAhPSBudWxsID8gcmVmNyA6IG9wdGlvbnMuc3BhY2ViZWZvcmVzbGFzaCkgIT0gbnVsbCA/IHJlZjYgOiAnJztcbiAgICAgIGlmIChmaWx0ZXJlZE9wdGlvbnMuc3BhY2VCZWZvcmVTbGFzaCA9PT0gdHJ1ZSkge1xuICAgICAgICBmaWx0ZXJlZE9wdGlvbnMuc3BhY2VCZWZvcmVTbGFzaCA9ICcgJztcbiAgICAgIH1cbiAgICAgIGZpbHRlcmVkT3B0aW9ucy5zdXBwcmVzc1ByZXR0eUNvdW50ID0gMDtcbiAgICAgIGZpbHRlcmVkT3B0aW9ucy51c2VyID0ge307XG4gICAgICBmaWx0ZXJlZE9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5Ob25lO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkT3B0aW9ucztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHRoZSBpbmRlbnRhdGlvbiBzdHJpbmcgZm9yIHRoZSBjdXJyZW50IGxldmVsXG5cbiAgICAvLyBgbm9kZWAgY3VycmVudCBub2RlXG4gICAgLy8gYG9wdGlvbnNgIHdyaXRlciBvcHRpb25zXG4gICAgLy8gYGxldmVsYCBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsXG4gICAgaW5kZW50KG5vZGUsIG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgaW5kZW50TGV2ZWw7XG4gICAgICBpZiAoIW9wdGlvbnMucHJldHR5IHx8IG9wdGlvbnMuc3VwcHJlc3NQcmV0dHlDb3VudCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucHJldHR5KSB7XG4gICAgICAgIGluZGVudExldmVsID0gKGxldmVsIHx8IDApICsgb3B0aW9ucy5vZmZzZXQgKyAxO1xuICAgICAgICBpZiAoaW5kZW50TGV2ZWwgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBcnJheShpbmRlbnRMZXZlbCkuam9pbihvcHRpb25zLmluZGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHRoZSBuZXdsaW5lIHN0cmluZ1xuXG4gICAgLy8gYG5vZGVgIGN1cnJlbnQgbm9kZVxuICAgIC8vIGBvcHRpb25zYCB3cml0ZXIgb3B0aW9uc1xuICAgIC8vIGBsZXZlbGAgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbFxuICAgIGVuZGxpbmUobm9kZSwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIGlmICghb3B0aW9ucy5wcmV0dHkgfHwgb3B0aW9ucy5zdXBwcmVzc1ByZXR0eUNvdW50KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLm5ld2xpbmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cmlidXRlKGF0dCwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHZhciByO1xuICAgICAgdGhpcy5vcGVuQXR0cmlidXRlKGF0dCwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgaWYgKG9wdGlvbnMucHJldHR5ICYmIG9wdGlvbnMud2lkdGggPiAwKSB7XG4gICAgICAgIHIgPSBhdHQubmFtZSArICc9XCInICsgYXR0LnZhbHVlICsgJ1wiJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgPSAnICcgKyBhdHQubmFtZSArICc9XCInICsgYXR0LnZhbHVlICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xvc2VBdHRyaWJ1dGUoYXR0LCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBjZGF0YShub2RlLCBvcHRpb25zLCBsZXZlbCkge1xuICAgICAgdmFyIHI7XG4gICAgICB0aGlzLm9wZW5Ob2RlKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5PcGVuVGFnO1xuICAgICAgciA9IHRoaXMuaW5kZW50KG5vZGUsIG9wdGlvbnMsIGxldmVsKSArICc8IVtDREFUQVsnO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkluc2lkZVRhZztcbiAgICAgIHIgKz0gbm9kZS52YWx1ZTtcbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5DbG9zZVRhZztcbiAgICAgIHIgKz0gJ11dPicgKyB0aGlzLmVuZGxpbmUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLk5vbmU7XG4gICAgICB0aGlzLmNsb3NlTm9kZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBjb21tZW50KG5vZGUsIG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHRoaXMub3Blbk5vZGUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLk9wZW5UYWc7XG4gICAgICByID0gdGhpcy5pbmRlbnQobm9kZSwgb3B0aW9ucywgbGV2ZWwpICsgJzwhLS0gJztcbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5JbnNpZGVUYWc7XG4gICAgICByICs9IG5vZGUudmFsdWU7XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuQ2xvc2VUYWc7XG4gICAgICByICs9ICcgLS0+JyArIHRoaXMuZW5kbGluZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuTm9uZTtcbiAgICAgIHRoaXMuY2xvc2VOb2RlKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGRlY2xhcmF0aW9uKG5vZGUsIG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHRoaXMub3Blbk5vZGUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLk9wZW5UYWc7XG4gICAgICByID0gdGhpcy5pbmRlbnQobm9kZSwgb3B0aW9ucywgbGV2ZWwpICsgJzw/eG1sJztcbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5JbnNpZGVUYWc7XG4gICAgICByICs9ICcgdmVyc2lvbj1cIicgKyBub2RlLnZlcnNpb24gKyAnXCInO1xuICAgICAgaWYgKG5vZGUuZW5jb2RpbmcgIT0gbnVsbCkge1xuICAgICAgICByICs9ICcgZW5jb2Rpbmc9XCInICsgbm9kZS5lbmNvZGluZyArICdcIic7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5zdGFuZGFsb25lICE9IG51bGwpIHtcbiAgICAgICAgciArPSAnIHN0YW5kYWxvbmU9XCInICsgbm9kZS5zdGFuZGFsb25lICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5DbG9zZVRhZztcbiAgICAgIHIgKz0gb3B0aW9ucy5zcGFjZUJlZm9yZVNsYXNoICsgJz8+JztcbiAgICAgIHIgKz0gdGhpcy5lbmRsaW5lKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5Ob25lO1xuICAgICAgdGhpcy5jbG9zZU5vZGUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZG9jVHlwZShub2RlLCBvcHRpb25zLCBsZXZlbCkge1xuICAgICAgdmFyIGNoaWxkLCBpLCBsZW4xLCByLCByZWY7XG4gICAgICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgICAgIHRoaXMub3Blbk5vZGUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLk9wZW5UYWc7XG4gICAgICByID0gdGhpcy5pbmRlbnQobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgciArPSAnPCFET0NUWVBFICcgKyBub2RlLnJvb3QoKS5uYW1lO1xuICAgICAgLy8gZXh0ZXJuYWwgaWRlbnRpZmllclxuICAgICAgaWYgKG5vZGUucHViSUQgJiYgbm9kZS5zeXNJRCkge1xuICAgICAgICByICs9ICcgUFVCTElDIFwiJyArIG5vZGUucHViSUQgKyAnXCIgXCInICsgbm9kZS5zeXNJRCArICdcIic7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuc3lzSUQpIHtcbiAgICAgICAgciArPSAnIFNZU1RFTSBcIicgKyBub2RlLnN5c0lEICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIC8vIGludGVybmFsIHN1YnNldFxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICByICs9ICcgWyc7XG4gICAgICAgIHIgKz0gdGhpcy5lbmRsaW5lKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkluc2lkZVRhZztcbiAgICAgICAgcmVmID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuMSA9IHJlZi5sZW5ndGg7IGkgPCBsZW4xOyBpKyspIHtcbiAgICAgICAgICBjaGlsZCA9IHJlZltpXTtcbiAgICAgICAgICByICs9IHRoaXMud3JpdGVDaGlsZE5vZGUoY2hpbGQsIG9wdGlvbnMsIGxldmVsICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkNsb3NlVGFnO1xuICAgICAgICByICs9ICddJztcbiAgICAgIH1cbiAgICAgIC8vIGNsb3NlIHRhZ1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkNsb3NlVGFnO1xuICAgICAgciArPSBvcHRpb25zLnNwYWNlQmVmb3JlU2xhc2ggKyAnPic7XG4gICAgICByICs9IHRoaXMuZW5kbGluZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuTm9uZTtcbiAgICAgIHRoaXMuY2xvc2VOb2RlKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGVsZW1lbnQobm9kZSwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHZhciBhdHQsIGF0dExlbiwgY2hpbGQsIGNoaWxkTm9kZUNvdW50LCBmaXJzdENoaWxkTm9kZSwgaSwgaiwgbGVuLCBsZW4xLCBsZW4yLCBuYW1lLCBwcmV0dHlTdXBwcmVzc2VkLCByLCByYXR0LCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHJsaW5lO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBwcmV0dHlTdXBwcmVzc2VkID0gZmFsc2U7XG4gICAgICAvLyBvcGVuIHRhZ1xuICAgICAgdGhpcy5vcGVuTm9kZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuT3BlblRhZztcbiAgICAgIHIgPSB0aGlzLmluZGVudChub2RlLCBvcHRpb25zLCBsZXZlbCkgKyAnPCcgKyBub2RlLm5hbWU7XG4gICAgICAvLyBhdHRyaWJ1dGVzXG4gICAgICBpZiAob3B0aW9ucy5wcmV0dHkgJiYgb3B0aW9ucy53aWR0aCA+IDApIHtcbiAgICAgICAgbGVuID0gci5sZW5ndGg7XG4gICAgICAgIHJlZiA9IG5vZGUuYXR0cmlicztcbiAgICAgICAgZm9yIChuYW1lIGluIHJlZikge1xuICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwgbmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIGF0dCA9IHJlZltuYW1lXTtcbiAgICAgICAgICByYXR0ID0gdGhpcy5hdHRyaWJ1dGUoYXR0LCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICAgICAgYXR0TGVuID0gcmF0dC5sZW5ndGg7XG4gICAgICAgICAgaWYgKGxlbiArIGF0dExlbiA+IG9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgICAgIHJsaW5lID0gdGhpcy5pbmRlbnQobm9kZSwgb3B0aW9ucywgbGV2ZWwgKyAxKSArIHJhdHQ7XG4gICAgICAgICAgICByICs9IHRoaXMuZW5kbGluZShub2RlLCBvcHRpb25zLCBsZXZlbCkgKyBybGluZTtcbiAgICAgICAgICAgIGxlbiA9IHJsaW5lLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmxpbmUgPSAnICcgKyByYXR0O1xuICAgICAgICAgICAgciArPSBybGluZTtcbiAgICAgICAgICAgIGxlbiArPSBybGluZS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWYxID0gbm9kZS5hdHRyaWJzO1xuICAgICAgICBmb3IgKG5hbWUgaW4gcmVmMSkge1xuICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZjEsIG5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICBhdHQgPSByZWYxW25hbWVdO1xuICAgICAgICAgIHIgKz0gdGhpcy5hdHRyaWJ1dGUoYXR0LCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoaWxkTm9kZUNvdW50ID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICBmaXJzdENoaWxkTm9kZSA9IGNoaWxkTm9kZUNvdW50ID09PSAwID8gbnVsbCA6IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICBpZiAoY2hpbGROb2RlQ291bnQgPT09IDAgfHwgbm9kZS5jaGlsZHJlbi5ldmVyeShmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiAoZS50eXBlID09PSBOb2RlVHlwZS5UZXh0IHx8IGUudHlwZSA9PT0gTm9kZVR5cGUuUmF3IHx8IGUudHlwZSA9PT0gTm9kZVR5cGUuQ0RhdGEpICYmIGUudmFsdWUgPT09ICcnO1xuICAgICAgfSkpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudFxuICAgICAgICBpZiAob3B0aW9ucy5hbGxvd0VtcHR5KSB7XG4gICAgICAgICAgciArPSAnPic7XG4gICAgICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkNsb3NlVGFnO1xuICAgICAgICAgIHIgKz0gJzwvJyArIG5vZGUubmFtZSArICc+JyArIHRoaXMuZW5kbGluZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkNsb3NlVGFnO1xuICAgICAgICAgIHIgKz0gb3B0aW9ucy5zcGFjZUJlZm9yZVNsYXNoICsgJy8+JyArIHRoaXMuZW5kbGluZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wcmV0dHkgJiYgY2hpbGROb2RlQ291bnQgPT09IDEgJiYgKGZpcnN0Q2hpbGROb2RlLnR5cGUgPT09IE5vZGVUeXBlLlRleHQgfHwgZmlyc3RDaGlsZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuUmF3IHx8IGZpcnN0Q2hpbGROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkNEYXRhKSAmJiAoZmlyc3RDaGlsZE5vZGUudmFsdWUgIT0gbnVsbCkpIHtcbiAgICAgICAgLy8gZG8gbm90IGluZGVudCB0ZXh0LW9ubHkgbm9kZXNcbiAgICAgICAgciArPSAnPic7XG4gICAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5JbnNpZGVUYWc7XG4gICAgICAgIG9wdGlvbnMuc3VwcHJlc3NQcmV0dHlDb3VudCsrO1xuICAgICAgICBwcmV0dHlTdXBwcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgciArPSB0aGlzLndyaXRlQ2hpbGROb2RlKGZpcnN0Q2hpbGROb2RlLCBvcHRpb25zLCBsZXZlbCArIDEpO1xuICAgICAgICBvcHRpb25zLnN1cHByZXNzUHJldHR5Q291bnQtLTtcbiAgICAgICAgcHJldHR5U3VwcHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuQ2xvc2VUYWc7XG4gICAgICAgIHIgKz0gJzwvJyArIG5vZGUubmFtZSArICc+JyArIHRoaXMuZW5kbGluZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBBTlkgYXJlIGEgdGV4dCBub2RlLCB0aGVuIHN1cHByZXNzIHByZXR0eSBub3dcbiAgICAgICAgaWYgKG9wdGlvbnMuZG9udFByZXR0eVRleHROb2Rlcykge1xuICAgICAgICAgIHJlZjIgPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbjEgPSByZWYyLmxlbmd0aDsgaSA8IGxlbjE7IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSByZWYyW2ldO1xuICAgICAgICAgICAgaWYgKChjaGlsZC50eXBlID09PSBOb2RlVHlwZS5UZXh0IHx8IGNoaWxkLnR5cGUgPT09IE5vZGVUeXBlLlJhdyB8fCBjaGlsZC50eXBlID09PSBOb2RlVHlwZS5DRGF0YSkgJiYgKGNoaWxkLnZhbHVlICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuc3VwcHJlc3NQcmV0dHlDb3VudCsrO1xuICAgICAgICAgICAgICBwcmV0dHlTdXBwcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNsb3NlIHRoZSBvcGVuaW5nIHRhZywgYWZ0ZXIgZGVhbGluZyB3aXRoIG5ld2xpbmVcbiAgICAgICAgciArPSAnPicgKyB0aGlzLmVuZGxpbmUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuSW5zaWRlVGFnO1xuICAgICAgICByZWYzID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgLy8gaW5uZXIgdGFnc1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4yID0gcmVmMy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgICBjaGlsZCA9IHJlZjNbal07XG4gICAgICAgICAgciArPSB0aGlzLndyaXRlQ2hpbGROb2RlKGNoaWxkLCBvcHRpb25zLCBsZXZlbCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsb3NlIHRhZ1xuICAgICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuQ2xvc2VUYWc7XG4gICAgICAgIHIgKz0gdGhpcy5pbmRlbnQobm9kZSwgb3B0aW9ucywgbGV2ZWwpICsgJzwvJyArIG5vZGUubmFtZSArICc+JztcbiAgICAgICAgaWYgKHByZXR0eVN1cHByZXNzZWQpIHtcbiAgICAgICAgICBvcHRpb25zLnN1cHByZXNzUHJldHR5Q291bnQtLTtcbiAgICAgICAgfVxuICAgICAgICByICs9IHRoaXMuZW5kbGluZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5Ob25lO1xuICAgICAgfVxuICAgICAgdGhpcy5jbG9zZU5vZGUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgd3JpdGVDaGlsZE5vZGUobm9kZSwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuQ0RhdGE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2RhdGEobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgICBjYXNlIE5vZGVUeXBlLkNvbW1lbnQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tbWVudChub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRWxlbWVudDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50KG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5SYXc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmF3KG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5UZXh0OlxuICAgICAgICAgIHJldHVybiB0aGlzLnRleHQobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgICBjYXNlIE5vZGVUeXBlLlByb2Nlc3NpbmdJbnN0cnVjdGlvbjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24obm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgICBjYXNlIE5vZGVUeXBlLkR1bW15OlxuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5EZWNsYXJhdGlvbjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNsYXJhdGlvbihub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRG9jVHlwZTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kb2NUeXBlKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5BdHRyaWJ1dGVEZWNsYXJhdGlvbjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kdGRBdHRMaXN0KG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5FbGVtZW50RGVjbGFyYXRpb246XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHRkRWxlbWVudChub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICAgIGNhc2UgTm9kZVR5cGUuRW50aXR5RGVjbGFyYXRpb246XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZHRkRW50aXR5KG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5Ob3RhdGlvbkRlY2xhcmF0aW9uOlxuICAgICAgICAgIHJldHVybiB0aGlzLmR0ZE5vdGF0aW9uKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIFhNTCBub2RlIHR5cGU6IFwiICsgbm9kZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb24obm9kZSwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHZhciByO1xuICAgICAgdGhpcy5vcGVuTm9kZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuT3BlblRhZztcbiAgICAgIHIgPSB0aGlzLmluZGVudChub2RlLCBvcHRpb25zLCBsZXZlbCkgKyAnPD8nO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkluc2lkZVRhZztcbiAgICAgIHIgKz0gbm9kZS50YXJnZXQ7XG4gICAgICBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICByICs9ICcgJyArIG5vZGUudmFsdWU7XG4gICAgICB9XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuQ2xvc2VUYWc7XG4gICAgICByICs9IG9wdGlvbnMuc3BhY2VCZWZvcmVTbGFzaCArICc/Pic7XG4gICAgICByICs9IHRoaXMuZW5kbGluZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuTm9uZTtcbiAgICAgIHRoaXMuY2xvc2VOb2RlKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIHJhdyhub2RlLCBvcHRpb25zLCBsZXZlbCkge1xuICAgICAgdmFyIHI7XG4gICAgICB0aGlzLm9wZW5Ob2RlKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5PcGVuVGFnO1xuICAgICAgciA9IHRoaXMuaW5kZW50KG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5JbnNpZGVUYWc7XG4gICAgICByICs9IG5vZGUudmFsdWU7XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuQ2xvc2VUYWc7XG4gICAgICByICs9IHRoaXMuZW5kbGluZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuTm9uZTtcbiAgICAgIHRoaXMuY2xvc2VOb2RlKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIHRleHQobm9kZSwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHZhciByO1xuICAgICAgdGhpcy5vcGVuTm9kZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuT3BlblRhZztcbiAgICAgIHIgPSB0aGlzLmluZGVudChub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuSW5zaWRlVGFnO1xuICAgICAgciArPSBub2RlLnZhbHVlO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkNsb3NlVGFnO1xuICAgICAgciArPSB0aGlzLmVuZGxpbmUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLk5vbmU7XG4gICAgICB0aGlzLmNsb3NlTm9kZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBkdGRBdHRMaXN0KG5vZGUsIG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHRoaXMub3Blbk5vZGUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLk9wZW5UYWc7XG4gICAgICByID0gdGhpcy5pbmRlbnQobm9kZSwgb3B0aW9ucywgbGV2ZWwpICsgJzwhQVRUTElTVCc7XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuSW5zaWRlVGFnO1xuICAgICAgciArPSAnICcgKyBub2RlLmVsZW1lbnROYW1lICsgJyAnICsgbm9kZS5hdHRyaWJ1dGVOYW1lICsgJyAnICsgbm9kZS5hdHRyaWJ1dGVUeXBlO1xuICAgICAgaWYgKG5vZGUuZGVmYXVsdFZhbHVlVHlwZSAhPT0gJyNERUZBVUxUJykge1xuICAgICAgICByICs9ICcgJyArIG5vZGUuZGVmYXVsdFZhbHVlVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByICs9ICcgXCInICsgbm9kZS5kZWZhdWx0VmFsdWUgKyAnXCInO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkNsb3NlVGFnO1xuICAgICAgciArPSBvcHRpb25zLnNwYWNlQmVmb3JlU2xhc2ggKyAnPicgKyB0aGlzLmVuZGxpbmUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLk5vbmU7XG4gICAgICB0aGlzLmNsb3NlTm9kZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBkdGRFbGVtZW50KG5vZGUsIG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIHRoaXMub3Blbk5vZGUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLk9wZW5UYWc7XG4gICAgICByID0gdGhpcy5pbmRlbnQobm9kZSwgb3B0aW9ucywgbGV2ZWwpICsgJzwhRUxFTUVOVCc7XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuSW5zaWRlVGFnO1xuICAgICAgciArPSAnICcgKyBub2RlLm5hbWUgKyAnICcgKyBub2RlLnZhbHVlO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkNsb3NlVGFnO1xuICAgICAgciArPSBvcHRpb25zLnNwYWNlQmVmb3JlU2xhc2ggKyAnPicgKyB0aGlzLmVuZGxpbmUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLk5vbmU7XG4gICAgICB0aGlzLmNsb3NlTm9kZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBkdGRFbnRpdHkobm9kZSwgb3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHZhciByO1xuICAgICAgdGhpcy5vcGVuTm9kZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICBvcHRpb25zLnN0YXRlID0gV3JpdGVyU3RhdGUuT3BlblRhZztcbiAgICAgIHIgPSB0aGlzLmluZGVudChub2RlLCBvcHRpb25zLCBsZXZlbCkgKyAnPCFFTlRJVFknO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkluc2lkZVRhZztcbiAgICAgIGlmIChub2RlLnBlKSB7XG4gICAgICAgIHIgKz0gJyAlJztcbiAgICAgIH1cbiAgICAgIHIgKz0gJyAnICsgbm9kZS5uYW1lO1xuICAgICAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICAgICAgciArPSAnIFwiJyArIG5vZGUudmFsdWUgKyAnXCInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGUucHViSUQgJiYgbm9kZS5zeXNJRCkge1xuICAgICAgICAgIHIgKz0gJyBQVUJMSUMgXCInICsgbm9kZS5wdWJJRCArICdcIiBcIicgKyBub2RlLnN5c0lEICsgJ1wiJztcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnN5c0lEKSB7XG4gICAgICAgICAgciArPSAnIFNZU1RFTSBcIicgKyBub2RlLnN5c0lEICsgJ1wiJztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5uRGF0YSkge1xuICAgICAgICAgIHIgKz0gJyBOREFUQSAnICsgbm9kZS5uRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLkNsb3NlVGFnO1xuICAgICAgciArPSBvcHRpb25zLnNwYWNlQmVmb3JlU2xhc2ggKyAnPicgKyB0aGlzLmVuZGxpbmUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgb3B0aW9ucy5zdGF0ZSA9IFdyaXRlclN0YXRlLk5vbmU7XG4gICAgICB0aGlzLmNsb3NlTm9kZShub2RlLCBvcHRpb25zLCBsZXZlbCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBkdGROb3RhdGlvbihub2RlLCBvcHRpb25zLCBsZXZlbCkge1xuICAgICAgdmFyIHI7XG4gICAgICB0aGlzLm9wZW5Ob2RlKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5PcGVuVGFnO1xuICAgICAgciA9IHRoaXMuaW5kZW50KG5vZGUsIG9wdGlvbnMsIGxldmVsKSArICc8IU5PVEFUSU9OJztcbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5JbnNpZGVUYWc7XG4gICAgICByICs9ICcgJyArIG5vZGUubmFtZTtcbiAgICAgIGlmIChub2RlLnB1YklEICYmIG5vZGUuc3lzSUQpIHtcbiAgICAgICAgciArPSAnIFBVQkxJQyBcIicgKyBub2RlLnB1YklEICsgJ1wiIFwiJyArIG5vZGUuc3lzSUQgKyAnXCInO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnB1YklEKSB7XG4gICAgICAgIHIgKz0gJyBQVUJMSUMgXCInICsgbm9kZS5wdWJJRCArICdcIic7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuc3lzSUQpIHtcbiAgICAgICAgciArPSAnIFNZU1RFTSBcIicgKyBub2RlLnN5c0lEICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5DbG9zZVRhZztcbiAgICAgIHIgKz0gb3B0aW9ucy5zcGFjZUJlZm9yZVNsYXNoICsgJz4nICsgdGhpcy5lbmRsaW5lKG5vZGUsIG9wdGlvbnMsIGxldmVsKTtcbiAgICAgIG9wdGlvbnMuc3RhdGUgPSBXcml0ZXJTdGF0ZS5Ob25lO1xuICAgICAgdGhpcy5jbG9zZU5vZGUobm9kZSwgb3B0aW9ucywgbGV2ZWwpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgb3Blbk5vZGUobm9kZSwgb3B0aW9ucywgbGV2ZWwpIHt9XG5cbiAgICBjbG9zZU5vZGUobm9kZSwgb3B0aW9ucywgbGV2ZWwpIHt9XG5cbiAgICBvcGVuQXR0cmlidXRlKGF0dCwgb3B0aW9ucywgbGV2ZWwpIHt9XG5cbiAgICBjbG9zZUF0dHJpYnV0ZShhdHQsIG9wdGlvbnMsIGxldmVsKSB7fVxuXG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDIuNC4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBOb2RlVHlwZSwgV3JpdGVyU3RhdGUsIFhNTERPTUltcGxlbWVudGF0aW9uLCBYTUxEb2N1bWVudCwgWE1MRG9jdW1lbnRDQiwgWE1MU3RyZWFtV3JpdGVyLCBYTUxTdHJpbmdXcml0ZXIsIGFzc2lnbiwgaXNGdW5jdGlvbjtcblxuICAoe2Fzc2lnbiwgaXNGdW5jdGlvbn0gPSByZXF1aXJlKCcuL1V0aWxpdHknKSk7XG5cbiAgWE1MRE9NSW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL1hNTERPTUltcGxlbWVudGF0aW9uJyk7XG5cbiAgWE1MRG9jdW1lbnQgPSByZXF1aXJlKCcuL1hNTERvY3VtZW50Jyk7XG5cbiAgWE1MRG9jdW1lbnRDQiA9IHJlcXVpcmUoJy4vWE1MRG9jdW1lbnRDQicpO1xuXG4gIFhNTFN0cmluZ1dyaXRlciA9IHJlcXVpcmUoJy4vWE1MU3RyaW5nV3JpdGVyJyk7XG5cbiAgWE1MU3RyZWFtV3JpdGVyID0gcmVxdWlyZSgnLi9YTUxTdHJlYW1Xcml0ZXInKTtcblxuICBOb2RlVHlwZSA9IHJlcXVpcmUoJy4vTm9kZVR5cGUnKTtcblxuICBXcml0ZXJTdGF0ZSA9IHJlcXVpcmUoJy4vV3JpdGVyU3RhdGUnKTtcblxuICAvLyBDcmVhdGVzIGEgbmV3IGRvY3VtZW50IGFuZCByZXR1cm5zIHRoZSByb290IG5vZGUgZm9yXG4gIC8vIGNoYWluLWJ1aWxkaW5nIHRoZSBkb2N1bWVudCB0cmVlXG5cbiAgLy8gYG5hbWVgIG5hbWUgb2YgdGhlIHJvb3QgZWxlbWVudFxuXG4gIC8vIGB4bWxkZWMudmVyc2lvbmAgQSB2ZXJzaW9uIG51bWJlciBzdHJpbmcsIGUuZy4gMS4wXG4gIC8vIGB4bWxkZWMuZW5jb2RpbmdgIEVuY29kaW5nIGRlY2xhcmF0aW9uLCBlLmcuIFVURi04XG4gIC8vIGB4bWxkZWMuc3RhbmRhbG9uZWAgc3RhbmRhbG9uZSBkb2N1bWVudCBkZWNsYXJhdGlvbjogdHJ1ZSBvciBmYWxzZVxuXG4gIC8vIGBkb2N0eXBlLnB1YklEYCBwdWJsaWMgaWRlbnRpZmllciBvZiB0aGUgZXh0ZXJuYWwgc3Vic2V0XG4gIC8vIGBkb2N0eXBlLnN5c0lEYCBzeXN0ZW0gaWRlbnRpZmllciBvZiB0aGUgZXh0ZXJuYWwgc3Vic2V0XG5cbiAgLy8gYG9wdGlvbnMuaGVhZGxlc3NgIHdoZXRoZXIgWE1MIGRlY2xhcmF0aW9uIGFuZCBkb2N0eXBlIHdpbGwgYmUgaW5jbHVkZWQ6XG4gIC8vICAgICB0cnVlIG9yIGZhbHNlXG4gIC8vIGBvcHRpb25zLmtlZXBOdWxsTm9kZXNgIHdoZXRoZXIgbm9kZXMgd2l0aCBudWxsIHZhbHVlcyB3aWxsIGJlIGtlcHRcbiAgLy8gICAgIG9yIGlnbm9yZWQ6IHRydWUgb3IgZmFsc2VcbiAgLy8gYG9wdGlvbnMua2VlcE51bGxBdHRyaWJ1dGVzYCB3aGV0aGVyIGF0dHJpYnV0ZXMgd2l0aCBudWxsIHZhbHVlcyB3aWxsIGJlXG4gIC8vICAgICBrZXB0IG9yIGlnbm9yZWQ6IHRydWUgb3IgZmFsc2VcbiAgLy8gYG9wdGlvbnMuaWdub3JlRGVjb3JhdG9yc2Agd2hldGhlciBkZWNvcmF0b3Igc3RyaW5ncyB3aWxsIGJlIGlnbm9yZWQgd2hlblxuICAvLyAgICAgY29udmVydGluZyBKUyBvYmplY3RzOiB0cnVlIG9yIGZhbHNlXG4gIC8vIGBvcHRpb25zLnNlcGFyYXRlQXJyYXlJdGVtc2Agd2hldGhlciBhcnJheSBpdGVtcyBhcmUgY3JlYXRlZCBhcyBzZXBhcmF0ZVxuICAvLyAgICAgbm9kZXMgd2hlbiBwYXNzZWQgYXMgYW4gb2JqZWN0IHZhbHVlOiB0cnVlIG9yIGZhbHNlXG4gIC8vIGBvcHRpb25zLm5vRG91YmxlRW5jb2RpbmdgIHdoZXRoZXIgZXhpc3RpbmcgaHRtbCBlbnRpdGllcyBhcmUgZW5jb2RlZDpcbiAgLy8gICAgIHRydWUgb3IgZmFsc2VcbiAgLy8gYG9wdGlvbnMuc3RyaW5naWZ5YCBhIHNldCBvZiBmdW5jdGlvbnMgdG8gdXNlIGZvciBjb252ZXJ0aW5nIHZhbHVlcyB0b1xuICAvLyAgICAgc3RyaW5nc1xuICAvLyBgb3B0aW9ucy53cml0ZXJgIHRoZSBkZWZhdWx0IFhNTCB3cml0ZXIgdG8gdXNlIGZvciBjb252ZXJ0aW5nIG5vZGVzIHRvXG4gIC8vICAgICBzdHJpbmcuIElmIHRoZSBkZWZhdWx0IHdyaXRlciBpcyBub3Qgc2V0LCB0aGUgYnVpbHQtaW4gWE1MU3RyaW5nV3JpdGVyXG4gIC8vICAgICB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cbiAgbW9kdWxlLmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24obmFtZSwgeG1sZGVjLCBkb2N0eXBlLCBvcHRpb25zKSB7XG4gICAgdmFyIGRvYywgcm9vdDtcbiAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IGVsZW1lbnQgbmVlZHMgYSBuYW1lLlwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IGFzc2lnbih7fSwgeG1sZGVjLCBkb2N0eXBlLCBvcHRpb25zKTtcbiAgICAvLyBjcmVhdGUgdGhlIGRvY3VtZW50IG5vZGVcbiAgICBkb2MgPSBuZXcgWE1MRG9jdW1lbnQob3B0aW9ucyk7XG4gICAgLy8gYWRkIHRoZSByb290IG5vZGVcbiAgICByb290ID0gZG9jLmVsZW1lbnQobmFtZSk7XG4gICAgLy8gcHJvbG9nXG4gICAgaWYgKCFvcHRpb25zLmhlYWRsZXNzKSB7XG4gICAgICBkb2MuZGVjbGFyYXRpb24ob3B0aW9ucyk7XG4gICAgICBpZiAoKG9wdGlvbnMucHViSUQgIT0gbnVsbCkgfHwgKG9wdGlvbnMuc3lzSUQgIT0gbnVsbCkpIHtcbiAgICAgICAgZG9jLmR0ZChvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH07XG5cbiAgLy8gQ3JlYXRlcyBhIG5ldyBkb2N1bWVudCBhbmQgcmV0dXJucyB0aGUgZG9jdW1lbnQgbm9kZSBmb3JcbiAgLy8gY2hhaW4tYnVpbGRpbmcgdGhlIGRvY3VtZW50IHRyZWVcblxuICAvLyBgb3B0aW9ucy5rZWVwTnVsbE5vZGVzYCB3aGV0aGVyIG5vZGVzIHdpdGggbnVsbCB2YWx1ZXMgd2lsbCBiZSBrZXB0XG4gIC8vICAgICBvciBpZ25vcmVkOiB0cnVlIG9yIGZhbHNlXG4gIC8vIGBvcHRpb25zLmtlZXBOdWxsQXR0cmlidXRlc2Agd2hldGhlciBhdHRyaWJ1dGVzIHdpdGggbnVsbCB2YWx1ZXMgd2lsbCBiZVxuICAvLyAgICAga2VwdCBvciBpZ25vcmVkOiB0cnVlIG9yIGZhbHNlXG4gIC8vIGBvcHRpb25zLmlnbm9yZURlY29yYXRvcnNgIHdoZXRoZXIgZGVjb3JhdG9yIHN0cmluZ3Mgd2lsbCBiZSBpZ25vcmVkIHdoZW5cbiAgLy8gICAgIGNvbnZlcnRpbmcgSlMgb2JqZWN0czogdHJ1ZSBvciBmYWxzZVxuICAvLyBgb3B0aW9ucy5zZXBhcmF0ZUFycmF5SXRlbXNgIHdoZXRoZXIgYXJyYXkgaXRlbXMgYXJlIGNyZWF0ZWQgYXMgc2VwYXJhdGVcbiAgLy8gICAgIG5vZGVzIHdoZW4gcGFzc2VkIGFzIGFuIG9iamVjdCB2YWx1ZTogdHJ1ZSBvciBmYWxzZVxuICAvLyBgb3B0aW9ucy5ub0RvdWJsZUVuY29kaW5nYCB3aGV0aGVyIGV4aXN0aW5nIGh0bWwgZW50aXRpZXMgYXJlIGVuY29kZWQ6XG4gIC8vICAgICB0cnVlIG9yIGZhbHNlXG4gIC8vIGBvcHRpb25zLnN0cmluZ2lmeWAgYSBzZXQgb2YgZnVuY3Rpb25zIHRvIHVzZSBmb3IgY29udmVydGluZyB2YWx1ZXMgdG9cbiAgLy8gICAgIHN0cmluZ3NcbiAgLy8gYG9wdGlvbnMud3JpdGVyYCB0aGUgZGVmYXVsdCBYTUwgd3JpdGVyIHRvIHVzZSBmb3IgY29udmVydGluZyBub2RlcyB0b1xuICAvLyAgICAgc3RyaW5nLiBJZiB0aGUgZGVmYXVsdCB3cml0ZXIgaXMgbm90IHNldCwgdGhlIGJ1aWx0LWluIFhNTFN0cmluZ1dyaXRlclxuICAvLyAgICAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXG5cbiAgLy8gYG9uRGF0YWAgdGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIGEgbmV3IGNodW5rIG9mIFhNTCBpcyBvdXRwdXQuIFRoZVxuICAvLyAgICAgICAgICBzdHJpbmcgY29udGFpbmluZyB0aGUgWE1MIGNodW5rIGlzIHBhc3NlZCB0byBgb25EYXRhYCBhcyBpdHMgc2luZ2xlXG4gIC8vICAgICAgICAgIGFyZ3VtZW50LlxuICAvLyBgb25FbmRgICB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIFhNTCBkb2N1bWVudCBpcyBjb21wbGV0ZWQgd2l0aFxuICAvLyAgICAgICAgICBgZW5kYC4gYG9uRW5kYCBkb2VzIG5vdCByZWNlaXZlIGFueSBhcmd1bWVudHMuXG4gIG1vZHVsZS5leHBvcnRzLmJlZ2luID0gZnVuY3Rpb24ob3B0aW9ucywgb25EYXRhLCBvbkVuZCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICBbb25EYXRhLCBvbkVuZF0gPSBbb3B0aW9ucywgb25EYXRhXTtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKG9uRGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBYTUxEb2N1bWVudENCKG9wdGlvbnMsIG9uRGF0YSwgb25FbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFhNTERvY3VtZW50KG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5zdHJpbmdXcml0ZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBYTUxTdHJpbmdXcml0ZXIob3B0aW9ucyk7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuc3RyZWFtV3JpdGVyID0gZnVuY3Rpb24oc3RyZWFtLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBYTUxTdHJlYW1Xcml0ZXIoc3RyZWFtLCBvcHRpb25zKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5pbXBsZW1lbnRhdGlvbiA9IG5ldyBYTUxET01JbXBsZW1lbnRhdGlvbigpO1xuXG4gIG1vZHVsZS5leHBvcnRzLm5vZGVUeXBlID0gTm9kZVR5cGU7XG5cbiAgbW9kdWxlLmV4cG9ydHMud3JpdGVyU3RhdGUgPSBXcml0ZXJTdGF0ZTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgeyBtYWtlTXVzaWMsIGJ1aWxkVGFibGVzLCBtYWtlTWVsb2R5IH0gZnJvbSBcIi4vc3JjL2Nob3Jkc1wiXG5pbXBvcnQgeyBsb2FkUGxheWVyIH0gZnJvbSBcIi4vc3JjL3BsYXllclwiXG5pbXBvcnQgeyB0b1htbCB9IGZyb20gXCIuL3NyYy9tdXNpY3htbGdlblwiXG5pbXBvcnQgeyBEaXZpc2lvbmVkUmljaG5vdGVzLCBNYWluTXVzaWNQYXJhbXMsIE11c2ljUGFyYW1zIH0gZnJvbSBcIi4vc3JjL3V0aWxzXCI7XG5cbmJ1aWxkVGFibGVzKClcblxuc2VsZi5vbm1lc3NhZ2UgPSAoZXZlbnQ6IHsgZGF0YTogeyBwYXJhbXM6IHN0cmluZywgbmV3TWVsb2R5OiB1bmRlZmluZWQgfCBib29sZWFuLCBnaXZlVXA6IHVuZGVmaW5lZCB8IGJvb2xlYW4gfSB9KSA9PiB7XG4gICAgY29uc3QgcGFyYW1zID0gbmV3IE1haW5NdXNpY1BhcmFtcyhKU09OLnBhcnNlKGV2ZW50LmRhdGEucGFyYW1zIHx8IFwie31cIikpO1xuXG4gICAgaWYgKGV2ZW50LmRhdGEubmV3TWVsb2R5KSB7XG4gICAgICAgIG1ha2VNZWxvZHkoKHNlbGYgYXMgYW55KS5kaXZpc2lvbmVkTm90ZXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJ4bWxcIik7XG4gICAgICAgIGNvbnN0IHNjb3JlWE1MID0gdG9YbWwoKHNlbGYgYXMgYW55KS5kaXZpc2lvbmVkTm90ZXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe3htbDogc2NvcmVYTUx9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5kYXRhLmdpdmVVcCkge1xuICAgICAgICAoc2VsZiBhcyBhbnkpLmdpdmVVUCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcHJvbWlzZTogUHJvbWlzZTxhbnk+O1xuICAgIGNvbnN0IHByb2dyZXNzQ2FsbGJhY2sgPSAoY3VycmVudEJlYXQ6IG51bWJlciwgcmljaE5vdGVzOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnRCZWF0ICE9IG51bGwgJiYgcmljaE5vdGVzICYmIHJpY2hOb3Rlc1swXSAmJiByaWNoTm90ZXNbMF0uY2hvcmQpIHtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe3Byb2dyZXNzOiB7Y3VycmVudEJlYXQsIGNob3JkOiByaWNoTm90ZXNbMF0uY2hvcmQudG9TdHJpbmcoKX19KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHNlbGYgYXMgYW55KS5naXZlVVApIHtcbiAgICAgICAgICAgIHJldHVybiBcImdpdmVVUFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1ha2VNdXNpYyhwYXJhbXMsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCBkaXZpc2lvbmVkTm90ZXM6IERpdmlzaW9uZWRSaWNobm90ZXMgPSByZXN1bHQuZGl2aXNpb25lZE5vdGVzO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGl2aXNpb25lZE5vdGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoc2VsZiBhcyBhbnkpLmRpdmlzaW9uZWROb3RlcyA9IGRpdmlzaW9uZWROb3RlcztcbiAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChcInhtbFwiKTtcbiAgICAgICAgY29uc3Qgc2NvcmVYTUwgPSB0b1htbChkaXZpc2lvbmVkTm90ZXMsIHBhcmFtcyk7XG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe3htbDogc2NvcmVYTUx9KTtcblxuXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe2Vycm9yOiBlcnJ9KTtcbiAgICB9KTtcblxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==